// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/harness/gitness/registry/app/api/openapi/contracts/artifact"
	"github.com/harness/gitness/registry/types"

	mock "github.com/stretchr/testify/mock"
)

// NewMockPackageWrapper creates a new instance of MockPackageWrapper. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPackageWrapper(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPackageWrapper {
	mock := &MockPackageWrapper{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPackageWrapper is an autogenerated mock type for the PackageWrapper type
type MockPackageWrapper struct {
	mock.Mock
}

type MockPackageWrapper_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPackageWrapper) EXPECT() *MockPackageWrapper_Expecter {
	return &MockPackageWrapper_Expecter{mock: &_m.Mock}
}

// DeleteArtifact provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) DeleteArtifact(ctx context.Context, regInfo *types.RegistryRequestBaseInfo, artifactName string) error {
	ret := _mock.Called(ctx, regInfo, artifactName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteArtifact")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.RegistryRequestBaseInfo, string) error); ok {
		r0 = returnFunc(ctx, regInfo, artifactName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPackageWrapper_DeleteArtifact_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteArtifact'
type MockPackageWrapper_DeleteArtifact_Call struct {
	*mock.Call
}

// DeleteArtifact is a helper method to define mock.On call
//   - ctx context.Context
//   - regInfo *types.RegistryRequestBaseInfo
//   - artifactName string
func (_e *MockPackageWrapper_Expecter) DeleteArtifact(ctx interface{}, regInfo interface{}, artifactName interface{}) *MockPackageWrapper_DeleteArtifact_Call {
	return &MockPackageWrapper_DeleteArtifact_Call{Call: _e.mock.On("DeleteArtifact", ctx, regInfo, artifactName)}
}

func (_c *MockPackageWrapper_DeleteArtifact_Call) Run(run func(ctx context.Context, regInfo *types.RegistryRequestBaseInfo, artifactName string)) *MockPackageWrapper_DeleteArtifact_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *types.RegistryRequestBaseInfo
		if args[1] != nil {
			arg1 = args[1].(*types.RegistryRequestBaseInfo)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_DeleteArtifact_Call) Return(err error) *MockPackageWrapper_DeleteArtifact_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPackageWrapper_DeleteArtifact_Call) RunAndReturn(run func(ctx context.Context, regInfo *types.RegistryRequestBaseInfo, artifactName string) error) *MockPackageWrapper_DeleteArtifact_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteArtifactVersion provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) DeleteArtifactVersion(ctx context.Context, regInfo *types.RegistryRequestBaseInfo, imageInfo *types.Image, artifactName string, versionName string) error {
	ret := _mock.Called(ctx, regInfo, imageInfo, artifactName, versionName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteArtifactVersion")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.RegistryRequestBaseInfo, *types.Image, string, string) error); ok {
		r0 = returnFunc(ctx, regInfo, imageInfo, artifactName, versionName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPackageWrapper_DeleteArtifactVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteArtifactVersion'
type MockPackageWrapper_DeleteArtifactVersion_Call struct {
	*mock.Call
}

// DeleteArtifactVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - regInfo *types.RegistryRequestBaseInfo
//   - imageInfo *types.Image
//   - artifactName string
//   - versionName string
func (_e *MockPackageWrapper_Expecter) DeleteArtifactVersion(ctx interface{}, regInfo interface{}, imageInfo interface{}, artifactName interface{}, versionName interface{}) *MockPackageWrapper_DeleteArtifactVersion_Call {
	return &MockPackageWrapper_DeleteArtifactVersion_Call{Call: _e.mock.On("DeleteArtifactVersion", ctx, regInfo, imageInfo, artifactName, versionName)}
}

func (_c *MockPackageWrapper_DeleteArtifactVersion_Call) Run(run func(ctx context.Context, regInfo *types.RegistryRequestBaseInfo, imageInfo *types.Image, artifactName string, versionName string)) *MockPackageWrapper_DeleteArtifactVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *types.RegistryRequestBaseInfo
		if args[1] != nil {
			arg1 = args[1].(*types.RegistryRequestBaseInfo)
		}
		var arg2 *types.Image
		if args[2] != nil {
			arg2 = args[2].(*types.Image)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_DeleteArtifactVersion_Call) Return(err error) *MockPackageWrapper_DeleteArtifactVersion_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPackageWrapper_DeleteArtifactVersion_Call) RunAndReturn(run func(ctx context.Context, regInfo *types.RegistryRequestBaseInfo, imageInfo *types.Image, artifactName string, versionName string) error) *MockPackageWrapper_DeleteArtifactVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetArtifactDetail provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) GetArtifactDetail(packageType string, img *types.Image, art *types.Artifact, downloadCount int64) (*artifact.ArtifactDetail, error) {
	ret := _mock.Called(packageType, img, art, downloadCount)

	if len(ret) == 0 {
		panic("no return value specified for GetArtifactDetail")
	}

	var r0 *artifact.ArtifactDetail
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, *types.Image, *types.Artifact, int64) (*artifact.ArtifactDetail, error)); ok {
		return returnFunc(packageType, img, art, downloadCount)
	}
	if returnFunc, ok := ret.Get(0).(func(string, *types.Image, *types.Artifact, int64) *artifact.ArtifactDetail); ok {
		r0 = returnFunc(packageType, img, art, downloadCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.ArtifactDetail)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, *types.Image, *types.Artifact, int64) error); ok {
		r1 = returnFunc(packageType, img, art, downloadCount)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackageWrapper_GetArtifactDetail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetArtifactDetail'
type MockPackageWrapper_GetArtifactDetail_Call struct {
	*mock.Call
}

// GetArtifactDetail is a helper method to define mock.On call
//   - packageType string
//   - img *types.Image
//   - art *types.Artifact
//   - downloadCount int64
func (_e *MockPackageWrapper_Expecter) GetArtifactDetail(packageType interface{}, img interface{}, art interface{}, downloadCount interface{}) *MockPackageWrapper_GetArtifactDetail_Call {
	return &MockPackageWrapper_GetArtifactDetail_Call{Call: _e.mock.On("GetArtifactDetail", packageType, img, art, downloadCount)}
}

func (_c *MockPackageWrapper_GetArtifactDetail_Call) Run(run func(packageType string, img *types.Image, art *types.Artifact, downloadCount int64)) *MockPackageWrapper_GetArtifactDetail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 *types.Image
		if args[1] != nil {
			arg1 = args[1].(*types.Image)
		}
		var arg2 *types.Artifact
		if args[2] != nil {
			arg2 = args[2].(*types.Artifact)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_GetArtifactDetail_Call) Return(artifactDetail *artifact.ArtifactDetail, err error) *MockPackageWrapper_GetArtifactDetail_Call {
	_c.Call.Return(artifactDetail, err)
	return _c
}

func (_c *MockPackageWrapper_GetArtifactDetail_Call) RunAndReturn(run func(packageType string, img *types.Image, art *types.Artifact, downloadCount int64) (*artifact.ArtifactDetail, error)) *MockPackageWrapper_GetArtifactDetail_Call {
	_c.Call.Return(run)
	return _c
}

// GetArtifactMetadata provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) GetArtifactMetadata(artifact1 types.ArtifactMetadata) *artifact.ArtifactMetadata {
	ret := _mock.Called(artifact1)

	if len(ret) == 0 {
		panic("no return value specified for GetArtifactMetadata")
	}

	var r0 *artifact.ArtifactMetadata
	if returnFunc, ok := ret.Get(0).(func(types.ArtifactMetadata) *artifact.ArtifactMetadata); ok {
		r0 = returnFunc(artifact1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.ArtifactMetadata)
		}
	}
	return r0
}

// MockPackageWrapper_GetArtifactMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetArtifactMetadata'
type MockPackageWrapper_GetArtifactMetadata_Call struct {
	*mock.Call
}

// GetArtifactMetadata is a helper method to define mock.On call
//   - artifact1 types.ArtifactMetadata
func (_e *MockPackageWrapper_Expecter) GetArtifactMetadata(artifact1 interface{}) *MockPackageWrapper_GetArtifactMetadata_Call {
	return &MockPackageWrapper_GetArtifactMetadata_Call{Call: _e.mock.On("GetArtifactMetadata", artifact1)}
}

func (_c *MockPackageWrapper_GetArtifactMetadata_Call) Run(run func(artifact1 types.ArtifactMetadata)) *MockPackageWrapper_GetArtifactMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 types.ArtifactMetadata
		if args[0] != nil {
			arg0 = args[0].(types.ArtifactMetadata)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_GetArtifactMetadata_Call) Return(artifactMetadata *artifact.ArtifactMetadata) *MockPackageWrapper_GetArtifactMetadata_Call {
	_c.Call.Return(artifactMetadata)
	return _c
}

func (_c *MockPackageWrapper_GetArtifactMetadata_Call) RunAndReturn(run func(artifact1 types.ArtifactMetadata) *artifact.ArtifactMetadata) *MockPackageWrapper_GetArtifactMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// GetArtifactVersionMetadata provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) GetArtifactVersionMetadata(packageType string, image string, tag types.NonOCIArtifactMetadata) *artifact.ArtifactVersionMetadata {
	ret := _mock.Called(packageType, image, tag)

	if len(ret) == 0 {
		panic("no return value specified for GetArtifactVersionMetadata")
	}

	var r0 *artifact.ArtifactVersionMetadata
	if returnFunc, ok := ret.Get(0).(func(string, string, types.NonOCIArtifactMetadata) *artifact.ArtifactVersionMetadata); ok {
		r0 = returnFunc(packageType, image, tag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.ArtifactVersionMetadata)
		}
	}
	return r0
}

// MockPackageWrapper_GetArtifactVersionMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetArtifactVersionMetadata'
type MockPackageWrapper_GetArtifactVersionMetadata_Call struct {
	*mock.Call
}

// GetArtifactVersionMetadata is a helper method to define mock.On call
//   - packageType string
//   - image string
//   - tag types.NonOCIArtifactMetadata
func (_e *MockPackageWrapper_Expecter) GetArtifactVersionMetadata(packageType interface{}, image interface{}, tag interface{}) *MockPackageWrapper_GetArtifactVersionMetadata_Call {
	return &MockPackageWrapper_GetArtifactVersionMetadata_Call{Call: _e.mock.On("GetArtifactVersionMetadata", packageType, image, tag)}
}

func (_c *MockPackageWrapper_GetArtifactVersionMetadata_Call) Run(run func(packageType string, image string, tag types.NonOCIArtifactMetadata)) *MockPackageWrapper_GetArtifactVersionMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 types.NonOCIArtifactMetadata
		if args[2] != nil {
			arg2 = args[2].(types.NonOCIArtifactMetadata)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_GetArtifactVersionMetadata_Call) Return(artifactVersionMetadata *artifact.ArtifactVersionMetadata) *MockPackageWrapper_GetArtifactVersionMetadata_Call {
	_c.Call.Return(artifactVersionMetadata)
	return _c
}

func (_c *MockPackageWrapper_GetArtifactVersionMetadata_Call) RunAndReturn(run func(packageType string, image string, tag types.NonOCIArtifactMetadata) *artifact.ArtifactVersionMetadata) *MockPackageWrapper_GetArtifactVersionMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// GetClientSetupDetails provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) GetClientSetupDetails(ctx context.Context, regRef string, image *artifact.ArtifactParam, tag *artifact.VersionParam, registryType artifact.RegistryType, packageType string) (*artifact.ClientSetupDetails, error) {
	ret := _mock.Called(ctx, regRef, image, tag, registryType, packageType)

	if len(ret) == 0 {
		panic("no return value specified for GetClientSetupDetails")
	}

	var r0 *artifact.ClientSetupDetails
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *artifact.ArtifactParam, *artifact.VersionParam, artifact.RegistryType, string) (*artifact.ClientSetupDetails, error)); ok {
		return returnFunc(ctx, regRef, image, tag, registryType, packageType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *artifact.ArtifactParam, *artifact.VersionParam, artifact.RegistryType, string) *artifact.ClientSetupDetails); ok {
		r0 = returnFunc(ctx, regRef, image, tag, registryType, packageType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.ClientSetupDetails)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, *artifact.ArtifactParam, *artifact.VersionParam, artifact.RegistryType, string) error); ok {
		r1 = returnFunc(ctx, regRef, image, tag, registryType, packageType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackageWrapper_GetClientSetupDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetClientSetupDetails'
type MockPackageWrapper_GetClientSetupDetails_Call struct {
	*mock.Call
}

// GetClientSetupDetails is a helper method to define mock.On call
//   - ctx context.Context
//   - regRef string
//   - image *artifact.ArtifactParam
//   - tag *artifact.VersionParam
//   - registryType artifact.RegistryType
//   - packageType string
func (_e *MockPackageWrapper_Expecter) GetClientSetupDetails(ctx interface{}, regRef interface{}, image interface{}, tag interface{}, registryType interface{}, packageType interface{}) *MockPackageWrapper_GetClientSetupDetails_Call {
	return &MockPackageWrapper_GetClientSetupDetails_Call{Call: _e.mock.On("GetClientSetupDetails", ctx, regRef, image, tag, registryType, packageType)}
}

func (_c *MockPackageWrapper_GetClientSetupDetails_Call) Run(run func(ctx context.Context, regRef string, image *artifact.ArtifactParam, tag *artifact.VersionParam, registryType artifact.RegistryType, packageType string)) *MockPackageWrapper_GetClientSetupDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *artifact.ArtifactParam
		if args[2] != nil {
			arg2 = args[2].(*artifact.ArtifactParam)
		}
		var arg3 *artifact.VersionParam
		if args[3] != nil {
			arg3 = args[3].(*artifact.VersionParam)
		}
		var arg4 artifact.RegistryType
		if args[4] != nil {
			arg4 = args[4].(artifact.RegistryType)
		}
		var arg5 string
		if args[5] != nil {
			arg5 = args[5].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_GetClientSetupDetails_Call) Return(clientSetupDetails *artifact.ClientSetupDetails, err error) *MockPackageWrapper_GetClientSetupDetails_Call {
	_c.Call.Return(clientSetupDetails, err)
	return _c
}

func (_c *MockPackageWrapper_GetClientSetupDetails_Call) RunAndReturn(run func(ctx context.Context, regRef string, image *artifact.ArtifactParam, tag *artifact.VersionParam, registryType artifact.RegistryType, packageType string) (*artifact.ClientSetupDetails, error)) *MockPackageWrapper_GetClientSetupDetails_Call {
	_c.Call.Return(run)
	return _c
}

// GetFileMetadata provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) GetFileMetadata(ctx context.Context, rootIdentifier string, registryIdentifier string, packageType string, artifactName string, version string, file types.FileNodeMetadata) *artifact.FileDetail {
	ret := _mock.Called(ctx, rootIdentifier, registryIdentifier, packageType, artifactName, version, file)

	if len(ret) == 0 {
		panic("no return value specified for GetFileMetadata")
	}

	var r0 *artifact.FileDetail
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, types.FileNodeMetadata) *artifact.FileDetail); ok {
		r0 = returnFunc(ctx, rootIdentifier, registryIdentifier, packageType, artifactName, version, file)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*artifact.FileDetail)
		}
	}
	return r0
}

// MockPackageWrapper_GetFileMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFileMetadata'
type MockPackageWrapper_GetFileMetadata_Call struct {
	*mock.Call
}

// GetFileMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - rootIdentifier string
//   - registryIdentifier string
//   - packageType string
//   - artifactName string
//   - version string
//   - file types.FileNodeMetadata
func (_e *MockPackageWrapper_Expecter) GetFileMetadata(ctx interface{}, rootIdentifier interface{}, registryIdentifier interface{}, packageType interface{}, artifactName interface{}, version interface{}, file interface{}) *MockPackageWrapper_GetFileMetadata_Call {
	return &MockPackageWrapper_GetFileMetadata_Call{Call: _e.mock.On("GetFileMetadata", ctx, rootIdentifier, registryIdentifier, packageType, artifactName, version, file)}
}

func (_c *MockPackageWrapper_GetFileMetadata_Call) Run(run func(ctx context.Context, rootIdentifier string, registryIdentifier string, packageType string, artifactName string, version string, file types.FileNodeMetadata)) *MockPackageWrapper_GetFileMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 string
		if args[5] != nil {
			arg5 = args[5].(string)
		}
		var arg6 types.FileNodeMetadata
		if args[6] != nil {
			arg6 = args[6].(types.FileNodeMetadata)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_GetFileMetadata_Call) Return(fileDetail *artifact.FileDetail) *MockPackageWrapper_GetFileMetadata_Call {
	_c.Call.Return(fileDetail)
	return _c
}

func (_c *MockPackageWrapper_GetFileMetadata_Call) RunAndReturn(run func(ctx context.Context, rootIdentifier string, registryIdentifier string, packageType string, artifactName string, version string, file types.FileNodeMetadata) *artifact.FileDetail) *MockPackageWrapper_GetFileMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// GetFilePath provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) GetFilePath(packageType string, artifactName string, versionName string) (string, error) {
	ret := _mock.Called(packageType, artifactName, versionName)

	if len(ret) == 0 {
		panic("no return value specified for GetFilePath")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string, string) (string, error)); ok {
		return returnFunc(packageType, artifactName, versionName)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string, string) string); ok {
		r0 = returnFunc(packageType, artifactName, versionName)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = returnFunc(packageType, artifactName, versionName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackageWrapper_GetFilePath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFilePath'
type MockPackageWrapper_GetFilePath_Call struct {
	*mock.Call
}

// GetFilePath is a helper method to define mock.On call
//   - packageType string
//   - artifactName string
//   - versionName string
func (_e *MockPackageWrapper_Expecter) GetFilePath(packageType interface{}, artifactName interface{}, versionName interface{}) *MockPackageWrapper_GetFilePath_Call {
	return &MockPackageWrapper_GetFilePath_Call{Call: _e.mock.On("GetFilePath", packageType, artifactName, versionName)}
}

func (_c *MockPackageWrapper_GetFilePath_Call) Run(run func(packageType string, artifactName string, versionName string)) *MockPackageWrapper_GetFilePath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_GetFilePath_Call) Return(s string, err error) *MockPackageWrapper_GetFilePath_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockPackageWrapper_GetFilePath_Call) RunAndReturn(run func(packageType string, artifactName string, versionName string) (string, error)) *MockPackageWrapper_GetFilePath_Call {
	_c.Call.Return(run)
	return _c
}

// GetPackageURL provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) GetPackageURL(ctx context.Context, rootIdentifier string, registryIdentifier string, packageType string) (string, error) {
	ret := _mock.Called(ctx, rootIdentifier, registryIdentifier, packageType)

	if len(ret) == 0 {
		panic("no return value specified for GetPackageURL")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) (string, error)); ok {
		return returnFunc(ctx, rootIdentifier, registryIdentifier, packageType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) string); ok {
		r0 = returnFunc(ctx, rootIdentifier, registryIdentifier, packageType)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = returnFunc(ctx, rootIdentifier, registryIdentifier, packageType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackageWrapper_GetPackageURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPackageURL'
type MockPackageWrapper_GetPackageURL_Call struct {
	*mock.Call
}

// GetPackageURL is a helper method to define mock.On call
//   - ctx context.Context
//   - rootIdentifier string
//   - registryIdentifier string
//   - packageType string
func (_e *MockPackageWrapper_Expecter) GetPackageURL(ctx interface{}, rootIdentifier interface{}, registryIdentifier interface{}, packageType interface{}) *MockPackageWrapper_GetPackageURL_Call {
	return &MockPackageWrapper_GetPackageURL_Call{Call: _e.mock.On("GetPackageURL", ctx, rootIdentifier, registryIdentifier, packageType)}
}

func (_c *MockPackageWrapper_GetPackageURL_Call) Run(run func(ctx context.Context, rootIdentifier string, registryIdentifier string, packageType string)) *MockPackageWrapper_GetPackageURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_GetPackageURL_Call) Return(s string, err error) *MockPackageWrapper_GetPackageURL_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockPackageWrapper_GetPackageURL_Call) RunAndReturn(run func(ctx context.Context, rootIdentifier string, registryIdentifier string, packageType string) (string, error)) *MockPackageWrapper_GetPackageURL_Call {
	_c.Call.Return(run)
	return _c
}

// IsURLRequiredForUpstreamSource provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) IsURLRequiredForUpstreamSource(packageType string, upstreamSource string) bool {
	ret := _mock.Called(packageType, upstreamSource)

	if len(ret) == 0 {
		panic("no return value specified for IsURLRequiredForUpstreamSource")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = returnFunc(packageType, upstreamSource)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockPackageWrapper_IsURLRequiredForUpstreamSource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsURLRequiredForUpstreamSource'
type MockPackageWrapper_IsURLRequiredForUpstreamSource_Call struct {
	*mock.Call
}

// IsURLRequiredForUpstreamSource is a helper method to define mock.On call
//   - packageType string
//   - upstreamSource string
func (_e *MockPackageWrapper_Expecter) IsURLRequiredForUpstreamSource(packageType interface{}, upstreamSource interface{}) *MockPackageWrapper_IsURLRequiredForUpstreamSource_Call {
	return &MockPackageWrapper_IsURLRequiredForUpstreamSource_Call{Call: _e.mock.On("IsURLRequiredForUpstreamSource", packageType, upstreamSource)}
}

func (_c *MockPackageWrapper_IsURLRequiredForUpstreamSource_Call) Run(run func(packageType string, upstreamSource string)) *MockPackageWrapper_IsURLRequiredForUpstreamSource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_IsURLRequiredForUpstreamSource_Call) Return(b bool) *MockPackageWrapper_IsURLRequiredForUpstreamSource_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockPackageWrapper_IsURLRequiredForUpstreamSource_Call) RunAndReturn(run func(packageType string, upstreamSource string) bool) *MockPackageWrapper_IsURLRequiredForUpstreamSource_Call {
	_c.Call.Return(run)
	return _c
}

// IsValidPackageType provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) IsValidPackageType(packageType string) bool {
	ret := _mock.Called(packageType)

	if len(ret) == 0 {
		panic("no return value specified for IsValidPackageType")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(packageType)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockPackageWrapper_IsValidPackageType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValidPackageType'
type MockPackageWrapper_IsValidPackageType_Call struct {
	*mock.Call
}

// IsValidPackageType is a helper method to define mock.On call
//   - packageType string
func (_e *MockPackageWrapper_Expecter) IsValidPackageType(packageType interface{}) *MockPackageWrapper_IsValidPackageType_Call {
	return &MockPackageWrapper_IsValidPackageType_Call{Call: _e.mock.On("IsValidPackageType", packageType)}
}

func (_c *MockPackageWrapper_IsValidPackageType_Call) Run(run func(packageType string)) *MockPackageWrapper_IsValidPackageType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_IsValidPackageType_Call) Return(b bool) *MockPackageWrapper_IsValidPackageType_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockPackageWrapper_IsValidPackageType_Call) RunAndReturn(run func(packageType string) bool) *MockPackageWrapper_IsValidPackageType_Call {
	_c.Call.Return(run)
	return _c
}

// IsValidPackageTypes provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) IsValidPackageTypes(packageTypes []string) bool {
	ret := _mock.Called(packageTypes)

	if len(ret) == 0 {
		panic("no return value specified for IsValidPackageTypes")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func([]string) bool); ok {
		r0 = returnFunc(packageTypes)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockPackageWrapper_IsValidPackageTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValidPackageTypes'
type MockPackageWrapper_IsValidPackageTypes_Call struct {
	*mock.Call
}

// IsValidPackageTypes is a helper method to define mock.On call
//   - packageTypes []string
func (_e *MockPackageWrapper_Expecter) IsValidPackageTypes(packageTypes interface{}) *MockPackageWrapper_IsValidPackageTypes_Call {
	return &MockPackageWrapper_IsValidPackageTypes_Call{Call: _e.mock.On("IsValidPackageTypes", packageTypes)}
}

func (_c *MockPackageWrapper_IsValidPackageTypes_Call) Run(run func(packageTypes []string)) *MockPackageWrapper_IsValidPackageTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []string
		if args[0] != nil {
			arg0 = args[0].([]string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_IsValidPackageTypes_Call) Return(b bool) *MockPackageWrapper_IsValidPackageTypes_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockPackageWrapper_IsValidPackageTypes_Call) RunAndReturn(run func(packageTypes []string) bool) *MockPackageWrapper_IsValidPackageTypes_Call {
	_c.Call.Return(run)
	return _c
}

// IsValidRepoType provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) IsValidRepoType(repoType string) bool {
	ret := _mock.Called(repoType)

	if len(ret) == 0 {
		panic("no return value specified for IsValidRepoType")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(repoType)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockPackageWrapper_IsValidRepoType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValidRepoType'
type MockPackageWrapper_IsValidRepoType_Call struct {
	*mock.Call
}

// IsValidRepoType is a helper method to define mock.On call
//   - repoType string
func (_e *MockPackageWrapper_Expecter) IsValidRepoType(repoType interface{}) *MockPackageWrapper_IsValidRepoType_Call {
	return &MockPackageWrapper_IsValidRepoType_Call{Call: _e.mock.On("IsValidRepoType", repoType)}
}

func (_c *MockPackageWrapper_IsValidRepoType_Call) Run(run func(repoType string)) *MockPackageWrapper_IsValidRepoType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_IsValidRepoType_Call) Return(b bool) *MockPackageWrapper_IsValidRepoType_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockPackageWrapper_IsValidRepoType_Call) RunAndReturn(run func(repoType string) bool) *MockPackageWrapper_IsValidRepoType_Call {
	_c.Call.Return(run)
	return _c
}

// IsValidRepoTypes provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) IsValidRepoTypes(repoTypes []string) bool {
	ret := _mock.Called(repoTypes)

	if len(ret) == 0 {
		panic("no return value specified for IsValidRepoTypes")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func([]string) bool); ok {
		r0 = returnFunc(repoTypes)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockPackageWrapper_IsValidRepoTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValidRepoTypes'
type MockPackageWrapper_IsValidRepoTypes_Call struct {
	*mock.Call
}

// IsValidRepoTypes is a helper method to define mock.On call
//   - repoTypes []string
func (_e *MockPackageWrapper_Expecter) IsValidRepoTypes(repoTypes interface{}) *MockPackageWrapper_IsValidRepoTypes_Call {
	return &MockPackageWrapper_IsValidRepoTypes_Call{Call: _e.mock.On("IsValidRepoTypes", repoTypes)}
}

func (_c *MockPackageWrapper_IsValidRepoTypes_Call) Run(run func(repoTypes []string)) *MockPackageWrapper_IsValidRepoTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []string
		if args[0] != nil {
			arg0 = args[0].([]string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_IsValidRepoTypes_Call) Return(b bool) *MockPackageWrapper_IsValidRepoTypes_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockPackageWrapper_IsValidRepoTypes_Call) RunAndReturn(run func(repoTypes []string) bool) *MockPackageWrapper_IsValidRepoTypes_Call {
	_c.Call.Return(run)
	return _c
}

// IsValidUpstreamSource provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) IsValidUpstreamSource(upstreamSource string) bool {
	ret := _mock.Called(upstreamSource)

	if len(ret) == 0 {
		panic("no return value specified for IsValidUpstreamSource")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(upstreamSource)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockPackageWrapper_IsValidUpstreamSource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValidUpstreamSource'
type MockPackageWrapper_IsValidUpstreamSource_Call struct {
	*mock.Call
}

// IsValidUpstreamSource is a helper method to define mock.On call
//   - upstreamSource string
func (_e *MockPackageWrapper_Expecter) IsValidUpstreamSource(upstreamSource interface{}) *MockPackageWrapper_IsValidUpstreamSource_Call {
	return &MockPackageWrapper_IsValidUpstreamSource_Call{Call: _e.mock.On("IsValidUpstreamSource", upstreamSource)}
}

func (_c *MockPackageWrapper_IsValidUpstreamSource_Call) Run(run func(upstreamSource string)) *MockPackageWrapper_IsValidUpstreamSource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_IsValidUpstreamSource_Call) Return(b bool) *MockPackageWrapper_IsValidUpstreamSource_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockPackageWrapper_IsValidUpstreamSource_Call) RunAndReturn(run func(upstreamSource string) bool) *MockPackageWrapper_IsValidUpstreamSource_Call {
	_c.Call.Return(run)
	return _c
}

// IsValidUpstreamSources provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) IsValidUpstreamSources(upstreamSources []string) bool {
	ret := _mock.Called(upstreamSources)

	if len(ret) == 0 {
		panic("no return value specified for IsValidUpstreamSources")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func([]string) bool); ok {
		r0 = returnFunc(upstreamSources)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockPackageWrapper_IsValidUpstreamSources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsValidUpstreamSources'
type MockPackageWrapper_IsValidUpstreamSources_Call struct {
	*mock.Call
}

// IsValidUpstreamSources is a helper method to define mock.On call
//   - upstreamSources []string
func (_e *MockPackageWrapper_Expecter) IsValidUpstreamSources(upstreamSources interface{}) *MockPackageWrapper_IsValidUpstreamSources_Call {
	return &MockPackageWrapper_IsValidUpstreamSources_Call{Call: _e.mock.On("IsValidUpstreamSources", upstreamSources)}
}

func (_c *MockPackageWrapper_IsValidUpstreamSources_Call) Run(run func(upstreamSources []string)) *MockPackageWrapper_IsValidUpstreamSources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 []string
		if args[0] != nil {
			arg0 = args[0].([]string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_IsValidUpstreamSources_Call) Return(b bool) *MockPackageWrapper_IsValidUpstreamSources_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockPackageWrapper_IsValidUpstreamSources_Call) RunAndReturn(run func(upstreamSources []string) bool) *MockPackageWrapper_IsValidUpstreamSources_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateRepoType provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) ValidateRepoType(packageType string, repoType string) bool {
	ret := _mock.Called(packageType, repoType)

	if len(ret) == 0 {
		panic("no return value specified for ValidateRepoType")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = returnFunc(packageType, repoType)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockPackageWrapper_ValidateRepoType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateRepoType'
type MockPackageWrapper_ValidateRepoType_Call struct {
	*mock.Call
}

// ValidateRepoType is a helper method to define mock.On call
//   - packageType string
//   - repoType string
func (_e *MockPackageWrapper_Expecter) ValidateRepoType(packageType interface{}, repoType interface{}) *MockPackageWrapper_ValidateRepoType_Call {
	return &MockPackageWrapper_ValidateRepoType_Call{Call: _e.mock.On("ValidateRepoType", packageType, repoType)}
}

func (_c *MockPackageWrapper_ValidateRepoType_Call) Run(run func(packageType string, repoType string)) *MockPackageWrapper_ValidateRepoType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_ValidateRepoType_Call) Return(b bool) *MockPackageWrapper_ValidateRepoType_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockPackageWrapper_ValidateRepoType_Call) RunAndReturn(run func(packageType string, repoType string) bool) *MockPackageWrapper_ValidateRepoType_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateUpstreamSource provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) ValidateUpstreamSource(packageType string, upstreamSource string) bool {
	ret := _mock.Called(packageType, upstreamSource)

	if len(ret) == 0 {
		panic("no return value specified for ValidateUpstreamSource")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = returnFunc(packageType, upstreamSource)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockPackageWrapper_ValidateUpstreamSource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateUpstreamSource'
type MockPackageWrapper_ValidateUpstreamSource_Call struct {
	*mock.Call
}

// ValidateUpstreamSource is a helper method to define mock.On call
//   - packageType string
//   - upstreamSource string
func (_e *MockPackageWrapper_Expecter) ValidateUpstreamSource(packageType interface{}, upstreamSource interface{}) *MockPackageWrapper_ValidateUpstreamSource_Call {
	return &MockPackageWrapper_ValidateUpstreamSource_Call{Call: _e.mock.On("ValidateUpstreamSource", packageType, upstreamSource)}
}

func (_c *MockPackageWrapper_ValidateUpstreamSource_Call) Run(run func(packageType string, upstreamSource string)) *MockPackageWrapper_ValidateUpstreamSource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_ValidateUpstreamSource_Call) Return(b bool) *MockPackageWrapper_ValidateUpstreamSource_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockPackageWrapper_ValidateUpstreamSource_Call) RunAndReturn(run func(packageType string, upstreamSource string) bool) *MockPackageWrapper_ValidateUpstreamSource_Call {
	_c.Call.Return(run)
	return _c
}

// BuildRegistryIndexAsync provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) BuildRegistryIndexAsync(ctx context.Context, payload types.BuildRegistryIndexTaskPayload) error {
	ret := _mock.Called(ctx, payload)

	if len(ret) == 0 {
		panic("no return value specified for BuildRegistryIndexAsync")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.BuildRegistryIndexTaskPayload) error); ok {
		r0 = returnFunc(ctx, payload)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPackageWrapper_BuildRegistryIndexAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildRegistryIndexAsync'
type MockPackageWrapper_BuildRegistryIndexAsync_Call struct {
	*mock.Call
}

// BuildRegistryIndexAsync is a helper method to define mock.On call
//   - ctx context.Context
//   - payload types.BuildRegistryIndexTaskPayload
func (_e *MockPackageWrapper_Expecter) BuildRegistryIndexAsync(ctx interface{}, payload interface{}) *MockPackageWrapper_BuildRegistryIndexAsync_Call {
	return &MockPackageWrapper_BuildRegistryIndexAsync_Call{Call: _e.mock.On("BuildRegistryIndexAsync", ctx, payload)}
}

func (_c *MockPackageWrapper_BuildRegistryIndexAsync_Call) Run(run func(ctx context.Context, payload types.BuildRegistryIndexTaskPayload)) *MockPackageWrapper_BuildRegistryIndexAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.BuildRegistryIndexTaskPayload
		if args[1] != nil {
			arg1 = args[1].(types.BuildRegistryIndexTaskPayload)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_BuildRegistryIndexAsync_Call) Return(err error) *MockPackageWrapper_BuildRegistryIndexAsync_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPackageWrapper_BuildRegistryIndexAsync_Call) RunAndReturn(run func(ctx context.Context, payload types.BuildRegistryIndexTaskPayload) error) *MockPackageWrapper_BuildRegistryIndexAsync_Call {
	_c.Call.Return(run)
	return _c
}

// BuildPackageIndexAsync provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) BuildPackageIndexAsync(ctx context.Context, payload types.BuildPackageIndexTaskPayload) error {
	ret := _mock.Called(ctx, payload)

	if len(ret) == 0 {
		panic("no return value specified for BuildPackageIndexAsync")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.BuildPackageIndexTaskPayload) error); ok {
		r0 = returnFunc(ctx, payload)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPackageWrapper_BuildPackageIndexAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildPackageIndexAsync'
type MockPackageWrapper_BuildPackageIndexAsync_Call struct {
	*mock.Call
}

// BuildPackageIndexAsync is a helper method to define mock.On call
//   - ctx context.Context
//   - payload types.BuildPackageIndexTaskPayload
func (_e *MockPackageWrapper_Expecter) BuildPackageIndexAsync(ctx interface{}, payload interface{}) *MockPackageWrapper_BuildPackageIndexAsync_Call {
	return &MockPackageWrapper_BuildPackageIndexAsync_Call{Call: _e.mock.On("BuildPackageIndexAsync", ctx, payload)}
}

func (_c *MockPackageWrapper_BuildPackageIndexAsync_Call) Run(run func(ctx context.Context, payload types.BuildPackageIndexTaskPayload)) *MockPackageWrapper_BuildPackageIndexAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.BuildPackageIndexTaskPayload
		if args[1] != nil {
			arg1 = args[1].(types.BuildPackageIndexTaskPayload)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_BuildPackageIndexAsync_Call) Return(err error) *MockPackageWrapper_BuildPackageIndexAsync_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPackageWrapper_BuildPackageIndexAsync_Call) RunAndReturn(run func(ctx context.Context, payload types.BuildPackageIndexTaskPayload) error) *MockPackageWrapper_BuildPackageIndexAsync_Call {
	_c.Call.Return(run)
	return _c
}

// BuildPackageMetadataAsync provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) BuildPackageMetadataAsync(ctx context.Context, payload types.BuildPackageMetadataTaskPayload) error {
	ret := _mock.Called(ctx, payload)

	if len(ret) == 0 {
		panic("no return value specified for BuildPackageMetadataAsync")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.BuildPackageMetadataTaskPayload) error); ok {
		r0 = returnFunc(ctx, payload)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPackageWrapper_BuildPackageMetadataAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildPackageMetadataAsync'
type MockPackageWrapper_BuildPackageMetadataAsync_Call struct {
	*mock.Call
}

// BuildPackageMetadataAsync is a helper method to define mock.On call
//   - ctx context.Context
//   - payload types.BuildPackageMetadataTaskPayload
func (_e *MockPackageWrapper_Expecter) BuildPackageMetadataAsync(ctx interface{}, payload interface{}) *MockPackageWrapper_BuildPackageMetadataAsync_Call {
	return &MockPackageWrapper_BuildPackageMetadataAsync_Call{Call: _e.mock.On("BuildPackageMetadataAsync", ctx, payload)}
}

func (_c *MockPackageWrapper_BuildPackageMetadataAsync_Call) Run(run func(ctx context.Context, payload types.BuildPackageMetadataTaskPayload)) *MockPackageWrapper_BuildPackageMetadataAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.BuildPackageMetadataTaskPayload
		if args[1] != nil {
			arg1 = args[1].(types.BuildPackageMetadataTaskPayload)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_BuildPackageMetadataAsync_Call) Return(err error) *MockPackageWrapper_BuildPackageMetadataAsync_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPackageWrapper_BuildPackageMetadataAsync_Call) RunAndReturn(run func(ctx context.Context, payload types.BuildPackageMetadataTaskPayload) error) *MockPackageWrapper_BuildPackageMetadataAsync_Call {
	_c.Call.Return(run)
	return _c
}

// GetPackageTypeFromPathPackageType provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) GetPackageTypeFromPathPackageType(pathPackageType string) (string, error) {
	ret := _mock.Called(pathPackageType)

	if len(ret) == 0 {
		panic("no return value specified for GetPackageTypeFromPathPackageType")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (string, error)); ok {
		return returnFunc(pathPackageType)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(pathPackageType)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(pathPackageType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackageWrapper_GetPackageTypeFromPathPackageType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPackageTypeFromPathPackageType'
type MockPackageWrapper_GetPackageTypeFromPathPackageType_Call struct {
	*mock.Call
}

// GetPackageTypeFromPathPackageType is a helper method to define mock.On call
//   - pathPackageType string
func (_e *MockPackageWrapper_Expecter) GetPackageTypeFromPathPackageType(pathPackageType interface{}) *MockPackageWrapper_GetPackageTypeFromPathPackageType_Call {
	return &MockPackageWrapper_GetPackageTypeFromPathPackageType_Call{Call: _e.mock.On("GetPackageTypeFromPathPackageType", pathPackageType)}
}

func (_c *MockPackageWrapper_GetPackageTypeFromPathPackageType_Call) Run(run func(pathPackageType string)) *MockPackageWrapper_GetPackageTypeFromPathPackageType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_GetPackageTypeFromPathPackageType_Call) Return(s string, err error) *MockPackageWrapper_GetPackageTypeFromPathPackageType_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockPackageWrapper_GetPackageTypeFromPathPackageType_Call) RunAndReturn(run func(pathPackageType string) (string, error)) *MockPackageWrapper_GetPackageTypeFromPathPackageType_Call {
	_c.Call.Return(run)
	return _c
}

// ReportDeleteVersionEvent provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) ReportDeleteVersionEvent(ctx context.Context, registryID int64, artifactName string, versionName string) error {
	ret := _mock.Called(ctx, registryID, artifactName, versionName)

	if len(ret) == 0 {
		panic("no return value specified for ReportDeleteVersionEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string) error); ok {
		r0 = returnFunc(ctx, registryID, artifactName, versionName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPackageWrapper_ReportDeleteVersionEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReportDeleteVersionEvent'
type MockPackageWrapper_ReportDeleteVersionEvent_Call struct {
	*mock.Call
}

// ReportDeleteVersionEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - registryID int64
//   - artifactName string
//   - versionName string
func (_e *MockPackageWrapper_Expecter) ReportDeleteVersionEvent(ctx interface{}, registryID interface{}, artifactName interface{}, versionName interface{}) *MockPackageWrapper_ReportDeleteVersionEvent_Call {
	return &MockPackageWrapper_ReportDeleteVersionEvent_Call{Call: _e.mock.On("ReportDeleteVersionEvent", ctx, registryID, artifactName, versionName)}
}

func (_c *MockPackageWrapper_ReportDeleteVersionEvent_Call) Run(run func(ctx context.Context, registryID int64, artifactName string, versionName string)) *MockPackageWrapper_ReportDeleteVersionEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_ReportDeleteVersionEvent_Call) Return(err error) *MockPackageWrapper_ReportDeleteVersionEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPackageWrapper_ReportDeleteVersionEvent_Call) RunAndReturn(run func(ctx context.Context, registryID int64, artifactName string, versionName string) error) *MockPackageWrapper_ReportDeleteVersionEvent_Call {
	_c.Call.Return(run)
	return _c
}

// ReportBuildPackageIndexEvent provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) ReportBuildPackageIndexEvent(ctx context.Context, registryID int64, artifactName string) error {
	ret := _mock.Called(ctx, registryID, artifactName)

	if len(ret) == 0 {
		panic("no return value specified for ReportBuildPackageIndexEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) error); ok {
		r0 = returnFunc(ctx, registryID, artifactName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPackageWrapper_ReportBuildPackageIndexEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReportBuildPackageIndexEvent'
type MockPackageWrapper_ReportBuildPackageIndexEvent_Call struct {
	*mock.Call
}

// ReportBuildPackageIndexEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - registryID int64
//   - artifactName string
func (_e *MockPackageWrapper_Expecter) ReportBuildPackageIndexEvent(ctx interface{}, registryID interface{}, artifactName interface{}) *MockPackageWrapper_ReportBuildPackageIndexEvent_Call {
	return &MockPackageWrapper_ReportBuildPackageIndexEvent_Call{Call: _e.mock.On("ReportBuildPackageIndexEvent", ctx, registryID, artifactName)}
}

func (_c *MockPackageWrapper_ReportBuildPackageIndexEvent_Call) Run(run func(ctx context.Context, registryID int64, artifactName string)) *MockPackageWrapper_ReportBuildPackageIndexEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_ReportBuildPackageIndexEvent_Call) Return(err error) *MockPackageWrapper_ReportBuildPackageIndexEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPackageWrapper_ReportBuildPackageIndexEvent_Call) RunAndReturn(run func(ctx context.Context, registryID int64, artifactName string) error) *MockPackageWrapper_ReportBuildPackageIndexEvent_Call {
	_c.Call.Return(run)
	return _c
}

// ReportBuildRegistryIndexEvent provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) ReportBuildRegistryIndexEvent(ctx context.Context, registryID int64, sourceRefs []types.SourceRef) error {
	ret := _mock.Called(ctx, registryID, sourceRefs)

	if len(ret) == 0 {
		panic("no return value specified for ReportBuildRegistryIndexEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, []types.SourceRef) error); ok {
		r0 = returnFunc(ctx, registryID, sourceRefs)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPackageWrapper_ReportBuildRegistryIndexEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReportBuildRegistryIndexEvent'
type MockPackageWrapper_ReportBuildRegistryIndexEvent_Call struct {
	*mock.Call
}

// ReportBuildRegistryIndexEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - registryID int64
//   - sourceRefs []types.SourceRef
func (_e *MockPackageWrapper_Expecter) ReportBuildRegistryIndexEvent(ctx interface{}, registryID interface{}, sourceRefs interface{}) *MockPackageWrapper_ReportBuildRegistryIndexEvent_Call {
	return &MockPackageWrapper_ReportBuildRegistryIndexEvent_Call{Call: _e.mock.On("ReportBuildRegistryIndexEvent", ctx, registryID, sourceRefs)}
}

func (_c *MockPackageWrapper_ReportBuildRegistryIndexEvent_Call) Run(run func(ctx context.Context, registryID int64, sourceRefs []types.SourceRef)) *MockPackageWrapper_ReportBuildRegistryIndexEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 []types.SourceRef
		if args[2] != nil {
			arg2 = args[2].([]types.SourceRef)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_ReportBuildRegistryIndexEvent_Call) Return(err error) *MockPackageWrapper_ReportBuildRegistryIndexEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPackageWrapper_ReportBuildRegistryIndexEvent_Call) RunAndReturn(run func(ctx context.Context, registryID int64, sourceRefs []types.SourceRef) error) *MockPackageWrapper_ReportBuildRegistryIndexEvent_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodePathsForImage provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) GetNodePathsForImage(packageType string, artifactType *string, packageName string) ([]string, error) {
	ret := _mock.Called(packageType, artifactType, packageName)

	if len(ret) == 0 {
		panic("no return value specified for GetNodePathsForImage")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, *string, string) ([]string, error)); ok {
		return returnFunc(packageType, artifactType, packageName)
	}
	if returnFunc, ok := ret.Get(0).(func(string, *string, string) []string); ok {
		r0 = returnFunc(packageType, artifactType, packageName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if returnFunc, ok := ret.Get(1).(func(string, *string, string) error); ok {
		r1 = returnFunc(packageType, artifactType, packageName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPackageWrapper_GetNodePathsForImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodePathsForImage'
type MockPackageWrapper_GetNodePathsForImage_Call struct {
	*mock.Call
}

// GetNodePathsForImage is a helper method to define mock.On call
//   - packageType string
//   - artifactType *string
//   - packageName string
func (_e *MockPackageWrapper_Expecter) GetNodePathsForImage(packageType interface{}, artifactType interface{}, packageName interface{}) *MockPackageWrapper_GetNodePathsForImage_Call {
	return &MockPackageWrapper_GetNodePathsForImage_Call{Call: _e.mock.On("GetNodePathsForImage", packageType, artifactType, packageName)}
}

func (_c *MockPackageWrapper_GetNodePathsForImage_Call) Run(run func(packageType string, artifactType *string, packageName string)) *MockPackageWrapper_GetNodePathsForImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 *string
		if args[1] != nil {
			arg1 = args[1].(*string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_GetNodePathsForImage_Call) Return(s []string, err error) *MockPackageWrapper_GetNodePathsForImage_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockPackageWrapper_GetNodePathsForImage_Call) RunAndReturn(run func(packageType string, artifactType *string, packageName string) ([]string, error)) *MockPackageWrapper_GetNodePathsForImage_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodePathsForArtifact provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) GetNodePathsForArtifact(packageType string, artifactType *string, packageName string, version string) ([]string, error) {
	ret := _mock.Called(packageType, artifactType, packageName, version)

	if len(ret) == 0 {
		panic("no return value specified for GetNodePathsForArtifact")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, *string, string, string) ([]string, error)); ok {
		return returnFunc(packageType, artifactType, packageName, version)
	}
	if returnFunc, ok := ret.Get(0).(func(string, *string, string, string) []string); ok {
		r0 = returnFunc(packageType, artifactType, packageName, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if returnFunc, ok := ret.Get(1).(func(string, *string, string, string) error); ok {
		r1 = returnFunc(packageType, artifactType, packageName, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPackageWrapper_GetNodePathsForArtifact_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodePathsForArtifact'
type MockPackageWrapper_GetNodePathsForArtifact_Call struct {
	*mock.Call
}

// GetNodePathsForArtifact is a helper method to define mock.On call
//   - packageType string
//   - artifactType *string
//   - packageName string
//   - version string
func (_e *MockPackageWrapper_Expecter) GetNodePathsForArtifact(packageType interface{}, artifactType interface{}, packageName interface{}, version interface{}) *MockPackageWrapper_GetNodePathsForArtifact_Call {
	return &MockPackageWrapper_GetNodePathsForArtifact_Call{Call: _e.mock.On("GetNodePathsForArtifact", packageType, artifactType, packageName, version)}
}

func (_c *MockPackageWrapper_GetNodePathsForArtifact_Call) Run(run func(packageType string, artifactType *string, packageName string, version string)) *MockPackageWrapper_GetNodePathsForArtifact_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 *string
		if args[1] != nil {
			arg1 = args[1].(*string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_GetNodePathsForArtifact_Call) Return(s []string, err error) *MockPackageWrapper_GetNodePathsForArtifact_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockPackageWrapper_GetNodePathsForArtifact_Call) RunAndReturn(run func(packageType string, artifactType *string, packageName string, version string) ([]string, error)) *MockPackageWrapper_GetNodePathsForArtifact_Call {
	_c.Call.Return(run)
	return _c
}

// GetPkgDownloadURL provides a mock function for the type MockPackageWrapper
func (_mock *MockPackageWrapper) GetPkgDownloadURL(ctx context.Context, packageType string, rootIdentifier string, registryIdentifier string, packageName string, artifactType string, version string, filename string, filepath string) (string, error) {
	ret := _mock.Called(ctx, packageType, rootIdentifier, registryIdentifier, packageName, artifactType, version, filename, filepath)

	if len(ret) == 0 {
		panic("no return value specified for GetPkgDownloadURL")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, string, string) (string, error)); ok {
		return returnFunc(ctx, packageType, rootIdentifier, registryIdentifier, packageName, artifactType, version, filename, filepath)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string, string, string, string, string) string); ok {
		r0 = returnFunc(ctx, packageType, rootIdentifier, registryIdentifier, packageName, artifactType, version, filename, filepath)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, string, string, string, string, string) error); ok {
		r1 = returnFunc(ctx, packageType, rootIdentifier, registryIdentifier, packageName, artifactType, version, filename, filepath)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPackageWrapper_GetPkgDownloadURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPkgDownloadURL'
type MockPackageWrapper_GetPkgDownloadURL_Call struct {
	*mock.Call
}

// GetPkgDownloadURL is a helper method to define mock.On call
//   - ctx context.Context
//   - packageType string
//   - rootIdentifier string
//   - registryIdentifier string
//   - packageName string
//   - artifactType string
//   - version string
//   - filename string
//   - filepath string
func (_e *MockPackageWrapper_Expecter) GetPkgDownloadURL(ctx interface{}, packageType interface{}, rootIdentifier interface{}, registryIdentifier interface{}, packageName interface{}, artifactType interface{}, version interface{}, filename interface{}, filepath interface{}) *MockPackageWrapper_GetPkgDownloadURL_Call {
	return &MockPackageWrapper_GetPkgDownloadURL_Call{Call: _e.mock.On("GetPkgDownloadURL", ctx, packageType, rootIdentifier, registryIdentifier, packageName, artifactType, version, filename, filepath)}
}

func (_c *MockPackageWrapper_GetPkgDownloadURL_Call) Run(run func(ctx context.Context, packageType string, rootIdentifier string, registryIdentifier string, packageName string, artifactType string, version string, filename string, filepath string)) *MockPackageWrapper_GetPkgDownloadURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 string
		if args[5] != nil {
			arg5 = args[5].(string)
		}
		var arg6 string
		if args[6] != nil {
			arg6 = args[6].(string)
		}
		var arg7 string
		if args[7] != nil {
			arg7 = args[7].(string)
		}
		var arg8 string
		if args[8] != nil {
			arg8 = args[8].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
			arg7,
			arg8,
		)
	})
	return _c
}

func (_c *MockPackageWrapper_GetPkgDownloadURL_Call) Return(s string, err error) *MockPackageWrapper_GetPkgDownloadURL_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockPackageWrapper_GetPkgDownloadURL_Call) RunAndReturn(run func(ctx context.Context, packageType string, rootIdentifier string, registryIdentifier string, packageName string, artifactType string, version string, filename string, filepath string) (string, error)) *MockPackageWrapper_GetPkgDownloadURL_Call {
	_c.Call.Return(run)
	return _c
}
