//go:generate mockery --name RegistryMetadataHelper --output . --filename registry_metadata_helper.go --outpkg mocks --with-expecter

package mocks

import (
	"context"

	api "github.com/harness/gitness/registry/app/api/openapi/contracts/artifact"
	registrytypes "github.com/harness/gitness/registry/types"
	"github.com/harness/gitness/types"
	"github.com/harness/gitness/types/enum"

	"github.com/stretchr/testify/mock"
)

// RegistryMetadataHelper is an autogenerated mock type for the RegistryMetadataHelper type
type RegistryMetadataHelper struct {
	mock.Mock
}

// GetPermissionChecks provides a mock function with given fields: space, registryIdentifier, permission
func (_m *RegistryMetadataHelper) GetPermissionChecks(space *types.SpaceCore, registryIdentifier string, permission enum.Permission) []types.PermissionCheck {
	ret := _m.Called(space, registryIdentifier, permission)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionChecks")
	}

	var r0 []types.PermissionCheck
	if rf, ok := ret.Get(0).(func(*types.SpaceCore, string, enum.Permission) []types.PermissionCheck); ok {
		r0 = rf(space, registryIdentifier, permission)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.PermissionCheck)
		}
	}

	return r0
}

// GetRegistryMetadata provides a mock function with given fields: ctx, registryID
func (_m *RegistryMetadataHelper) GetRegistryMetadata(ctx context.Context, registryID int64) (*registrytypes.Registry, error) {
	ret := _m.Called(ctx, registryID)

	if len(ret) == 0 {
		panic("no return value specified for GetRegistryMetadata")
	}

	var r0 *registrytypes.Registry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*registrytypes.Registry, error)); ok {
		return rf(ctx, registryID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *registrytypes.Registry); ok {
		r0 = rf(ctx, registryID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*registrytypes.Registry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, registryID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegistryMetadataByIdentifier provides a mock function with given fields: ctx, identifier
func (_m *RegistryMetadataHelper) GetRegistryMetadataByIdentifier(ctx context.Context, identifier string) (*registrytypes.Registry, error) {
	ret := _m.Called(ctx, identifier)

	if len(ret) == 0 {
		panic("no return value specified for GetRegistryMetadataByIdentifier")
	}

	var r0 *registrytypes.Registry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*registrytypes.Registry, error)); ok {
		return rf(ctx, identifier)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *registrytypes.Registry); ok {
		r0 = rf(ctx, identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*registrytypes.Registry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, identifier)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegistryMetadataByParentIDAndIdentifier provides a mock function with given fields: ctx, parentID, identifier
func (_m *RegistryMetadataHelper) GetRegistryMetadataByParentIDAndIdentifier(ctx context.Context, parentID int64, identifier string) (*registrytypes.Registry, error) {
	ret := _m.Called(ctx, parentID, identifier)

	if len(ret) == 0 {
		panic("no return value specified for GetRegistryMetadataByParentIDAndIdentifier")
	}

	var r0 *registrytypes.Registry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) (*registrytypes.Registry, error)); ok {
		return rf(ctx, parentID, identifier)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) *registrytypes.Registry); ok {
		r0 = rf(ctx, parentID, identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*registrytypes.Registry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string) error); ok {
		r1 = rf(ctx, parentID, identifier)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegistryMetadataByParentPathAndIdentifier provides a mock function with given fields: ctx, parentPath, identifier
func (_m *RegistryMetadataHelper) GetRegistryMetadataByParentPathAndIdentifier(ctx context.Context, parentPath string, identifier string) (*registrytypes.Registry, error) {
	ret := _m.Called(ctx, parentPath, identifier)

	if len(ret) == 0 {
		panic("no return value specified for GetRegistryMetadataByParentPathAndIdentifier")
	}

	var r0 *registrytypes.Registry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*registrytypes.Registry, error)); ok {
		return rf(ctx, parentPath, identifier)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *registrytypes.Registry); ok {
		r0 = rf(ctx, parentPath, identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*registrytypes.Registry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, parentPath, identifier)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegistryMetadataByPath provides a mock function with given fields: ctx, path
func (_m *RegistryMetadataHelper) GetRegistryMetadataByPath(ctx context.Context, path string) (*registrytypes.Registry, error) {
	ret := _m.Called(ctx, path)

	if len(ret) == 0 {
		panic("no return value specified for GetRegistryMetadataByPath")
	}

	var r0 *registrytypes.Registry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*registrytypes.Registry, error)); ok {
		return rf(ctx, path)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *registrytypes.Registry); ok {
		r0 = rf(ctx, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*registrytypes.Registry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRegistryRequestBaseInfo provides a mock function with given fields: ctx, parentPath, identifier
func (_m *RegistryMetadataHelper) GetRegistryRequestBaseInfo(ctx context.Context, parentPath string, identifier string) (*registrytypes.RegistryRequestBaseInfo, error) {
	ret := _m.Called(ctx, parentPath, identifier)

	if len(ret) == 0 {
		panic("no return value specified for GetRegistryRequestBaseInfo")
	}

	var r0 *registrytypes.RegistryRequestBaseInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*registrytypes.RegistryRequestBaseInfo, error)); ok {
		return rf(ctx, parentPath, identifier)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *registrytypes.RegistryRequestBaseInfo); ok {
		r0 = rf(ctx, parentPath, identifier)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*registrytypes.RegistryRequestBaseInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, parentPath, identifier)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSecretSpaceID provides a mock function with given fields: ctx, secretSpacePath
func (_m *RegistryMetadataHelper) GetSecretSpaceID(ctx context.Context, secretSpacePath *string) (int64, error) {
	ret := _m.Called(ctx, secretSpacePath)

	if len(ret) == 0 {
		panic("no return value specified for GetSecretSpaceID")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *string) (int64, error)); ok {
		return rf(ctx, secretSpacePath)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *string) int64); ok {
		r0 = rf(ctx, secretSpacePath)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *string) error); ok {
		r1 = rf(ctx, secretSpacePath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MapToAPIExtraHeaders provides a mock function with given fields: headers
func (_m *RegistryMetadataHelper) MapToAPIExtraHeaders(headers []types.ExtraHeader) []api.ExtraHeader {
	ret := _m.Called(headers)

	if len(ret) == 0 {
		panic("no return value specified for MapToAPIExtraHeaders")
	}

	var r0 []api.ExtraHeader
	if rf, ok := ret.Get(0).(func([]types.ExtraHeader) []api.ExtraHeader); ok {
		r0 = rf(headers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.ExtraHeader)
		}
	}

	return r0
}

// MapToAPIWebhookTriggers provides a mock function with given fields: triggers
func (_m *RegistryMetadataHelper) MapToAPIWebhookTriggers(triggers []enum.WebhookTrigger) []api.Trigger {
	ret := _m.Called(triggers)

	if len(ret) == 0 {
		panic("no return value specified for MapToAPIWebhookTriggers")
	}

	var r0 []api.Trigger
	if rf, ok := ret.Get(0).(func([]enum.WebhookTrigger) []api.Trigger); ok {
		r0 = rf(triggers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Trigger)
		}
	}

	return r0
}

// MapToInternalWebhookTriggers provides a mock function with given fields: triggers
func (_m *RegistryMetadataHelper) MapToInternalWebhookTriggers(triggers []api.Trigger) ([]enum.WebhookTrigger, error) {
	ret := _m.Called(triggers)

	if len(ret) == 0 {
		panic("no return value specified for MapToInternalWebhookTriggers")
	}

	var r0 []enum.WebhookTrigger
	var r1 error
	if rf, ok := ret.Get(0).(func([]api.Trigger) ([]enum.WebhookTrigger, error)); ok {
		return rf(triggers)
	}
	if rf, ok := ret.Get(0).(func([]api.Trigger) []enum.WebhookTrigger); ok {
		r0 = rf(triggers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]enum.WebhookTrigger)
		}
	}

	if rf, ok := ret.Get(1).(func([]api.Trigger) error); ok {
		r1 = rf(triggers)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MapToWebhookCore provides a mock function with given fields: ctx, webhookRequest, regInfo
func (_m *RegistryMetadataHelper) MapToWebhookCore(ctx context.Context, webhookRequest api.WebhookRequest, regInfo *registrytypes.RegistryRequestBaseInfo) (*types.WebhookCore, error) {
	ret := _m.Called(ctx, webhookRequest, regInfo)

	if len(ret) == 0 {
		panic("no return value specified for MapToWebhookCore")
	}

	var r0 *types.WebhookCore
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, api.WebhookRequest, *registrytypes.RegistryRequestBaseInfo) (*types.WebhookCore, error)); ok {
		return rf(ctx, webhookRequest, regInfo)
	}
	if rf, ok := ret.Get(0).(func(context.Context, api.WebhookRequest, *registrytypes.RegistryRequestBaseInfo) *types.WebhookCore); ok {
		r0 = rf(ctx, webhookRequest, regInfo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WebhookCore)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, api.WebhookRequest, *registrytypes.RegistryRequestBaseInfo) error); ok {
		r1 = rf(ctx, webhookRequest, regInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MapToWebhookResponseEntity provides a mock function with given fields: ctx, webhook
func (_m *RegistryMetadataHelper) MapToWebhookResponseEntity(ctx context.Context, webhook *types.WebhookCore) (*api.Webhook, error) {
	ret := _m.Called(ctx, webhook)

	if len(ret) == 0 {
		panic("no return value specified for MapToWebhookResponseEntity")
	}

	var r0 *api.Webhook
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.WebhookCore) (*api.Webhook, error)); ok {
		return rf(ctx, webhook)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.WebhookCore) *api.Webhook); ok {
		r0 = rf(ctx, webhook)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Webhook)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.WebhookCore) error); ok {
		r1 = rf(ctx, webhook)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewRegistryMetadataHelper creates a new instance of RegistryMetadataHelper. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRegistryMetadataHelper(t interface {
	mock.TestingT
	Cleanup(func())
}) *RegistryMetadataHelper {
	mock := &RegistryMetadataHelper{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
