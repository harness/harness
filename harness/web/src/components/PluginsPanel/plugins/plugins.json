[
  {
    "kind": "plugin",
    "type": "step",
    "name": "acr",
    "spec": {
      "name": "Azure container Registry",
      "description": "The ACR plugin can be used to build and publish images to the Azure ECR\nregistry.\n",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/acr",
          "envs": {
            "PLUGIN_REGISTRY": "<+ inputs.registry >",
            "PLUGIN_REPO": "<+ inputs.repo >",
            "PLUGIN_SERVICE_PRINCIPAL_CLIENT_ID": "<+ inputs.service_principal_client_id >",
            "PLUGIN_SERVICE_PRINCIPAL_CLIENT_SECRET": "<+ inputs.service_principal_client_secret >"
          }
        }
      },
      "inputs": {
        "registry": { "type": "string", "description": "authenticates to this registry", "default": "azurecr.io" },
        "repo": { "type": "string", "description": "repository name for the image" },
        "service_principal_client_id": { "type": "string", "description": "authenticates with this username" },
        "service_principal_client_secret": { "type": "string", "description": "authenticates with this password" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "airbrake-deployment",
    "spec": {
      "name": "airbrake-deployment",
      "description": "Use the airbrake-deployment plugin to notify Airbrake of deployment in a certain environment.",
      "step": {
        "type": "script",
        "spec": {
          "image": "dhoeric/drone-airbrake-deployment",
          "envs": {
            "PLUGIN_AIRBRAKE_ENVIRONMENT": "<+ inputs.airbrake_environment >",
            "PLUGIN_SECRETS": "<+ inputs.secrets >"
          }
        }
      },
      "inputs": {
        "airbrake_environment": {
          "type": "string",
          "description": "environment have been deployed in the drone build",
          "required": true
        },
        "secrets": {
          "type": "array",
          "description": "project ID of airbrake project & project API key of airbrake project",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "ansible",
    "spec": {
      "name": "Ansible",
      "description": "The Ansible plugin can be used to run ansible plays.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/ansible",
          "envs": {
            "PLUGIN_BECOME": "<+ inputs.become >",
            "PLUGIN_BECOME_METHOD": "<+ inputs.become_method >",
            "PLUGIN_BECOME_USER": "<+ inputs.become_user >",
            "PLUGIN_CHECK": "<+ inputs.check >",
            "PLUGIN_CONNECTION": "<+ inputs.connection >",
            "PLUGIN_DIFF": "<+ inputs.diff >",
            "PLUGIN_EXTRA_VARS": "<+ inputs.extra_vars >",
            "PLUGIN_FLUSH_CACHE": "<+ inputs.flush_cache >",
            "PLUGIN_FORCE_HANDLERS": "<+ inputs.force_handlers >",
            "PLUGIN_FORKS": "<+ inputs.forks >",
            "PLUGIN_GALAXY": "<+ inputs.galaxy >",
            "PLUGIN_GALAXY_FORCE": "<+ inputs.galaxy_force >",
            "PLUGIN_INVENTORY": "<+ inputs.inventory >",
            "PLUGIN_LIMIT": "<+ inputs.limit >",
            "PLUGIN_LIST_HOSTS": "<+ inputs.list_hosts >",
            "PLUGIN_LIST_TAGS": "<+ inputs.list_tags >",
            "PLUGIN_LIST_TASKS": "<+ inputs.list_tasks >",
            "PLUGIN_MODULE_PATH": "<+ inputs.module_path >",
            "PLUGIN_PLAYBOOK": "<+ inputs.playbook >",
            "PLUGIN_PRIVATE_KEY": "<+ inputs.private_key >",
            "PLUGIN_REQUIREMENTS": "<+ inputs.requirements >",
            "PLUGIN_SCP_EXTRA_ARGS": "<+ inputs.scp_extra_args >",
            "PLUGIN_SFTP_EXTRA_ARGS": "<+ inputs.sftp_extra_args >",
            "PLUGIN_SKIP_TAGS": "<+ inputs.skip_tags >",
            "PLUGIN_SSH_COMMON_ARGS": "<+ inputs.ssh_common_args >",
            "PLUGIN_SSH_EXTRA_ARGS": "<+ inputs.ssh_extra_args >",
            "PLUGIN_START_AT_TASK": "<+ inputs.start_at_task >",
            "PLUGIN_SYNTAX_CHECK": "<+ inputs.syntax_check >",
            "PLUGIN_TAGS": "<+ inputs.tags >",
            "PLUGIN_TIMEOUT": "<+ inputs.timeout >",
            "PLUGIN_USER": "<+ inputs.user >",
            "PLUGIN_VAULT_ID": "<+ inputs.vault_id >",
            "PLUGIN_VAULT_PASSWORD": "<+ inputs.vault_password >",
            "PLUGIN_VERBOSE": "<+ inputs.verbose >"
          }
        }
      },
      "inputs": {
        "become": { "type": "boolean", "description": "run operations with become", "default": "false" },
        "become_method": { "type": "string", "description": "privilege escalation method to use" },
        "become_user": { "type": "string", "description": "run operations as this user" },
        "check": { "type": "boolean", "description": "run a check, do not apply any changes", "default": "false" },
        "connection": { "type": "string", "description": "connection type to use" },
        "diff": { "type": "boolean", "description": "show the differences, may print secrets", "default": "false" },
        "extra_vars": {
          "type": "string",
          "description": "set additional variables as key=value e.g. 'key1=value1,[key2=value2]'"
        },
        "flush_cache": {
          "type": "boolean",
          "description": "clear the fact cache for every host in inventory",
          "default": "false"
        },
        "force_handlers": { "type": "boolean", "description": "run handlers even if a task fails", "default": "false" },
        "forks": { "type": "number", "description": "specify number of parallel processes to use", "default": "5" },
        "galaxy": { "type": "string", "description": "path to galaxy requirements" },
        "galaxy_force": {
          "type": "boolean",
          "description": "force overwriting an existing role or collection",
          "default": "true"
        },
        "inventory": {
          "type": "string",
          "description": "specify (multiple) inventory host path(s) e.g. 'path1,[path2]'"
        },
        "limit": { "type": "string", "description": "further limit selected hosts to an additional pattern" },
        "list_hosts": { "type": "boolean", "description": "outputs a list of matching hosts", "default": "false" },
        "list_tags": { "type": "boolean", "description": "list all available tags", "default": "false" },
        "list_tasks": { "type": "boolean", "description": "list all tasks that would be executed", "default": "false" },
        "module_path": { "type": "string", "description": "prepend paths to module library e.g. 'path1,[path2]'" },
        "playbook": { "type": "string", "description": "list of playbooks to apply e.g. 'playbook1,[playbook2]'" },
        "private_key": { "type": "string", "description": "use this key to authenticate the ssh connection" },
        "requirements": { "type": "string", "description": "path to python requirements" },
        "scp_extra_args": { "type": "string", "description": "specify extra arguments to pass to scp only" },
        "sftp_extra_args": { "type": "string", "description": "specify extra arguments to pass to sftp only" },
        "skip_tags": { "type": "array", "description": "only run plays and tasks whose tags do not match" },
        "ssh_common_args": { "type": "string", "description": "specify common arguments to pass to sftp/scp/ssh" },
        "ssh_extra_args": { "type": "string", "description": "specify extra arguments to pass to ssh only" },
        "start_at_task": { "type": "string", "description": "start the playbook at the task matching this name" },
        "syntax_check": {
          "type": "boolean",
          "description": "perform a syntax check on the playbook",
          "default": "false"
        },
        "tags": { "type": "array", "description": "only run plays and tasks tagged with these values" },
        "timeout": { "type": "number", "description": "override the connection timeout in seconds", "default": "0" },
        "user": { "type": "string", "description": "connect as this user" },
        "vault_id": { "type": "string", "description": "the vault identity to use" },
        "vault_password": { "type": "string", "description": "the vault password to use" },
        "verbose": { "type": "number", "description": "level of verbosity, 0 up to 4", "default": "0" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "anynines",
    "spec": {
      "name": "Anynines",
      "description": "This plugin deploys your application on the Anynines platform.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/anynines",
          "envs": {
            "PLUGIN_ORGANIZATION": "<+ inputs.organization >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_SKIP_CLEANUP": "<+ inputs.skip_cleanup >",
            "PLUGIN_SPACE": "<+ inputs.space >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "organization": { "type": "string", "description": "Organization on Anynines.", "required": true },
        "password": { "type": "string", "description": "Password for Anynines auth.", "required": true },
        "skip_cleanup": { "type": "boolean", "description": "Skip cleanup of workspace.", "default": "false" },
        "space": { "type": "string", "description": "Space within Anynines organization." },
        "username": { "type": "string", "description": "Username for Anynines auth.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "apex-up",
    "spec": {
      "name": "Apex Up",
      "description": "This plugin can deploy infinitely scalable serverless apps, apis, and sites in seconds to AWS using apex/up tool.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-apex-up",
          "envs": {
            "PLUGIN_DIRECTORY": "<+ inputs.directory >",
            "PLUGIN_SECRETS": "<+ inputs.secrets >",
            "PLUGIN_STAGE": "<+ inputs.stage >",
            "PLUGIN_VERBOSE": "<+ inputs.verbose >"
          }
        }
      },
      "inputs": {
        "directory": { "type": "string", "description": "Change working directory." },
        "secrets": { "type": "array", "description": "AWS access key and secret access key.", "required": true },
        "stage": { "type": "array", "description": "Target stage names - staging or production.", "required": true },
        "verbose": { "type": "boolean", "description": "Enable verbose log output.", "default": "true" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "apko",
    "spec": {
      "name": "APKO",
      "description": "Plugin to build OCI images from APK packages without Dockerfile. Learn more about apko at https://github.com/chainguard-dev/apko.",
      "step": {
        "type": "script",
        "spec": {
          "image": "https://hub.docker.com/repository/docker/kameshsampath/apko-drone-plugin",
          "envs": {
            "PLUGIN_ARCHS": "<+ inputs.archs >",
            "PLUGIN_AWS_ACCESS_KEY_ID": "<+ inputs.aws_access_key_id >",
            "PLUGIN_AWS_SECRET_ACCESS_KEY": "<+ inputs.aws_secret_access_key >",
            "PLUGIN_BUILD_OUTPUT_DIR": "<+ inputs.build_output_dir >",
            "PLUGIN_CONFIG_FILE": "<+ inputs.config_file >",
            "PLUGIN_GOOGLE_APPLICATION_CREDENTIALS": "<+ inputs.google_application_credentials >",
            "PLUGIN_IMAGE_REGISTRY_PASSWORD": "<+ inputs.image_registry_password >",
            "PLUGIN_IMAGE_REGISTRY_USERNAME": "<+ inputs.image_registry_username >",
            "PLUGIN_IMAGE_REPO": "<+ inputs.image_repo >",
            "PLUGIN_INSECURE": "<+ inputs.insecure >",
            "PLUGIN_PUBLISH": "<+ inputs.publish >"
          }
        }
      },
      "inputs": {
        "archs": {
          "type": "array",
          "description": "The \"linux\" architecture for which the images will be built. Defaults \"$(uname -m)\". Valid values are: \"amd64\", \"arm64\".",
          "default": "$(uname -m)"
        },
        "aws_access_key_id": {
          "type": "string",
          "description": "The AWS \"AWS_ACCESS_KEY_ID\" that will be used to authenticate \"image_repo\". Valid only if \"publish is true\" and \"image_repo\" is a ECR repo"
        },
        "aws_secret_access_key": {
          "type": "string",
          "description": "The AWS \"AWS_SECRET_ACCESS_KEY\" that will be used to authenticate \"image_repo\". Valid only if \"publish is true\" and \"image_repo\" is a ECR repo"
        },
        "build_output_dir": {
          "type": "string",
          "description": "The output directory relative to `config_file` where the build artifacts will be generated.",
          "default": "dist"
        },
        "config_file": {
          "type": "string",
          "description": "The apko configuration YAML file, a path relative to drone pipeline. https://github.com/chainguard-dev/apko/blob/main/docs/apko_file.md\">",
          "required": true
        },
        "google_application_credentials": {
          "type": "string",
          "description": "The base64 encoded Google application credentials i.e. SA key.json. This parameter is useful only when your \"image_repo\" is [Google Artifact registry](https://cloud.google.com/artifact-registry/docs). NOTE: Use GNU base64 when encoding key.json e.g using jq tool `cat \"$GOOGLE_APPLICATION_CREDENTIALS\" | jq -r -c . | gbase64 --wrap=0 | pbcopy`"
        },
        "image_registry_password": {
          "type": "string",
          "description": "The user password that will be used to push the image to `image_repo`. Applicable when the `image_repo` is not GAR, ECR."
        },
        "image_registry_username": {
          "type": "string",
          "description": "The user name that will be used to push the image to `image_repo`. Applicable when the `image_repo` is not GAR, ECR."
        },
        "image_repo": {
          "type": "string",
          "description": "The fully qualified image repository where the built OCI image will be pushed. e.g. quay.io/kameshsampath/my-app:1.0.0",
          "required": true
        },
        "insecure": { "type": "boolean", "description": "Push to insecure registry.", "default": "false" },
        "publish": {
          "type": "boolean",
          "description": "Whether to publish the image to \"image_repo\". Defaults to \"false\" which will just build the image tarball in \"$PROJECT_HOME/dist\" folder.",
          "default": "false"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "artifactory",
    "spec": {
      "name": "Artifactory",
      "description": "Use this plugin to publish artifacts from the build to Artifactory.",
      "step": {
        "type": "script",
        "spec": {
          "image": "athieriot/drone-artifactory",
          "envs": {
            "PLUGIN_ARTIFACT_ID": "<+ inputs.artifact_id >",
            "PLUGIN_FILES": "<+ inputs.files >",
            "PLUGIN_FORCE_UPLOAD": "<+ inputs.force_upload >",
            "PLUGIN_GROUP_ID": "<+ inputs.group_id >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_POM": "<+ inputs.pom >",
            "PLUGIN_REPO_KEY": "<+ inputs.repo_key >",
            "PLUGIN_URL": "<+ inputs.url >",
            "PLUGIN_USERNAME": "<+ inputs.username >",
            "PLUGIN_VERSION": "<+ inputs.version >"
          }
        }
      },
      "inputs": {
        "artifact_id": {
          "type": "string",
          "description": "Project artifact id.",
          "default": "default to value from Pom file."
        },
        "files": { "type": "array", "description": "List of files to deploy." },
        "force_upload": {
          "type": "boolean",
          "description": "Force upload if a file already exists.",
          "default": "false"
        },
        "group_id": {
          "type": "string",
          "description": "Project group id.",
          "default": "default to value from Pom file."
        },
        "password": { "type": "string", "description": "Artifactory password.", "required": true },
        "pom": { "type": "string", "description": "The path to a pom.xml file were to read project details." },
        "repo_key": {
          "type": "string",
          "description": "Target repository key.",
          "default": "libs-snapshot-local if version contains snapshot, libs-release-local otherwise."
        },
        "url": { "type": "string", "description": "Artifactory URL (Includes scheme).", "required": true },
        "username": { "type": "string", "description": "Artifactory username.", "required": true },
        "version": {
          "type": "string",
          "description": "Artifact version.",
          "default": "default to value from Pom file."
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "b2",
    "spec": {
      "name": "Backblaze B2",
      "description": "The B2 plugin uploads files and build artifacts to your B2 bucket.",
      "step": {
        "type": "script",
        "spec": {
          "image": "techknowlogick/drone-b2",
          "envs": {
            "PLUGIN_ACCOUNT": "<+ inputs.account >",
            "PLUGIN_BUCKET": "<+ inputs.bucket >",
            "PLUGIN_EXCLUDE": "<+ inputs.exclude >",
            "PLUGIN_KEY": "<+ inputs.key >",
            "PLUGIN_PATH_STYLE": "<+ inputs.path_style >",
            "PLUGIN_SOURCE": "<+ inputs.source >",
            "PLUGIN_STRIP_PREFIX": "<+ inputs.strip_prefix >",
            "PLUGIN_TARGET": "<+ inputs.target >"
          }
        }
      },
      "inputs": {
        "account": { "type": "string", "description": "backblaze account ID." },
        "bucket": { "type": "string", "description": "bucket name." },
        "exclude": { "type": "array", "description": "glob exclusion patterns." },
        "key": { "type": "string", "description": "backblaze secret key." },
        "path_style": { "type": "string", "description": "whether path style URLs should be used (true for minio)." },
        "source": { "type": "string", "description": "source location of the files, using a glob matching pattern." },
        "strip_prefix": { "type": "boolean", "description": "strip the prefix from source path.", "default": "false" },
        "target": { "type": "string", "description": "target location of files in the bucket." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "bluemix-cloudfoundry",
    "spec": {
      "name": "Bluemix Cloud Foundry",
      "description": "The Bluemix Cloud Foundry plugin can be used to deploy files and/or services to Bluemix.",
      "step": {
        "type": "script",
        "spec": {
          "image": "ibmclouddevops/drone-bluemix-cloudfoundry",
          "envs": {
            "PLUGIN_API": "<+ inputs.api >",
            "PLUGIN_BLUEMIX_API": "<+ inputs.BLUEMIX_API >",
            "PLUGIN_BLUEMIX_ORG": "<+ inputs.BLUEMIX_ORG >",
            "PLUGIN_BLUEMIX_PASSWORD": "<+ inputs.BLUEMIX_PASSWORD >",
            "PLUGIN_BLUEMIX_SPACE": "<+ inputs.BLUEMIX_SPACE >",
            "PLUGIN_BLUEMIX_USER": "<+ inputs.BLUEMIX_USER >",
            "PLUGIN_BUILDPACK": "<+ inputs.buildpack >",
            "PLUGIN_COMMAND": "<+ inputs.command >",
            "PLUGIN_DISK": "<+ inputs.disk >",
            "PLUGIN_DOCKER_IMAGE": "<+ inputs.docker_image >",
            "PLUGIN_DOMAIN": "<+ inputs.domain >",
            "PLUGIN_HEALTH_CHECK_TYPE": "<+ inputs.health_check_type >",
            "PLUGIN_HOSTNAME": "<+ inputs.hostname >",
            "PLUGIN_INSTANCES": "<+ inputs.instances >",
            "PLUGIN_MANIFEST": "<+ inputs.manifest >",
            "PLUGIN_MEMORY": "<+ inputs.memory >",
            "PLUGIN_NAME": "<+ inputs.name >",
            "PLUGIN_NO_HOSTNAME": "<+ inputs.no_hostname >",
            "PLUGIN_NO_MANIFEST": "<+ inputs.no_manifest >",
            "PLUGIN_NO_ROUTE": "<+ inputs.no_route >",
            "PLUGIN_NO_START": "<+ inputs.no_start >",
            "PLUGIN_ORG": "<+ inputs.org >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PATH": "<+ inputs.path >",
            "PLUGIN_RANDOM_ROUTE": "<+ inputs.random_route >",
            "PLUGIN_ROUTE_PATH": "<+ inputs.route_path >",
            "PLUGIN_SKIP_SSL": "<+ inputs.skip_ssl >",
            "PLUGIN_SPACE": "<+ inputs.space >",
            "PLUGIN_STACK": "<+ inputs.stack >",
            "PLUGIN_TIMEOUT": "<+ inputs.timeout >",
            "PLUGIN_USER": "<+ inputs.user >"
          }
        }
      },
      "inputs": {
        "BLUEMIX_API": { "type": "string", "description": "target api endpoint (e.g. https://api.example.com)." },
        "BLUEMIX_ORG": { "type": "string", "description": "target BLUEMIX org." },
        "BLUEMIX_PASSWORD": { "type": "string", "description": "BLUEMIX password." },
        "BLUEMIX_SPACE": { "type": "boolean", "description": "target BLUEMIX space.", "default": "false" },
        "BLUEMIX_USER": { "type": "string", "description": "BLUEMIX username." },
        "api": { "type": "string", "description": "Target API (e.g. api.ng.bluemix.net)." },
        "buildpack": { "type": "string", "description": "Custom buildpack (e.g. https://....)." },
        "command": { "type": "string", "description": "Startup command (e.g. start-script.sh)." },
        "disk": { "type": "string", "description": "Disk limit (e.g. 256M)." },
        "docker_image": {
          "type": "string",
          "description": "Image name (e.g. ibmclouddevops/drone-bluemix-cloudfoundry)."
        },
        "domain": { "type": "string", "description": "Domain (e.g. example.com)." },
        "health_check_type": { "type": "string", "description": "Application health check type (e.g. port)." },
        "hostname": { "type": "string", "description": "Hostname (e.g. my-app)." },
        "instances": { "type": "number", "description": "Number of instances (e.g. 2)." },
        "manifest": { "type": "string", "description": "Path to manifest (e.g. test.manifest.yml)." },
        "memory": { "type": "string", "description": "Memory limit (e.g. 256M)." },
        "name": { "type": "string", "description": "Override application name (e.g. app-canary)." },
        "no_hostname": { "type": "boolean", "description": "Map the root domain to this app", "default": "false" },
        "no_manifest": { "type": "boolean", "description": "Ignore manifest file", "default": "false" },
        "no_route": {
          "type": "boolean",
          "description": "Do not map a route to this app and remove routes from previous pushes of this app.",
          "default": "false"
        },
        "no_start": { "type": "boolean", "description": "Do not start an app after pushing.", "default": "false" },
        "org": { "type": "string", "description": "Target Org (e.g. xyz-org)." },
        "password": { "type": "string", "description": "Auth password (e.g. mypassword)." },
        "path": { "type": "string", "description": "App path (e.g. build/assets)." },
        "random_route": { "type": "boolean", "description": "Create a random route for this app.", "default": "false" },
        "route_path": { "type": "string", "description": "Path for the route (e.g. about)." },
        "skip_ssl": {
          "type": "boolean",
          "description": "Skip verification of the API endpoint. Not recommended!.",
          "default": "false"
        },
        "space": { "type": "string", "description": "Target Space (e.g. development)." },
        "stack": { "type": "string", "description": "Stack to use (e.g. cflinuxfs2)." },
        "timeout": { "type": "number", "description": "App start timeout (e.g. 60)." },
        "user": { "type": "string", "description": "Auth username (e.g. john@doe.com)." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "buildah",
    "spec": {
      "name": "Drone Buildah",
      "description": "Drone plugin uses Buildah to build and publish Docker images to a container registry. It mimics the Docker plugin.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/buildah-docker",
          "envs": {
            "PLUGIN_ARGS": "<+ inputs.args >",
            "PLUGIN_ARGS-FROM-ENV": "<+ inputs.args-from-env >",
            "PLUGIN_AUTO-LABEL": "<+ inputs.auto-label >",
            "PLUGIN_COMPRESS": "<+ inputs.compress >",
            "PLUGIN_CONTEXT": "<+ inputs.context >",
            "PLUGIN_CUSTOM-LABELS": "<+ inputs.custom-labels >",
            "PLUGIN_DOCKERFILE": "<+ inputs.dockerfile >",
            "PLUGIN_DRY-RUN": "<+ inputs.dry-run >",
            "PLUGIN_LABEL-SCHEMA": "<+ inputs.label-schema >",
            "PLUGIN_LINK": "<+ inputs.link >",
            "PLUGIN_PULL-IMAGE": "<+ inputs.pull-image >",
            "PLUGIN_QUIET": "<+ inputs.quiet >",
            "PLUGIN_REPO": "<+ inputs.repo >",
            "PLUGIN_SQUASH": "<+ inputs.squash >",
            "PLUGIN_TAGS": "<+ inputs.tags >",
            "PLUGIN_TAGS_AUTO": "<+ inputs.tags_auto >",
            "PLUGIN_TAGS_SUFFIX": "<+ inputs.tags_suffix >",
            "PLUGIN_TARGET": "<+ inputs.target >"
          }
        }
      },
      "inputs": {
        "args": { "type": "string", "description": "additional build args" },
        "args-from-env": { "type": "string", "description": "additional build args from env" },
        "auto-label": { "type": "boolean", "description": "auto label image", "default": "false" },
        "compress": { "type": "boolean", "description": "compress image layers", "default": "false" },
        "context": { "type": "string", "description": "build context", "default": "." },
        "custom-labels": { "type": "array", "description": "additional k=v labels", "default": "[]" },
        "dockerfile": { "type": "string", "description": "dockerfile to use", "default": "Dockerfile" },
        "dry-run": { "type": "boolean", "description": "dry run disables docker push", "default": "false" },
        "label-schema": { "type": "string", "description": "label schema to use" },
        "link": { "type": "string", "description": "link, for example https://example.com/org/repo-name" },
        "pull-image": { "type": "boolean", "description": "force pull base image at build time", "default": "false" },
        "quiet": { "type": "boolean", "description": "quiet mode", "default": "false" },
        "repo": { "type": "string", "description": "docker repository used to push image" },
        "squash": { "type": "boolean", "description": "squash image layers", "default": "false" },
        "tags": {
          "type": "string",
          "description": "tag used to tage built image, default \"latest\"",
          "default": "list"
        },
        "tags_auto": { "type": "string", "description": "default build tags" },
        "tags_suffix": { "type": "string", "description": "suffix to append to build tags" },
        "target": { "type": "string", "description": "build target" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "cache",
    "spec": {
      "name": "Drone Cache",
      "description": "A Drone plugin for caching current workspace files between builds to reduce your build times. `drone-cache` is a small CLI program, written in Go without any external OS dependencies (such as tar, etc).",
      "step": {
        "type": "script",
        "spec": {
          "image": "meltwater/drone-cache",
          "envs": {
            "PLUGIN_ACCESS-KEY": "<+ inputs.access-key >",
            "PLUGIN_ACL": "<+ inputs.acl >",
            "PLUGIN_ARCHIVE-FORMAT": "<+ inputs.archive-format >",
            "PLUGIN_BACKEND": "<+ inputs.backend >",
            "PLUGIN_BUCKET": "<+ inputs.bucket >",
            "PLUGIN_CACHE-KEY": "<+ inputs.cache-key >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_ENCRYPTION": "<+ inputs.encryption >",
            "PLUGIN_ENDPOINT": "<+ inputs.endpoint >",
            "PLUGIN_FILESYSTEM-CACHE-ROUTE": "<+ inputs.filesystem-cache-route >",
            "PLUGIN_MOUNT": "<+ inputs.mount >",
            "PLUGIN_PATH-STYLE": "<+ inputs.path-style >",
            "PLUGIN_REBUILD": "<+ inputs.rebuild >",
            "PLUGIN_REGION": "<+ inputs.region >",
            "PLUGIN_RESTORE": "<+ inputs.restore >",
            "PLUGIN_SECRET-KEY": "<+ inputs.secret-key >"
          }
        }
      },
      "inputs": {
        "access-key": { "type": "string", "description": "AWS access key." },
        "acl": {
          "type": "string",
          "description": "upload files with acl (private, public-read, ...).",
          "default": "private"
        },
        "archive-format": {
          "type": "string",
          "description": "archive format to use for the cache directories (tar, gzip).",
          "default": "tar"
        },
        "backend": {
          "type": "string",
          "description": "cache backend to use in plugin (s3, filesystem).",
          "default": "s3"
        },
        "bucket": { "type": "string", "description": "AWS bucket name." },
        "cache-key": { "type": "string", "description": "cache key to use for the cache directories." },
        "debug": { "type": "boolean", "description": "whether to enable debug mode.", "default": "false" },
        "encryption": {
          "type": "string",
          "description": "server-side encryption algorithm (AES256, aws:kms).",
          "default": "none"
        },
        "endpoint": { "type": "string", "description": "endpoint for the s3 connection." },
        "filesystem-cache-route": {
          "type": "string",
          "description": "local filesystem root directory for the filesystem cache.",
          "default": "/tmp/cache"
        },
        "mount": {
          "type": "array",
          "description": "cache directories, an array of folders to cache.",
          "default": "[]"
        },
        "path-style": {
          "type": "boolean",
          "description": "use path style for bucket paths. (true for minio, false for aws).",
          "default": "false"
        },
        "rebuild": {
          "type": "boolean",
          "description": "whether to rebuild the cache directories.",
          "default": "false"
        },
        "region": { "type": "string", "description": "AWS bucket region." },
        "restore": {
          "type": "boolean",
          "description": "whether to restore the cache directories.",
          "default": "false"
        },
        "secret-key": { "type": "string", "description": "AWS secret key." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "capistrano",
    "spec": {
      "name": "Capistrano",
      "description": "The Capistrano plugin deploys applications via the Capistrano ruby gem.",
      "step": {
        "type": "script",
        "spec": {
          "image": "glaszig/drone-capistrano",
          "envs": {
            "PLUGIN_CAPISTRANO_PRIVATE_KEY": "<+ inputs.capistrano_private_key >",
            "PLUGIN_CAPISTRANO_PUBLIC_KEY": "<+ inputs.capistrano_public_key >",
            "PLUGIN_TASKS": "<+ inputs.tasks >"
          }
        }
      },
      "inputs": {
        "capistrano_private_key": { "type": "string", "description": "Private SSH deploy key", "required": true },
        "capistrano_public_key": { "type": "string", "description": "Public SSH deploy key", "required": true },
        "tasks": { "type": "string", "description": "The Capistrano tasks to run", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "captains-log",
    "spec": {
      "name": "Captains Log",
      "description": "A Drone plugin that helps organize release information in Slack",
      "step": {
        "type": "script",
        "spec": {
          "image": "target/captains-log",
          "envs": {
            "PLUGIN_ENTERPRISE_HOST": "<+ inputs.enterprise_host >",
            "PLUGIN_GITHUB_OWNER": "<+ inputs.github_owner >",
            "PLUGIN_GITHUB_REPO": "<+ inputs.github_repo >",
            "PLUGIN_GITHUB_TAG_ID": "<+ inputs.github_tag_id >",
            "PLUGIN_JIRA_TEAM_DOMAIN": "<+ inputs.jira_team_domain >",
            "PLUGIN_SECRETS": "<+ inputs.secrets >",
            "PLUGIN_SLACK_CHANNEL": "<+ inputs.slack_channel >",
            "PLUGIN_TEAMS": "<+ inputs.teams >"
          }
        }
      },
      "inputs": {
        "enterprise_host": {
          "type": "string",
          "description": "if you use Enterprise Github, this is where you would supply the custom domain."
        },
        "github_owner": { "type": "string", "description": "The owner of the GitHub repository", "required": true },
        "github_repo": { "type": "string", "description": "Target repository name", "required": true },
        "github_tag_id": { "type": "string", "description": "regex to match on specific tags" },
        "jira_team_domain": {
          "type": "string",
          "description": "namespace of Jira workspace (e.g. `jira.myteamnamespace.com`)",
          "required": true
        },
        "secrets": { "type": "string", "description": "slack and github secrets" },
        "slack_channel": {
          "type": "string",
          "description": "when using the API, you should use slack_channel to specify which room you'd like to post to. When using SLACK_URL you should not specify the room (i.e. slack_channel) because the room is already a part of the webhook."
        },
        "teams": {
          "type": "array",
          "description": "a list of teams which allows you to organize the output of Captains Log into meaningful chunks."
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "chef-supermarket",
    "spec": {
      "name": "Chef Supermarket",
      "description": "The Chef Supermarket plugin can publish cookbooks to Supermarket (internal or public).",
      "step": {
        "type": "script",
        "spec": {
          "image": "jmccann/drone-chef-supermarket",
          "envs": {
            "PLUGIN_PRIVATE_KEY": "<+ inputs.private_key >",
            "PLUGIN_SERVER": "<+ inputs.server >",
            "PLUGIN_SSL_VERIFY": "<+ inputs.ssl_verify >",
            "PLUGIN_USER": "<+ inputs.user >"
          }
        }
      },
      "inputs": {
        "private_key": { "type": "string", "description": "private key contents to auth to server with" },
        "server": {
          "type": "string",
          "description": "Supermarket server to connect to",
          "default": "https://supermarket.chef.io"
        },
        "ssl_verify": { "type": "boolean", "description": "Enable/Disable SSL verify", "default": "true" },
        "user": { "type": "string", "description": "connects as this user" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "circleci",
    "spec": {
      "name": "CircleCI",
      "description": "The CircleCI plugin allows you to trigger builds automatically.",
      "step": {
        "type": "script",
        "spec": {
          "image": "wesleimp/drone-circleci",
          "envs": {
            "PLUGIN_BRANCH": "<+ inputs.branch >",
            "PLUGIN_REPO": "<+ inputs.repo >",
            "PLUGIN_TOKEN": "<+ inputs.token >",
            "PLUGIN_USER": "<+ inputs.user >"
          }
        }
      },
      "inputs": {
        "branch": { "type": "string", "description": "CircleCI branch.", "default": "default" },
        "repo": { "type": "string", "description": "CircleCI repo." },
        "token": { "type": "string", "description": "CircleCI user token." },
        "user": { "type": "string", "description": "CircleCI user." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "clair",
    "spec": {
      "name": "Clair",
      "description": "The Clair plugin submits your docker image to your Clair server to scan your docker image for security vulnerabilities.",
      "step": {
        "type": "script",
        "spec": {
          "image": "jmccann/drone-clair",
          "envs": {
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_SCAN_IMAGE": "<+ inputs.scan_image >",
            "PLUGIN_URL": "<+ inputs.url >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "password": { "type": "string", "description": "Docker Registry password to download the `scan_image` from" },
        "scan_image": {
          "type": "string",
          "description": "The docker image to scan.  Supports Docker Hub or private repos."
        },
        "url": { "type": "string", "description": "Clair server URL" },
        "username": { "type": "string", "description": "Docker Registry username to download the `scan_image` from" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "cloudflare-caching",
    "spec": {
      "name": "Cloudflare Caching",
      "description": "Our Drone plugin enables the ability for your pipeline to interface with Cloudflare's API to purge cache.",
      "step": {
        "type": "script",
        "spec": {
          "image": "jetrails/drone-cloudflare-caching",
          "envs": {
            "PLUGIN_ACTION": "<+ inputs.action >",
            "PLUGIN_API_TOKEN": "<+ inputs.api_token >",
            "PLUGIN_LIST": "<+ inputs.list >",
            "PLUGIN_ZONE_IDENTIFIER": "<+ inputs.zone_identifier >"
          }
        }
      },
      "inputs": {
        "action": {
          "type": "string",
          "description": "What type of cache purge, options are purge_everything, purge_hosts, purge_files, purge_tags.",
          "default": "purge_everything",
          "required": true
        },
        "api_token": { "type": "string", "description": "Cloudflare API token.", "required": true },
        "list": {
          "type": "array",
          "description": "List of values, could be valid hosts, tags, or files depending on action parameter value."
        },
        "zone_identifier": { "type": "string", "description": "Cloudflare zone id.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "cloudflare-dns",
    "spec": {
      "name": "Cloudflare DNS",
      "description": "Our Drone plugin enables the ability for your pipeline to interface with Cloudflare's API to create/update/delete DNS records.",
      "step": {
        "type": "script",
        "spec": {
          "image": "jetrails/drone-cloudflare-dns",
          "envs": {
            "PLUGIN_ACTION": "<+ inputs.action >",
            "PLUGIN_API_TOKEN": "<+ inputs.api_token >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_RECORD_CONTENT": "<+ inputs.record_content >",
            "PLUGIN_RECORD_NAME": "<+ inputs.record_name >",
            "PLUGIN_RECORD_PRIORITY": "<+ inputs.record_priority >",
            "PLUGIN_RECORD_PROXIED": "<+ inputs.record_proxied >",
            "PLUGIN_RECORD_TTL": "<+ inputs.record_ttl >",
            "PLUGIN_RECORD_TYPE": "<+ inputs.record_type >",
            "PLUGIN_ZONE_IDENTIFIER": "<+ inputs.zone_identifier >"
          }
        }
      },
      "inputs": {
        "action": { "type": "string", "description": "What type of action, options are set, unset." },
        "api_token": { "type": "string", "description": "Cloudflare API token.", "required": true },
        "debug": { "type": "boolean", "description": "Display debug data.", "default": "false" },
        "record_content": { "type": "string", "description": "Value of DNS record." },
        "record_name": { "type": "string", "description": "Name of DNS record.", "required": true },
        "record_priority": { "type": "number", "description": "Priority value for DNS record.", "default": "1" },
        "record_proxied": { "type": "boolean", "description": "Proxy record through cloudflare.", "default": "true" },
        "record_ttl": {
          "type": "number",
          "description": "Time to live value in seconds for DNS record.",
          "default": "1"
        },
        "record_type": {
          "type": "string",
          "description": "Type of DNS record, examples include A, CNAME, NS, etc.",
          "required": true
        },
        "zone_identifier": { "type": "string", "description": "Cloudflare zone id.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "cloudflare-pages",
    "spec": {
      "name": "CloudFlare Pages",
      "description": "The Cloudflare Pages plugin is used to publish static websites to CloudFlare Pages. The following configuration uses the wrangler cli to publish a website.",
      "step": {
        "type": "script",
        "spec": {
          "image": "mgzamharness/cf-pages-drone-plugin",
          "envs": {
            "PLUGIN_BRANCH": "<+ inputs.branch >",
            "PLUGIN_CLOUDFLARE_ACCOUNT_ID": "<+ inputs.cloudflare_account_id >",
            "PLUGIN_CLOUDFLARE_API_TOKEN": "<+ inputs.cloudflare_api_token >",
            "PLUGIN_PATH": "<+ inputs.path >",
            "PLUGIN_PROJECT_NAME": "<+ inputs.project_name >",
            "PLUGIN_REPO_URL": "<+ inputs.repo_url >"
          }
        }
      },
      "inputs": {
        "branch": { "type": "string", "description": "Cloudflare target branch", "default": "main", "required": true },
        "cloudflare_account_id": { "type": "string", "description": "CloudFlare Account ID", "required": true },
        "cloudflare_api_token": {
          "type": "string",
          "description": "CloudFlare API Token for authentication",
          "required": true
        },
        "path": {
          "type": "string",
          "description": "The directory of content to publish",
          "default": ".",
          "required": true
        },
        "project_name": {
          "type": "string",
          "description": "The cloudflare project name",
          "default": "demo",
          "required": true
        },
        "repo_url": { "type": "string", "description": "GitHub repo URL for code to publish", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "cloudformation",
    "spec": {
      "name": "AWS CloudFormation",
      "description": "The CloudFormation plugin can be used to create/update or delete stacks, and to validate templates.",
      "step": {
        "type": "script",
        "spec": {
          "image": "robertstettner/drone-cloudformation",
          "envs": {
            "PLUGIN_ACCESS_KEY": "<+ inputs.access_key >",
            "PLUGIN_BATCH": "<+ inputs.batch >",
            "PLUGIN_MODE": "<+ inputs.mode >",
            "PLUGIN_PARALLEL": "<+ inputs.parallel >",
            "PLUGIN_PARAMS": "<+ inputs.params >",
            "PLUGIN_REGION": "<+ inputs.region >",
            "PLUGIN_SECRET_KEY": "<+ inputs.secret_key >",
            "PLUGIN_STACKNAME": "<+ inputs.stackname >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >"
          }
        }
      },
      "inputs": {
        "access_key": { "type": "string", "description": "the AWS access key." },
        "batch": { "type": "array", "description": "an array of configurations." },
        "mode": {
          "type": "string",
          "description": "Mode to run the plugin, options are createOrUpdate, create, delete, validate.",
          "default": "createOrUpdate"
        },
        "parallel": { "type": "boolean", "description": "whether to run the batch in parallel.", "default": "false" },
        "params": {
          "type": "object",
          "description": "object of parameters to feed into the template. Not needed for validate and delete modes."
        },
        "region": { "type": "string", "description": "the AWS region to deploy to.", "default": "eu-west-1" },
        "secret_key": { "type": "string", "description": "the AWS secret key." },
        "stackname": {
          "type": "string",
          "description": "the name of the CloudFormation stack. Required for all but validate mode."
        },
        "template": {
          "type": "string",
          "description": "the path to the CloudFormation template. Required for all but delete mode."
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "cloudfoundry",
    "spec": {
      "name": "Cloud Foundry",
      "description": "The Cloud Foundry plugin can be used to deploy files and/or services to Cloud Foundry.",
      "step": {
        "type": "script",
        "spec": {
          "image": "cheslip/drone-cloudfoundry",
          "envs": {
            "PLUGIN_API": "<+ inputs.api >",
            "PLUGIN_BUILDPACK": "<+ inputs.buildpack >",
            "PLUGIN_CF_API": "<+ inputs.CF_API >",
            "PLUGIN_CF_ORG": "<+ inputs.CF_ORG >",
            "PLUGIN_CF_PASSWORD": "<+ inputs.CF_PASSWORD >",
            "PLUGIN_CF_SPACE": "<+ inputs.CF_SPACE >",
            "PLUGIN_CF_USER": "<+ inputs.CF_USER >",
            "PLUGIN_COMMAND": "<+ inputs.command >",
            "PLUGIN_DISK": "<+ inputs.disk >",
            "PLUGIN_DOCKER_IMAGE": "<+ inputs.docker_image >",
            "PLUGIN_DOMAIN": "<+ inputs.domain >",
            "PLUGIN_HEALTH_CHECK_TYPE": "<+ inputs.health_check_type >",
            "PLUGIN_HOSTNAME": "<+ inputs.hostname >",
            "PLUGIN_INSTANCES": "<+ inputs.instances >",
            "PLUGIN_MANIFEST": "<+ inputs.manifest >",
            "PLUGIN_MEMORY": "<+ inputs.memory >",
            "PLUGIN_NAME": "<+ inputs.name >",
            "PLUGIN_NO_HOSTNAME": "<+ inputs.no_hostname >",
            "PLUGIN_NO_MANIFEST": "<+ inputs.no_manifest >",
            "PLUGIN_NO_ROUTE": "<+ inputs.no_route >",
            "PLUGIN_NO_START": "<+ inputs.no_start >",
            "PLUGIN_ORG": "<+ inputs.org >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PATH": "<+ inputs.path >",
            "PLUGIN_RANDOM_ROUTE": "<+ inputs.random_route >",
            "PLUGIN_ROUTE_PATH": "<+ inputs.route_path >",
            "PLUGIN_SKIP_SSL": "<+ inputs.skip_ssl >",
            "PLUGIN_SPACE": "<+ inputs.space >",
            "PLUGIN_STACK": "<+ inputs.stack >",
            "PLUGIN_TIMEOUT": "<+ inputs.timeout >",
            "PLUGIN_USER": "<+ inputs.user >"
          }
        }
      },
      "inputs": {
        "CF_API": { "type": "string", "description": "Target API." },
        "CF_ORG": { "type": "string", "description": "target CF org." },
        "CF_PASSWORD": { "type": "string", "description": "CF password." },
        "CF_SPACE": { "type": "string", "description": "target CF space." },
        "CF_USER": { "type": "string", "description": "CF username." },
        "api": { "type": "string", "description": "Target API." },
        "buildpack": { "type": "string", "description": "Custom buildpack." },
        "command": { "type": "string", "description": "Startup command." },
        "disk": { "type": "string", "description": "Disk limit e.g. 256M." },
        "docker_image": { "type": "string", "description": "Image name." },
        "domain": { "type": "string", "description": "Domain." },
        "health_check_type": { "type": "string", "description": "Application health check type e.g. port." },
        "hostname": { "type": "string", "description": "Hostname." },
        "instances": { "type": "number", "description": "Number of instances." },
        "manifest": { "type": "string", "description": "Path to manifest." },
        "memory": { "type": "string", "description": "Memory limit e.g. 256M." },
        "name": { "type": "string", "description": "Override application name." },
        "no_hostname": { "type": "boolean", "description": "Map the route domain to this app.", "default": "false" },
        "no_manifest": { "type": "boolean", "description": "Ignore manifest file.", "default": "false" },
        "no_route": {
          "type": "boolean",
          "description": "Do not map a route to this app and remove routes from previous pushes of this app.",
          "default": "false"
        },
        "no_start": { "type": "boolean", "description": "Do not start an app after pushing.", "default": "false" },
        "org": { "type": "string", "description": "Target org." },
        "password": { "type": "string", "description": "Auth password." },
        "path": { "type": "string", "description": "App path." },
        "random_route": {
          "type": "boolean",
          "description": "Generate a random route for this app.",
          "default": "false"
        },
        "route_path": { "type": "string", "description": "Route path." },
        "skip_ssl": {
          "type": "boolean",
          "description": "Skip verification of the API endpoint. Not recommended!",
          "default": "false"
        },
        "space": { "type": "string", "description": "Target space." },
        "stack": { "type": "string", "description": "Stack to use." },
        "timeout": { "type": "number", "description": "App start timeout." },
        "user": { "type": "string", "description": "Auth username." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "codacy",
    "spec": {
      "name": "Codacy",
      "description": "This plugin can upload coverage reports to Codacy, currently it's limited to Golang coverage reports.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/codacy",
          "envs": { "PLUGIN_PATTERN": "<+ inputs.pattern >", "PLUGIN_TOKEN": "<+ inputs.token >" }
        }
      },
      "inputs": {
        "pattern": { "type": "string", "description": "Coverage search pattern.", "default": "**/*.out" },
        "token": { "type": "string", "description": "Codacy authentication token.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "codecov",
    "spec": {
      "name": "Codecov",
      "description": "This plugin allows for pushing test coverage results to Codecov.",
      "step": {
        "type": "script",
        "spec": {
          "image": "robertstettner/drone-codecov",
          "envs": {
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_FILES": "<+ inputs.files >",
            "PLUGIN_FLAGS": "<+ inputs.flags >",
            "PLUGIN_TOKEN": "<+ inputs.token >"
          }
        }
      },
      "inputs": {
        "debug": { "type": "boolean", "description": "enable debug mode.", "default": "false" },
        "files": { "type": "array", "description": "list of target files to upload." },
        "flags": { "type": "array", "description": "flag the upload to group coverage metrics." },
        "token": { "type": "string", "description": "Sets the private repository token.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "coveralls",
    "spec": {
      "name": "Coveralls",
      "description": "This plugin can upload coverage reports to Coveralls.",
      "step": {
        "type": "script",
        "spec": {
          "image": "lizheming/drone-coveralls",
          "envs": {
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_FILES": "<+ inputs.files >",
            "PLUGIN_TOKEN": "<+ inputs.token >"
          }
        }
      },
      "inputs": {
        "debug": { "type": "boolean", "description": "if you want to debug, set it to true.", "default": "false" },
        "files": { "type": "array", "description": "List of files to upload.", "required": true },
        "token": {
          "type": "string",
          "description": "if you have not set environment COVERALLS_REPO_TOKEN, you should set the private repository token."
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "crowdin",
    "spec": {
      "name": "Crowdin",
      "description": "The Crowdin plugin allows you to submit translation files to Crowdin.",
      "step": {
        "type": "script",
        "spec": {
          "image": "jonasfranz/crowdin",
          "envs": {
            "PLUGIN_DOWNLOAD": "<+ inputs.download >",
            "PLUGIN_EXPORT_DIR": "<+ inputs.export_dir >",
            "PLUGIN_FILES": "<+ inputs.files >",
            "PLUGIN_IGNORE_BRANCH": "<+ inputs.ignore_branch >",
            "PLUGIN_LANGUAGES": "<+ inputs.languages >",
            "PLUGIN_PROJECT_IDENTIFIER": "<+ inputs.project_identifier >",
            "PLUGIN_PROJECT_KEY": "<+ inputs.project_key >"
          }
        }
      },
      "inputs": {
        "download": {
          "type": "boolean",
          "description": "Downloads translated files from Crowdin if it is true.",
          "default": "true"
        },
        "export_dir": { "type": "string", "description": "Export directory of the translated strings." },
        "files": {
          "type": "object",
          "description": "Map of translatable files with the Crowdin file name as key and the real filepath as value. The plugin will not upload any files if this list is empty.",
          "required": true
        },
        "ignore_branch": {
          "type": "boolean",
          "description": "It will send the Drone branch to Crowdin if it is false.",
          "default": "false"
        },
        "languages": {
          "type": "array",
          "description": "Languages which should be downloaded/exported from Crowdin.",
          "default": "all"
        },
        "project_identifier": { "type": "string", "description": "Identifier provided by Crowdin.", "required": true },
        "project_key": { "type": "string", "description": "API key provided by Crowdin.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "datadog",
    "spec": {
      "name": "Datadog",
      "description": "The plugin can be used to send events and metrics to Datadog from a drone pipeline.",
      "step": {
        "type": "script",
        "spec": {
          "image": "masci/drone-datadog",
          "envs": {
            "PLUGIN_API_KEY": "<+ inputs.api_key >",
            "PLUGIN_DRY_RUN": "<+ inputs.dry_run >",
            "PLUGIN_EVENTS": "<+ inputs.events >",
            "PLUGIN_METRICS": "<+ inputs.metrics >"
          }
        }
      },
      "inputs": {
        "api_key": { "type": "string", "description": "Datadog API key." },
        "dry_run": {
          "type": "boolean",
          "description": "When set to true, the plugin only computes metrics and events without sending anything to the Datadog intake. When the plugin runs in dry mode, it doesn't require an api_key to be set, useful for testing.",
          "default": "false"
        },
        "events": {
          "type": "array",
          "description": "A list of events to be sent to Datadog. An event must have a title and a text; alert_type defaults to info.",
          "default": "[]"
        },
        "metrics": {
          "type": "array",
          "description": "A list of metrics to be sent to Datadog. A metric must have a name and a value; type defaults to gauge; tags and hostname are optional.",
          "default": "[]"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "dco",
    "spec": {
      "name": "DCO",
      "description": "The DCO plugin enforces the Developer Certificate of Origin.",
      "step": {
        "type": "script",
        "spec": { "image": "algernon/drone-plugin-dco", "envs": { "PLUGIN_DEBUG": "<+ inputs.debug >" } }
      },
      "inputs": { "debug": { "type": "boolean", "description": "whether to enable debug mode.", "default": "false" } }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "deta",
    "spec": {
      "name": "Deta",
      "description": "The Deta plugin deploy your build to deta.sh(https://deta.sh).\n",
      "step": {
        "type": "script",
        "spec": {
          "image": "lizheming/drone-deta",
          "envs": {
            "PLUGIN_ACCESS_TOKEN": "<+ inputs.access_token >",
            "PLUGIN_NAME": "<+ inputs.name >",
            "PLUGIN_PROJECT": "<+ inputs.project >",
            "PLUGIN_PROJECT_DIR": "<+ inputs.project_dir >"
          }
        }
      },
      "inputs": {
        "access_token": {
          "type": "string",
          "description": "Deta access token. \nHow to get Deta access token? https://docs.deta.sh/docs/cli/auth#deta-access-tokens\n"
        },
        "name": { "type": "string", "description": "Deta micro name", "required": true },
        "project": { "type": "string", "description": "Deta project name", "default": "default" },
        "project_dir": { "type": "string", "description": "irectory of the project", "default": "." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "diagnostics",
    "spec": {
      "name": "diagnostics",
      "description": "A plugin with cli network tools (dig / ping / traceroute) to diagnose issues in a build. It does not accept any properties.",
      "step": { "type": "script", "spec": { "image": "plugins/drone-diagnostics" } },
      "inputs": {}
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "dingtalk-message",
    "spec": {
      "name": "DingTalk",
      "description": "The DingTalk can be used to send a message by DingTalk group robot.",
      "step": {
        "type": "script",
        "spec": {
          "image": "lddsb/drone-dingtalk-message",
          "envs": {
            "PLUGIN_MESSAGE_COLOR": "<+ inputs.message_color >",
            "PLUGIN_MESSAGE_PIC": "<+ inputs.message_pic >",
            "PLUGIN_SHA_LINK": "<+ inputs.sha_link >",
            "PLUGIN_TOKEN": "<+ inputs.token >",
            "PLUGIN_TYPE": "<+ inputs.type >"
          }
        }
      },
      "inputs": {
        "message_color": {
          "type": "boolean",
          "description": "color the title and content for easier identification.",
          "default": "false"
        },
        "message_pic": {
          "type": "boolean",
          "description": "insert a picture into a message to make the content richer.",
          "default": "false"
        },
        "sha_link": {
          "type": "boolean",
          "description": "sha as a link to click to the source code page.",
          "default": "false"
        },
        "token": {
          "type": "string",
          "description": "you can get the access token when you add a bot in a group.",
          "required": true
        },
        "type": {
          "type": "string",
          "description": "dingtalk message type, markdown is the best type now.",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "discord",
    "spec": {
      "name": "Discord",
      "description": "The discord plugin posts build status messages to discord channel.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-discord",
          "envs": {
            "PLUGIN_AVATAR_URL": "<+ inputs.avatar_url >",
            "PLUGIN_MESSAGE": "<+ inputs.message >",
            "PLUGIN_TTS": "<+ inputs.tts >",
            "PLUGIN_USERNAME": "<+ inputs.username >",
            "PLUGIN_WEBHOOK_ID": "<+ inputs.webhook_id >",
            "PLUGIN_WEBHOOK_TOKEN": "<+ inputs.webhook_token >"
          }
        }
      },
      "inputs": {
        "avatar_url": { "type": "string", "description": "override the default avatar of the webhook." },
        "message": { "type": "string", "description": "the message contents (up to 2000 characters)." },
        "tts": { "type": "boolean", "description": "enable text-to-speech.", "default": "false" },
        "username": { "type": "string", "description": "override the default username of the webhook." },
        "webhook_id": { "type": "string", "description": "discord webhook id.", "required": true },
        "webhook_token": { "type": "string", "description": "discord webhook token.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "docker",
    "spec": {
      "name": "Docker",
      "description": "The Docker plugin can be used to build and publish images to the Docker\nregistry.\n",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/docker",
          "envs": {
            "PLUGIN_ADD_HOST": "<+ inputs.add_host >",
            "PLUGIN_AUTO_TAG": "<+ inputs.auto_tag >",
            "PLUGIN_AUTO_TAG_SUFFIX": "<+ inputs.auto_tag_suffix >",
            "PLUGIN_BIP": "<+ inputs.bip >",
            "PLUGIN_BUILD_ARGS": "<+ inputs.build_args >",
            "PLUGIN_BUILD_ARGS_FROM_ENV": "<+ inputs.build_args_from_env >",
            "PLUGIN_CACHE_FROM": "<+ inputs.cache_from >",
            "PLUGIN_COMPRESS": "<+ inputs.compress >",
            "PLUGIN_CONTEXT": "<+ inputs.context >",
            "PLUGIN_CUSTOM_DNS": "<+ inputs.custom_dns >",
            "PLUGIN_CUSTOM_DNS_SEARCH": "<+ inputs.custom_dns_search >",
            "PLUGIN_CUSTOM_LABELS": "<+ inputs.custom_labels >",
            "PLUGIN_DAEMON_OFF": "<+ inputs.daemon_off >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_DOCKERFILE": "<+ inputs.dockerfile >",
            "PLUGIN_DRY_RUN": "<+ inputs.dry_run >",
            "PLUGIN_EMAIL": "<+ inputs.email >",
            "PLUGIN_EXPERIMENTAL": "<+ inputs.experimental >",
            "PLUGIN_FORCE_TAG": "<+ inputs.force_tag >",
            "PLUGIN_INSECURE": "<+ inputs.insecure >",
            "PLUGIN_IPV6": "<+ inputs.ipv6 >",
            "PLUGIN_LABEL_SCHEMA": "<+ inputs.label_schema >",
            "PLUGIN_LAUNCH_DEBUG": "<+ inputs.launch_debug >",
            "PLUGIN_MIRROR": "<+ inputs.mirror >",
            "PLUGIN_MTU": "<+ inputs.mtu >",
            "PLUGIN_NO_CACHE": "<+ inputs.no_cache >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PLATFORM": "<+ inputs.platform >",
            "PLUGIN_PULL_IMAGE": "<+ inputs.pull_image >",
            "PLUGIN_PURGE": "<+ inputs.purge >",
            "PLUGIN_REGISTRY": "<+ inputs.registry >",
            "PLUGIN_REPO": "<+ inputs.repo >",
            "PLUGIN_SECRET": "<+ inputs.secret >",
            "PLUGIN_SQUASH": "<+ inputs.squash >",
            "PLUGIN_SSH-AGENT-KEY": "<+ inputs.ssh-agent-key >",
            "PLUGIN_STORAGE_DRIVER": "<+ inputs.storage_driver >",
            "PLUGIN_STORAGE_PATH": "<+ inputs.storage_path >",
            "PLUGIN_TAGS": "<+ inputs.tags >",
            "PLUGIN_TARGET": "<+ inputs.target >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "add_host": { "type": "string", "description": "additional host:IP mapping" },
        "auto_tag": {
          "type": "boolean",
          "description": "generate tag names automatically based on git branch and git tag",
          "default": "false"
        },
        "auto_tag_suffix": { "type": "string", "description": "generate tag names with this suffix" },
        "bip": { "type": "boolean", "description": "use for pass bridge ip", "default": "false" },
        "build_args": { "type": "string", "description": "pass custom arguments to docker build" },
        "build_args_from_env": {
          "type": "string",
          "description": "pass the envvars as custom arguments to docker build"
        },
        "cache_from": { "type": "string", "description": "images to consider as cache sources" },
        "compress": { "type": "boolean", "description": "compress the build context using gzip", "default": "false" },
        "context": { "type": "string", "description": "the context path to use, defaults to root of the git repo" },
        "custom_dns": { "type": "string", "description": "set custom dns servers for the container" },
        "custom_dns_search": { "type": "string", "description": "docker daemon dns search domains" },
        "custom_labels": { "type": "string", "description": "additional k=v labels" },
        "daemon_off": { "type": "boolean", "description": "don't start the docker daemon", "default": "false" },
        "debug": {
          "type": "boolean",
          "description": "launch the docker daemon in verbose debug mode",
          "default": "false"
        },
        "dockerfile": { "type": "string", "description": "dockerfile to be used", "default": "Dockerfile" },
        "dry_run": { "type": "string", "description": "boolean if the docker image should not be pushed at the end" },
        "email": { "type": "string", "description": "docker email" },
        "experimental": { "type": "boolean", "description": "docker daemon Experimental mode", "default": "false" },
        "force_tag": { "type": "boolean", "description": "replace existing matched image tags", "default": "false" },
        "insecure": {
          "type": "boolean",
          "description": "enable insecure communication to this registry",
          "default": "false"
        },
        "ipv6": { "type": "string", "description": "docker daemon IPv6 networking" },
        "label_schema": { "type": "string", "description": "label-schema labels" },
        "launch_debug": {
          "type": "boolean",
          "description": "launch the docker daemon in verbose debug mode",
          "default": "false"
        },
        "mirror": {
          "type": "string",
          "description": "use a mirror registry instead of pulling images directly from the central Hub"
        },
        "mtu": { "type": "string", "description": "docker daemon custom mtu setting" },
        "no_cache": { "type": "string", "description": "do not use cached intermediate containers" },
        "password": { "type": "string", "description": "authenticates with this password" },
        "platform": {
          "type": "string",
          "description": "specify the target platform for the build output, (for example, linux/amd64, linux/arm64, or darwin/amd64)."
        },
        "pull_image": { "type": "boolean", "description": "force pull base image at build time", "default": "false" },
        "purge": {
          "type": "boolean",
          "description": "boolean if cleanup of the docker image should be done at the end",
          "default": "true"
        },
        "registry": { "type": "string", "description": "authenticates to this registry" },
        "repo": { "type": "string", "description": "repository name for the image" },
        "secret": {
          "type": "string",
          "description": "Use buildkit to pass secrets to the dockerbuild. Eg `id=mysecret,src=secret-file`"
        },
        "squash": { "type": "boolean", "description": "squash the layers at build time", "default": "false" },
        "ssh-agent-key": {
          "type": "string",
          "description": "private key to use for ssh passthrough, see https://docs.docker.com/engine/reference/commandline/buildx_build/#ssh\n"
        },
        "storage_driver": { "type": "string", "description": "supports `aufs`, `overlay` or `vfs` drivers" },
        "storage_path": { "type": "string", "description": "docker daemon storage path" },
        "tags": { "type": "array", "description": "repository tag(s) for the image" },
        "target": { "type": "string", "description": "the build target to use, must be defined in the docker file" },
        "username": { "type": "string", "description": "authenticates with this username" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "doumark",
    "spec": {
      "name": "Doumark",
      "description": "Drone plugin for Douban(https://douban.com) movie/book/music marked data sync automatically.\n",
      "step": {
        "type": "script",
        "spec": {
          "image": "lizheming/drone-doumark",
          "envs": {
            "PLUGIN_DIR": "<+ inputs.dir >",
            "PLUGIN_FORMAT": "<+ inputs.format >",
            "PLUGIN_ID": "<+ inputs.id >",
            "PLUGIN_NOTION_TOKEN": "<+ inputs.notion_token >",
            "PLUGIN_TYPE": "<+ inputs.type >"
          }
        }
      },
      "inputs": {
        "dir": {
          "type": "string",
          "description": "Target where douban data sync to. It's a file path for csv and json format, and a notion database id for notion format.",
          "required": true
        },
        "format": {
          "type": "string",
          "description": "Douban data store format, enum value: csv, json, notion\n",
          "default": "csv"
        },
        "id": { "type": "string", "description": "Douban ID", "required": true },
        "notion_token": { "type": "string", "description": "Notion Integration Token" },
        "type": {
          "type": "string",
          "description": "Douban data Type, enum value: movie, book, music\n",
          "default": "movie"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "download",
    "spec": {
      "name": "Download",
      "description": "Use the Download plugin to download archives required for your builds, it also integrates a secure way to inject basic authentication credentials and checking by md5 or sha256 checksums.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/download",
          "envs": {
            "PLUGIN_DESTINATION": "<+ inputs.destination >",
            "PLUGIN_MD5": "<+ inputs.md5 >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_SHA256": "<+ inputs.sha256 >",
            "PLUGIN_SKIP_VERIFY": "<+ inputs.skip_verify >",
            "PLUGIN_SOURCE": "<+ inputs.source >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "destination": { "type": "string", "description": "The destination path for the download." },
        "md5": { "type": "string", "description": "The md5 checksum." },
        "password": { "type": "string", "description": "The password for basic auth." },
        "sha256": { "type": "string", "description": "The sha256 checksum." },
        "skip_verify": { "type": "boolean", "description": "Skip SSL verification.", "default": "false" },
        "source": { "type": "string", "description": "The source URL for the download.", "required": true },
        "username": { "type": "string", "description": "The username for basic auth." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "downstream",
    "spec": {
      "name": "Downstream Build",
      "description": "Use this plugin to trigger builds for a list of downstream repositories. This",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/downstream",
          "envs": {
            "PLUGIN_DEPLOY": "<+ inputs.deploy >",
            "PLUGIN_LAST_SUCCESSFUL": "<+ inputs.last_successful >",
            "PLUGIN_PARAMS": "<+ inputs.params >",
            "PLUGIN_REPOSITORIES": "<+ inputs.repositories >",
            "PLUGIN_SERVER": "<+ inputs.server >",
            "PLUGIN_TIMEOUT": "<+ inputs.timeout >",
            "PLUGIN_TOKEN": "<+ inputs.token >",
            "PLUGIN_WAIT": "<+ inputs.wait >"
          }
        }
      },
      "inputs": {
        "deploy": {
          "type": "string",
          "description": "Trigger a deployment (promote build), value is the environment/target for the new build."
        },
        "last_successful": {
          "type": "boolean",
          "description": "Trigger the last successful build for the branch specified in repositories.",
          "default": "false"
        },
        "params": {
          "type": "array",
          "description": "supports params in KEY=value format as well as loading of params from godotenv files.",
          "default": "[]"
        },
        "repositories": {
          "type": "array",
          "description": "trigger builds for the repository list, you can mention branch using @.",
          "default": "[]",
          "required": true
        },
        "server": { "type": "string", "description": "drone server url.", "required": true },
        "timeout": {
          "type": "number",
          "description": "how long to wait on any currently running builds.",
          "default": "60"
        },
        "token": { "type": "string", "description": "drone server auth token.", "required": true },
        "wait": {
          "type": "boolean",
          "description": "wait for any currently running builds to finish if true, else fails.",
          "default": "false"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "dron8s",
    "spec": {
      "name": "Dron8s",
      "description": "Yet another Kubernetes plugin for Drone using dynamic Server Side Apply to achieve `kubectl apply -f multi-configs.yaml` parity for your CI-CD pipelines.",
      "step": {
        "type": "script",
        "spec": {
          "image": "bh90210/dron8s",
          "envs": { "PLUGIN_KUBECONFIG": "<+ inputs.kubeconfig >", "PLUGIN_YAML": "<+ inputs.yaml >" }
        }
      },
      "inputs": {
        "kubeconfig": {
          "type": "string",
          "description": "Needed for out-of-cluster use. If not present plugin will default to in-cluster configuration. You can find kubeconfig under ~/.kube/config"
        },
        "yaml": { "type": "string", "description": "Yaml containing configs", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "ecr",
    "spec": {
      "name": "AWS ECR",
      "description": "The ECR plugin can be used to build and publish images to the Amazon ECR registry.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/ecr",
          "envs": {
            "PLUGIN_ACCESS_KEY": "<+ inputs.access_key >",
            "PLUGIN_AUTH": "<+ inputs.auth >",
            "PLUGIN_BIP": "<+ inputs.bip >",
            "PLUGIN_BUILD_ARGS": "<+ inputs.build_args >",
            "PLUGIN_CONTEXT": "<+ inputs.context >",
            "PLUGIN_CREATE_REPOSITORY": "<+ inputs.create_repository >",
            "PLUGIN_CUSTOM_DNS": "<+ inputs.custom_dns >",
            "PLUGIN_DOCKERFILE": "<+ inputs.dockerfile >",
            "PLUGIN_FORCE_TAG": "<+ inputs.force_tag >",
            "PLUGIN_INSECURE": "<+ inputs.insecure >",
            "PLUGIN_LIFECYCLE_POLICY": "<+ inputs.lifecycle_policy >",
            "PLUGIN_MIRROR": "<+ inputs.mirror >",
            "PLUGIN_REGION": "<+ inputs.region >",
            "PLUGIN_REPO": "<+ inputs.repo >",
            "PLUGIN_REPOSITORY_POLICY": "<+ inputs.repository_policy >",
            "PLUGIN_SCAN_ON_PUSH": "<+ inputs.scan_on_push >",
            "PLUGIN_SECRET_KEY": "<+ inputs.secret_key >",
            "PLUGIN_STORAGE_DRIVER": "<+ inputs.storage_driver >",
            "PLUGIN_TAGS": "<+ inputs.tags >"
          }
        }
      },
      "inputs": {
        "access_key": { "type": "string", "description": "AWS access key.", "required": true },
        "auth": { "type": "string", "description": "auth token for the registry." },
        "bip": { "type": "boolean", "description": "use for pass bridge ip.", "default": "false" },
        "build_args": { "type": "array", "description": "custom arguments passed to docker build.", "default": "[]" },
        "context": {
          "type": "string",
          "description": "context directory for the dockerfile.",
          "default": "rot of the git repo"
        },
        "create_repository": {
          "type": "boolean",
          "description": "Create repository if it does not exist.",
          "default": "false"
        },
        "custom_dns": { "type": "string", "description": "set custom dns servers for the container." },
        "dockerfile": { "type": "string", "description": "filename of dockerfile.", "default": "Dockerfile" },
        "force_tag": { "type": "boolean", "description": "replace existing matched image tags.", "default": "false" },
        "insecure": {
          "type": "boolean",
          "description": "enable insecure communication to this registry.",
          "default": "false"
        },
        "lifecycle_policy": { "type": "string", "description": "filename of ecr lifecycle json policy." },
        "mirror": {
          "type": "string",
          "description": "use a mirror registry instead of pulling images directly from the central Hub."
        },
        "region": { "type": "string", "description": "AWS region.", "default": "us-east-1" },
        "repo": { "type": "string", "description": "repository name for the image.", "required": true },
        "repository_policy": { "type": "string", "description": "filename of ecr repository json policy." },
        "scan_on_push": {
          "type": "boolean",
          "description": "boolean of whether to enable automatic ECR images vulnerabilities scanning for repository if it was created with create_repository=true.",
          "default": "false"
        },
        "secret_key": { "type": "string", "description": "AWS secret key.", "required": true },
        "storage_driver": { "type": "string", "description": "supports aufs, overlay or vfs drivers." },
        "tags": {
          "type": "array",
          "description": "repository tag for the image, defaults to latest.",
          "default": "latest"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "ecs-deploy",
    "spec": {
      "name": "AWS ECS Deploy",
      "description": "This plugin allows updating an ECS service. The plugin is a wrapper for ecs-deploy, this bash works by taking the current task definition of a service and just changing the image so that all the configuration stays the same.",
      "step": {
        "type": "script",
        "spec": {
          "image": "joshdvir/drone-ecs-deploy",
          "envs": {
            "PLUGIN_AWS_ACCESS_KEY_ID": "<+ inputs.aws_access_key_id >",
            "PLUGIN_AWS_REGION": "<+ inputs.aws_region >",
            "PLUGIN_AWS_SECRET_ACCESS_KEY": "<+ inputs.aws_secret_access_key >",
            "PLUGIN_CLUSTER": "<+ inputs.cluster >",
            "PLUGIN_IMAGE_NAME": "<+ inputs.image_name >",
            "PLUGIN_MAX": "<+ inputs.max >",
            "PLUGIN_MIN": "<+ inputs.min >",
            "PLUGIN_SERVICE": "<+ inputs.service >",
            "PLUGIN_TIMEOUT": "<+ inputs.timeout >"
          }
        }
      },
      "inputs": {
        "aws_access_key_id": { "type": "string", "description": "AWS access key." },
        "aws_region": { "type": "string", "description": "AWS region.", "default": "us-east-1" },
        "aws_secret_access_key": { "type": "string", "description": "AWS secret key." },
        "cluster": { "type": "string", "description": "ECS cluster." },
        "image_name": { "type": "string", "description": "Name of Docker image to run, e.g. repo/image:latest." },
        "max": {
          "type": "number",
          "description": "The upper limit on the number of running tasks during a deployment.",
          "default": "200"
        },
        "min": {
          "type": "number",
          "description": "The lower limit on the number of running tasks during a deployment.",
          "default": "100"
        },
        "service": { "type": "string", "description": "Name of service to deploy." },
        "timeout": {
          "type": "number",
          "description": "Script monitors ECS Service for new task definition to be running.",
          "default": "300"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "ecs",
    "spec": {
      "name": "AWS ECS",
      "description": "The ECS plugin can be used to deploy a Docker image to an ECS environment.",
      "step": {
        "type": "script",
        "spec": {
          "image": "pelotech/drone-ecs",
          "envs": {
            "PLUGIN_ACCESS_KEY": "<+ inputs.access_key >",
            "PLUGIN_ENVIRONMENT_VARIABLES": "<+ inputs.environment_variables >",
            "PLUGIN_FAMILY": "<+ inputs.family >",
            "PLUGIN_IMAGE_NAME": "<+ inputs.image_name >",
            "PLUGIN_IMAGE_TAG": "<+ inputs.image_tag >",
            "PLUGIN_MEMORY": "<+ inputs.memory >",
            "PLUGIN_PORT_MAPPINGS": "<+ inputs.port_mappings >",
            "PLUGIN_REGION": "<+ inputs.region >",
            "PLUGIN_SECRET_KEY": "<+ inputs.secret_key >",
            "PLUGIN_SERVICE": "<+ inputs.service >"
          }
        }
      },
      "inputs": {
        "access_key": { "type": "string", "description": "AWS access key." },
        "environment_variables": {
          "type": "array",
          "description": "list of environment variables to pass to ecs.",
          "default": "[]"
        },
        "family": { "type": "string", "description": "ECS task." },
        "image_name": { "type": "string", "description": "docker image to use." },
        "image_tag": { "type": "string", "description": "docker image tag to use." },
        "memory": { "type": "number", "description": "memory to assign to the service." },
        "port_mappings": { "type": "array", "description": "list of port mappings to pass to ecs.", "default": "[]" },
        "region": { "type": "string", "description": "AWS region." },
        "secret_key": { "type": "string", "description": "AWS secret key." },
        "service": { "type": "string", "description": "ecs service on that environment to upgrade." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "elastic-beanstalk",
    "spec": {
      "name": "AWS Elastic Beanstalk",
      "description": "The Elastic Beanstalk plugin can be used to deploy an app to a Beanstalk environment.",
      "step": {
        "type": "script",
        "spec": {
          "image": "pelotech/drone-elastic-beanstalk",
          "envs": {
            "PLUGIN_ACCESS_KEY": "<+ inputs.access_key >",
            "PLUGIN_AUTO_CREATE": "<+ inputs.auto_create >",
            "PLUGIN_BUCKET_KEY": "<+ inputs.bucket_key >",
            "PLUGIN_BUCKET_NAME": "<+ inputs.bucket_name >",
            "PLUGIN_DESCRIPTION": "<+ inputs.description >",
            "PLUGIN_ENVIRONMENT_NAME": "<+ inputs.environment_name >",
            "PLUGIN_ENVIRONMENT_UPDATE": "<+ inputs.environment_update >",
            "PLUGIN_PROCESS": "<+ inputs.process >",
            "PLUGIN_REGION": "<+ inputs.region >",
            "PLUGIN_SECRET_KEY": "<+ inputs.secret_key >",
            "PLUGIN_VERSION_LABEL": "<+ inputs.version_label >"
          }
        }
      },
      "inputs": {
        "access_key": { "type": "string", "description": "AWS access key." },
        "auto_create": {
          "type": "boolean",
          "description": "Automatically create the application.",
          "default": "false"
        },
        "bucket_key": { "type": "string", "description": "Key for S3 source bundle." },
        "bucket_name": { "type": "string", "description": "Bucket for S3 source bundle." },
        "description": { "type": "string", "description": "A description about the deployment." },
        "environment_name": { "type": "string", "description": "Environment Name, if environment_update true." },
        "environment_update": {
          "type": "boolean",
          "description": "Flag whether to update ElasticBeansTalk environment with the new version.",
          "default": "false"
        },
        "process": { "type": "boolean", "description": "Preprocess and validate the manifest.", "default": "false" },
        "region": { "type": "string", "description": "AWS region." },
        "secret_key": { "type": "string", "description": "AWS secret key." },
        "version_label": { "type": "string", "description": "label to identify this version." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "email",
    "spec": {
      "name": "Email",
      "description": "The email plugin can be used to notify people of a build result.",
      "step": {
        "type": "script",
        "spec": {
          "image": "drillster/drone-email",
          "envs": {
            "PLUGIN_ATTACHMENT": "<+ inputs.attachment >",
            "PLUGIN_BODY": "<+ inputs.body >",
            "PLUGIN_FROM": "<+ inputs.from >",
            "PLUGIN_HOST": "<+ inputs.host >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PORT": "<+ inputs.port >",
            "PLUGIN_RECIPIENTS": "<+ inputs.recipients >",
            "PLUGIN_RECIPIENTS_FILE": "<+ inputs.recipients_file >",
            "PLUGIN_RECIPIENTS_ONLY": "<+ inputs.recipients_only >",
            "PLUGIN_SKIP_VERIFY": "<+ inputs.skip_verify >",
            "PLUGIN_SUBJECT": "<+ inputs.subject >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "attachment": {
          "type": "string",
          "description": "An optional file to attach to the sent mail(s). This can be an absolute path or a path relative to the working directory."
        },
        "body": {
          "type": "string",
          "description": "The email body template (handlebars template). This can be an inline template, or a URL (file:/// allowed)"
        },
        "from": { "type": "string", "description": "The email address to send the notification from." },
        "host": { "type": "string", "description": "SMTP server host." },
        "password": { "type": "string", "description": "SMTP server password." },
        "port": { "type": "number", "description": "SMTP server port.", "default": "587" },
        "recipients": {
          "type": "array",
          "description": "List of recipients to send this mail to (besides the commit author).",
          "default": "[]"
        },
        "recipients_file": {
          "type": "string",
          "description": "File containing a list of recipients to send this mail to (besides the commit author)."
        },
        "recipients_only": {
          "type": "boolean",
          "description": "Do not send mails to the commit author, but only to recipients.",
          "default": "false"
        },
        "skip_verify": { "type": "boolean", "description": "Skip cert verification.", "default": "false" },
        "subject": { "type": "string", "description": "The subject line template (handlebars template)." },
        "username": { "type": "string", "description": "SMTP server username." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "facebook",
    "spec": {
      "name": "Facebook",
      "description": "The Facebook plugin posts build status messages to your account.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-facebook",
          "envs": {
            "PLUGIN_APP_SECRET": "<+ inputs.app_secret >",
            "PLUGIN_AUDIOS": "<+ inputs.audios >",
            "PLUGIN_FB_PAGE_TOKEN": "<+ inputs.fb_page_token >",
            "PLUGIN_FB_VERIFY_TOKEN": "<+ inputs.fb_verify_token >",
            "PLUGIN_FILES": "<+ inputs.files >",
            "PLUGIN_IMAGES": "<+ inputs.images >",
            "PLUGIN_MESSAGE": "<+ inputs.message >",
            "PLUGIN_TO": "<+ inputs.to >",
            "PLUGIN_VIDEOS": "<+ inputs.videos >"
          }
        }
      },
      "inputs": {
        "app_secret": { "type": "string", "description": "Facebook App Secret." },
        "audios": { "type": "array", "description": "a valid URL to an audio message.", "default": "[]" },
        "fb_page_token": { "type": "string", "description": "Facebook Page Token." },
        "fb_verify_token": { "type": "string", "description": "Facebook Verify Token." },
        "files": { "type": "array", "description": "a valid URL to a file message.", "default": "[]" },
        "images": { "type": "array", "description": "a valid URL to an image message.", "default": "[]" },
        "message": { "type": "string", "description": "overwrite the default message template." },
        "to": { "type": "string", "description": "Facebook User ID." },
        "videos": { "type": "array", "description": "a valid URL to a video message.", "default": "[]" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "fandogh",
    "spec": {
      "name": "Fandogh",
      "description": "This plugin can help you to easy delivery your new docker images to fandogh PaaS.",
      "step": {
        "type": "script",
        "spec": {
          "image": "amirbagh75/fandogh-drone",
          "envs": {
            "PLUGIN_MANIFEST_PATH": "<+ inputs.manifest_path >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_REGISTRY": "<+ inputs.registry >",
            "PLUGIN_USERNAME": "<+ inputs.username >",
            "PLUGIN_VERSION": "<+ inputs.version >"
          }
        }
      },
      "inputs": {
        "manifest_path": { "type": "string", "description": "manifest path." },
        "password": { "type": "string", "description": "Fandogh password." },
        "registry": { "type": "string", "description": "registry url." },
        "username": { "type": "string", "description": "Fandogh username." },
        "version": { "type": "string", "description": "version id." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "ftps",
    "spec": {
      "name": "FTP(S)",
      "description": "The FTPS plugin can be used to publish artifacts over FTP(S).",
      "step": {
        "type": "script",
        "spec": {
          "image": "cschlosser/drone-ftps",
          "envs": {
            "PLUGIN_CHMOD": "<+ inputs.chmod >",
            "PLUGIN_CLEAN_DIR": "<+ inputs.clean_dir >",
            "PLUGIN_DEST_DIR": "<+ inputs.dest_dir >",
            "PLUGIN_EXCLUDE": "<+ inputs.exclude >",
            "PLUGIN_HOSTNAME": "<+ inputs.hostname >",
            "PLUGIN_INCLUDE": "<+ inputs.include >",
            "PLUGIN_SECRETS": "<+ inputs.secrets >",
            "PLUGIN_SECURE": "<+ inputs.secure >",
            "PLUGIN_SRC_DIR": "<+ inputs.src_dir >",
            "PLUGIN_VERIFY": "<+ inputs.verify >"
          }
        }
      },
      "inputs": {
        "chmod": {
          "type": "boolean",
          "description": "if set to true chmod would be executed after file transferred, otherwise no chmod.",
          "default": "true"
        },
        "clean_dir": { "type": "boolean", "description": "Clean the directory before uploading.", "default": "false" },
        "dest_dir": { "type": "string", "description": "where to put the files on the remote server.", "default": "/" },
        "exclude": { "type": "string", "description": "egrep like pattern matching to exclude files from uploading." },
        "hostname": { "type": "string", "description": "FTP host including port." },
        "include": { "type": "string", "description": "egrep like pattern matching to include files for uploading." },
        "secrets": { "type": "array", "description": "FTP_PASSWORD and FTP_USERNAME.", "default": "[]" },
        "secure": {
          "type": "boolean",
          "description": "if set to true FTPS is enforced, otherwise plain FTP is used.",
          "default": "true"
        },
        "src_dir": {
          "type": "string",
          "description": "which local directory should be used for the upload.",
          "default": "./"
        },
        "verify": {
          "type": "boolean",
          "description": "if set to true the SSL certificate validation is enforced, otherwise no validation.",
          "default": "true"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gcf",
    "spec": {
      "name": "Google Cloud Functions",
      "description": "The GCF plugin can be used to deploy, list, and delete Google Cloud Functions.",
      "step": {
        "type": "script",
        "spec": {
          "image": "oliver006/drone-gcf",
          "envs": {
            "PLUGIN_ACTION": "<+ inputs.action >",
            "PLUGIN_FUNCTIONS": "<+ inputs.functions >",
            "PLUGIN_PROJECT": "<+ inputs.project >",
            "PLUGIN_RUNTIME": "<+ inputs.runtime >",
            "PLUGIN_TOKEN": "<+ inputs.token >"
          }
        }
      },
      "inputs": {
        "action": { "type": "string", "description": "can be either deploy, delete, or list." },
        "functions": {
          "type": "array",
          "description": "list of functions to be deployed, each needs to at least provide a trigger but can also set memory, runtime, and source.",
          "default": "[]"
        },
        "project": {
          "type": "string",
          "description": "name of the GCP project.",
          "default": "the project of the service account"
        },
        "runtime": {
          "type": "string",
          "description": "runtime of the functions to be deployed. Can be specified once or one a per function basis."
        },
        "token": {
          "type": "string",
          "description": "json credentials of the service account to access Google Cloud Functions."
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gcr",
    "spec": {
      "name": "Google Container Registry",
      "description": "The GCR plugin can be used to build and publish images to the Google Container Registry.\n",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/gcr",
          "envs": {
            "PLUGIN_JSON_KEY": "<+ inputs.json_key >",
            "PLUGIN_REGISTRY": "<+ inputs.registry >",
            "PLUGIN_REPO": "<+ inputs.repo >",
            "PLUGIN_WORKLOAD_IDENTITY": "<+ inputs.workload_identity >"
          }
        }
      },
      "inputs": {
        "json_key": { "type": "string", "description": "json key - can be inline or base64 encoded", "required": true },
        "registry": { "type": "string", "description": "authenticates to this registry", "default": "gcr.io" },
        "repo": { "type": "string", "description": "repository name for the image" },
        "workload_identity": {
          "type": "boolean",
          "description": "flag if key is a workload identity key",
          "default": "false"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gcs-2",
    "spec": {
      "name": "Google Cloud Storage",
      "description": "The Google Cloud Storage plugin uploads files and build artifacts to your Google Cloud Storage bucket.",
      "step": {
        "type": "script",
        "spec": {
          "image": "wyattjoh/drone-gcs",
          "envs": {
            "PLUGIN_ACL": "<+ inputs.acl >",
            "PLUGIN_BUCKET": "<+ inputs.bucket >",
            "PLUGIN_COMPRESS": "<+ inputs.compress >",
            "PLUGIN_EXCLUDE": "<+ inputs.exclude >",
            "PLUGIN_SOURCE": "<+ inputs.source >",
            "PLUGIN_STRIP_PREFIX": "<+ inputs.strip_prefix >",
            "PLUGIN_TARGET": "<+ inputs.target >"
          }
        }
      },
      "inputs": {
        "acl": { "type": "string", "description": "access to files that are uploaded (private, public)" },
        "bucket": { "type": "string", "description": "bucket name", "required": true },
        "compress": {
          "type": "boolean",
          "description": "gzip files before they are uploaded and add a Content-Encoding gzip",
          "default": "false"
        },
        "exclude": { "type": "string", "description": "glob exclusion patterns" },
        "source": {
          "type": "string",
          "description": "source location of the files, using a glob matching pattern",
          "required": true
        },
        "strip_prefix": { "type": "boolean", "description": "strip the prefix from source path", "default": "false" },
        "target": { "type": "string", "description": "target location of files in the bucket", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gcs-cache",
    "spec": {
      "name": "Google Cloud Storage Cache",
      "description": "The GCS cache plugin can be used to preserve files and directories between builds.",
      "step": {
        "type": "script",
        "spec": {
          "image": "homerovalle/drone-gcs-cache",
          "envs": {
            "PLUGIN_BUCKET": "<+ inputs.bucket >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_FALLBACK_PATH": "<+ inputs.fallback_path >",
            "PLUGIN_FILENAME": "<+ inputs.filename >",
            "PLUGIN_FLUSH": "<+ inputs.flush >",
            "PLUGIN_FLUSH_AGE": "<+ inputs.flush_age >",
            "PLUGIN_FLUSH_PATH": "<+ inputs.flush_path >",
            "PLUGIN_JSON_KEY": "<+ inputs.json_key >",
            "PLUGIN_MOUNT": "<+ inputs.mount >",
            "PLUGIN_PATH": "<+ inputs.path >",
            "PLUGIN_REBUILD": "<+ inputs.rebuild >",
            "PLUGIN_RESTORE": "<+ inputs.restore >"
          }
        }
      },
      "inputs": {
        "bucket": { "type": "string", "description": "bucket to use to rebuild and restore cache.", "required": true },
        "debug": { "type": "boolean", "description": "enabling more logging for debugging.", "default": "false" },
        "fallback_path": {
          "type": "string",
          "description": "fallback path for the cache file.",
          "default": "[bucket]/<owner>/<repo>/<branch>/",
          "required": true
        },
        "filename": { "type": "string", "description": "filename to use for cache." },
        "flush": {
          "type": "boolean",
          "description": "mode to flush the cache of old cache items (please be sure to set this so we don't waste storage).",
          "default": "false"
        },
        "flush_age": { "type": "number", "description": "flush cache files older then x days.", "default": "30" },
        "flush_path": {
          "type": "string",
          "description": "path to search for flushable cache files.",
          "default": "[bucket]/<owner>/<repo>/",
          "required": true
        },
        "json_key": { "type": "string", "description": "service account json key.", "required": true },
        "mount": { "type": "array", "description": "list of files/directories to cache.", "default": "[]" },
        "path": {
          "type": "string",
          "description": "path to store the cache file.",
          "default": "[bucket]/<owner>/<repo>/<branch>/",
          "required": true
        },
        "rebuild": {
          "type": "boolean",
          "description": "mode to rebuild the cache from the build environment and specified mounts.",
          "default": "false"
        },
        "restore": {
          "type": "boolean",
          "description": "mode to restore the build environment from cache.",
          "default": "false"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gcs",
    "spec": {
      "name": "Google Cloud Storage",
      "description": "The GCS plugin can be used to publish files and artifacts to Google Cloud Storage.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/gcs",
          "envs": {
            "PLUGIN_ACL": "<+ inputs.acl >",
            "PLUGIN_CACHE_CONTROL": "<+ inputs.cache_control >",
            "PLUGIN_GZIP": "<+ inputs.gzip >",
            "PLUGIN_IGNORE": "<+ inputs.ignore >",
            "PLUGIN_METADATA": "<+ inputs.metadata >",
            "PLUGIN_SOURCE": "<+ inputs.source >",
            "PLUGIN_TARGET": "<+ inputs.target >",
            "PLUGIN_TOKEN": "<+ inputs.token >"
          }
        }
      },
      "inputs": {
        "acl": {
          "type": "array",
          "description": "a list of access rules applied to the uploaded files, in a form of entity:role",
          "default": "[]"
        },
        "cache_control": { "type": "string", "description": "Cache-Control header" },
        "gzip": {
          "type": "string",
          "description": "files with the specified extensions will be gzipped and uploaded with \"gzip\" Content-Encoding header e.g. js,css,html"
        },
        "ignore": { "type": "string", "description": "skip files matching this pattern, relative to source" },
        "metadata": {
          "type": "string",
          "description": "an arbitrary dictionary with custom metadata applied to all objects"
        },
        "source": { "type": "string", "description": "location of files to upload", "required": true },
        "target": {
          "type": "string",
          "description": "destination to copy files to, including bucket name",
          "required": true
        },
        "token": { "type": "string", "description": "credentials to access Google Cloud Storage", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gh-pages",
    "spec": {
      "name": "GitHub Pages",
      "description": "The GitHub Pages plugin is used to publish static websites to GitHub. The following configuration uses the gh-pages plugin to publish a website.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/gh-pages",
          "envs": {
            "PLUGIN_PAGES_DIRECTORY": "<+ inputs.pages_directory >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_SSH_KEY": "<+ inputs.ssh_key >",
            "PLUGIN_TARGET_BRANCH": "<+ inputs.target_branch >",
            "PLUGIN_TEMPORARY_BASE": "<+ inputs.temporary_base >",
            "PLUGIN_UPSTREAM_NAME": "<+ inputs.upstream_name >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "pages_directory": {
          "type": "string",
          "description": "The directory of content to publish",
          "default": "docs",
          "required": true
        },
        "password": { "type": "string", "description": "GitHub password for pushing changes", "required": true },
        "ssh_key": { "type": "string", "description": "SSH key to use for pushing changes" },
        "target_branch": { "type": "string", "description": "GitHub target branch", "default": "gh-pages" },
        "temporary_base": {
          "type": "string",
          "description": "Temporary directory to pull gh-pages branch",
          "default": ".tmp"
        },
        "upstream_name": { "type": "string", "description": "GitHub upstream target", "default": "origin" },
        "username": { "type": "string", "description": "GitHub username for pushing changes", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "git-push",
    "spec": {
      "name": "Git Push",
      "description": "Use this plugin for deploying an application via `git push`. You will need to supply Drone with a private SSH key or use the same credentials as the cloned repo to being able to push changes.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-git-push",
          "envs": {
            "PLUGIN_AUTHOR_EMAIL": "<+ inputs.author_email >",
            "PLUGIN_AUTHOR_NAME": "<+ inputs.author_name >",
            "PLUGIN_BRANCH": "<+ inputs.branch >",
            "PLUGIN_COMMIT": "<+ inputs.commit >",
            "PLUGIN_COMMIT_MESSAGE": "<+ inputs.commit_message >",
            "PLUGIN_EMPTY_COMMIT": "<+ inputs.empty_commit >",
            "PLUGIN_FOLLOWTAGS": "<+ inputs.followtags >",
            "PLUGIN_FORCE": "<+ inputs.force >",
            "PLUGIN_LOCAL_BRANCH": "<+ inputs.local_branch >",
            "PLUGIN_PATH": "<+ inputs.path >",
            "PLUGIN_REMOTE": "<+ inputs.remote >",
            "PLUGIN_REMOTE_NAME": "<+ inputs.remote_name >",
            "PLUGIN_SKIP_VERIFY": "<+ inputs.skip_verify >",
            "PLUGIN_SSH_KEY": "<+ inputs.ssh_key >"
          }
        }
      },
      "inputs": {
        "author_email": { "type": "string", "description": "author email for commit.", "default": "commiter email" },
        "author_name": { "type": "string", "description": "author name for commit.", "default": "commiter name" },
        "branch": { "type": "string", "description": "target branch to push to.", "default": "master" },
        "commit": {
          "type": "boolean",
          "description": "add and commit the contents of the repo before pushing.",
          "default": "false"
        },
        "commit_message": {
          "type": "string",
          "description": "add a custom message for commit.",
          "default": "[skip ci] Commit dirty state"
        },
        "empty_commit": {
          "type": "boolean",
          "description": "create an empty commit if there are no changes.",
          "default": "false"
        },
        "followtags": { "type": "boolean", "description": "push with --follow-tags option.", "default": "false" },
        "force": { "type": "boolean", "description": "force push using the --force flag.", "default": "false" },
        "local_branch": { "type": "string", "description": "local branch or ref to push from.", "default": "HEAD" },
        "path": { "type": "string", "description": "path to the repository.", "default": "current repo" },
        "remote": {
          "type": "string",
          "description": "target remote repository (if blank, assume exists).",
          "required": true
        },
        "remote_name": { "type": "string", "description": "name of the remote to use locally.", "default": "deploy" },
        "skip_verify": { "type": "boolean", "description": "skip verification of HTTPS certs.", "default": "false" },
        "ssh_key": { "type": "string", "description": "Private SSH key for the remote machine." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "git",
    "spec": {
      "name": "Git",
      "description": "The git plugin is used to clone a git repository. Note that Drone uses the git plugin by default for all repositories, without any configuration required.",
      "step": {
        "type": "script",
        "spec": {
          "image": "drone/git",
          "envs": {
            "PLUGIN_DEPTH": "<+ inputs.depth >",
            "PLUGIN_RECURSIVE": "<+ inputs.recursive >",
            "PLUGIN_SKIP_VERIFY": "<+ inputs.skip_verify >",
            "PLUGIN_SUBMODULE_OVERRIDES": "<+ inputs.submodule_overrides >",
            "PLUGIN_SUBMODULE_UPDATE_REMOTE": "<+ inputs.submodule_update_remote >",
            "PLUGIN_TAGS": "<+ inputs.tags >"
          }
        }
      },
      "inputs": {
        "depth": { "type": "number", "description": "creates a shallow clone with truncated history." },
        "recursive": { "type": "boolean", "description": "clones submodules recursively.", "default": "false" },
        "skip_verify": { "type": "boolean", "description": "skips the SSL verification.", "default": "false" },
        "submodule_overrides": { "type": "object", "description": "override submodule urls." },
        "submodule_update_remote": {
          "type": "boolean",
          "description": "pass the --remote flag to git submodule update.",
          "default": "false"
        },
        "tags": { "type": "boolean", "description": "fetches tags when set to true.", "default": "false" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gitea-comment",
    "spec": {
      "name": "Gitea Comment",
      "description": "Use this plugin to update build status on Gitea Pull Request. This is useful when the complete team does not want to open drone dashboard for each build message.",
      "step": {
        "type": "script",
        "spec": {
          "image": "tsakidev/giteacomment",
          "envs": {
            "PLUGIN_COMMENT": "<+ inputs.comment >",
            "PLUGIN_COMMENT_FROM_FILE": "<+ inputs.comment_from_file >",
            "PLUGIN_COMMENT_TITLE": "<+ inputs.comment_title >",
            "PLUGIN_GITEA_BASE_URL": "<+ inputs.gitea_base_url >",
            "PLUGIN_GITEA_TOKEN": "<+ inputs.gitea_token >"
          }
        }
      },
      "inputs": {
        "comment": {
          "type": "string",
          "description": "the content of the comment (required if comment_from_file is not used)"
        },
        "comment_from_file": {
          "type": "string",
          "description": "the file path to read from (required if comment is not used)"
        },
        "comment_title": { "type": "string", "description": "the title of the comment" },
        "gitea_base_url": { "type": "string", "description": "the url of the gitea installation", "required": true },
        "gitea_token": { "type": "string", "description": "gitea server auth token", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gitea-release",
    "spec": {
      "name": "Gitea Release",
      "description": "The gitea-release plugin is used to publish files and artifacts to Gitea Release.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/gitea-release",
          "envs": {
            "PLUGIN_API_KEY": "<+ inputs.api_key >",
            "PLUGIN_BASE_URL": "<+ inputs.base_url >",
            "PLUGIN_CHECKSUM": "<+ inputs.checksum >",
            "PLUGIN_DRAFT": "<+ inputs.draft >",
            "PLUGIN_FILES": "<+ inputs.files >",
            "PLUGIN_FILE_EXISTS": "<+ inputs.file_exists >",
            "PLUGIN_INSECURE": "<+ inputs.insecure >",
            "PLUGIN_NOTE": "<+ inputs.note >",
            "PLUGIN_PRERELEASE": "<+ inputs.prerelease >",
            "PLUGIN_TITLE": "<+ inputs.title >"
          }
        }
      },
      "inputs": {
        "api_key": { "type": "string", "description": "Gitea API key", "required": true },
        "base_url": { "type": "string", "description": "Gitea base URL", "required": true },
        "checksum": {
          "type": "string",
          "description": "checksum takes hash methods to include in your Gitea release for the files specified. Supported hash methods include - md5, sha1, sha256, sha512, adler32, and crc32."
        },
        "draft": { "type": "boolean", "description": "draft release", "default": "false" },
        "file_exists": {
          "type": "string",
          "description": "what to do if an file asset already exists, supported values - overwrite, skip and fail.",
          "default": "overwrite"
        },
        "files": {
          "type": "array",
          "description": "files to upload to Gitea Release, globs are allowed.",
          "required": true
        },
        "insecure": {
          "type": "boolean",
          "description": "visit base_url via insecure https protocol",
          "default": "false"
        },
        "note": { "type": "string", "description": "file or string with notes for the release" },
        "prerelease": { "type": "boolean", "description": "prerelease release", "default": "false" },
        "title": { "type": "string", "description": "file or string for the title shown in the gitea release" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gitee-pulls",
    "spec": {
      "name": "Gitee Pulls",
      "description": "This plugin can automatically update the comments / labels / test in PR to gitee.",
      "step": {
        "type": "script",
        "spec": {
          "image": "kit101z/drone-plugin-gitee-pulls",
          "envs": {
            "PLUGIN_ACCESS_TOKEN": "<+ inputs.access_token >",
            "PLUGIN_API_SERVER": "<+ inputs.api_server >",
            "PLUGIN_COMMENT_DISABLED": "<+ inputs.comment_disabled >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_FAILURE_LABEL": "<+ inputs.failure_label >",
            "PLUGIN_IS_RUNNING": "<+ inputs.is_running >",
            "PLUGIN_LABEL_DISABLED": "<+ inputs.label_disabled >",
            "PLUGIN_RUNNING_LABEL": "<+ inputs.running_label >",
            "PLUGIN_SUCCESS_LABEL": "<+ inputs.success_label >",
            "PLUGIN_TEST_DISABLED": "<+ inputs.test_disabled >"
          }
        }
      },
      "inputs": {
        "access_token": {
          "type": "string",
          "description": "gitee access token, you can generate personal access token",
          "required": true
        },
        "api_server": {
          "type": "string",
          "description": "the gitee api server url",
          "default": "https://gitee.com/api/v5"
        },
        "comment_disabled": {
          "type": "boolean",
          "description": "disable automatic updating of the comment with build status",
          "default": "false"
        },
        "debug": { "type": "boolean", "description": "enable debug mode", "default": "false" },
        "failure_label": {
          "type": "string",
          "description": "set the name and color of the failure label",
          "default": "drone-build/failure,DB2828"
        },
        "is_running": { "type": "boolean", "description": "is the build running", "default": "false" },
        "label_disabled": {
          "type": "boolean",
          "description": "disable automatic updating of the label with build status",
          "default": "false"
        },
        "running_label": {
          "type": "string",
          "description": "set the name and color of the running label",
          "default": "drone-build/running,E6A23C"
        },
        "success_label": {
          "type": "string",
          "description": "set the name and color of the success label",
          "default": "drone-build/success,67C23A"
        },
        "test_disabled": {
          "type": "boolean",
          "description": "disable automatic updating of the test status",
          "default": "false"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "github-app",
    "spec": {
      "name": "Github App",
      "description": "A plugin to get a jwt or installation token for a github app.\n",
      "step": {
        "type": "script",
        "spec": {
          "image": "rssnyder/drone-github-app",
          "envs": {
            "PLUGIN_APP_ID": "<+ inputs.app_id >",
            "PLUGIN_INSTALLATION": "<+ inputs.installation >",
            "PLUGIN_JSON_FILE": "<+ inputs.json_file >",
            "PLUGIN_JWT_FILE": "<+ inputs.jwt_file >",
            "PLUGIN_PEM": "<+ inputs.pem >",
            "PLUGIN_PEM_B64": "<+ inputs.pem_b64 >",
            "PLUGIN_PEM_FILE": "<+ inputs.pem_file >",
            "PLUGIN_TOKEN_FILE": "<+ inputs.token_file >"
          }
        }
      },
      "inputs": {
        "app_id": { "type": "string", "description": "github app id", "required": true },
        "installation": { "type": "string", "description": "installation id" },
        "json_file": { "type": "string", "description": "output file for both jwt and token in json" },
        "jwt_file": { "type": "string", "description": "output file for jwt" },
        "pem": { "type": "string", "description": "rsa private key" },
        "pem_b64": { "type": "string", "description": "local file path of base64 encoded rsa private key" },
        "pem_file": { "type": "string", "description": "local file path of rsa private key" },
        "token_file": { "type": "string", "description": "output file for token" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "github-changelog-generator",
    "spec": {
      "name": "Github-changelog-generator",
      "description": "This plugin can be used to create a changelog file based on GitHub tags, it will not auto-push it into the repo but rather create a changelog file for you to upload into your desired location via other Drone plugins.",
      "step": {
        "type": "script",
        "spec": {
          "image": "naorlivne/drone-github-changelog-generator",
          "envs": {
            "PLUGIN_GITHUB_PROJECT": "<+ inputs.github_project >",
            "PLUGIN_GITHUB_USER": "<+ inputs.github_user >",
            "PLUGIN_OUTPUT_PATH": "<+ inputs.output_path >"
          }
        }
      },
      "inputs": {
        "github_project": { "type": "string", "description": "Github project name", "required": true },
        "github_user": { "type": "string", "description": "Github username", "required": true },
        "output_path": {
          "type": "string",
          "description": "The changelog file path to be created in the current working directory (repo root by default)",
          "default": "CHANGELOG.md",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "github-comment",
    "spec": {
      "name": "Github Comment",
      "description": "Use this plugin to update build status on Github Pull Request. This is useful when the complete team does not want to open drone dashboard for each build message.",
      "step": {
        "type": "script",
        "spec": {
          "image": "codehimanshu/gitdrone",
          "envs": {
            "PLUGIN_DRONE_ACCESS_TOKEN": "<+ inputs.drone_access_token >",
            "PLUGIN_GITHUB_APP_ID": "<+ inputs.github_app_id >",
            "PLUGIN_GITHUB_INSTALLATION_ID": "<+ inputs.github_installation_id >",
            "PLUGIN_PRIVATE_KEY": "<+ inputs.private_key >"
          }
        }
      },
      "inputs": {
        "drone_access_token": { "type": "string", "description": "drone server auth token", "required": true },
        "github_app_id": {
          "type": "string",
          "description": "your app id for drone on github",
          "default": "38899",
          "required": true
        },
        "github_installation_id": {
          "type": "string",
          "description": "installation id of github app for drone",
          "required": true
        },
        "private_key": { "type": "string", "description": "from github app installation", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "github-release",
    "spec": {
      "name": "Github Release",
      "description": "The github-release plugin is used to publish files and artifacts to GitHub Release.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/github-release",
          "envs": {
            "PLUGIN_API_KEY": "<+ inputs.api_key >",
            "PLUGIN_BASE_URL": "<+ inputs.base_url >",
            "PLUGIN_CHECKSUM": "<+ inputs.checksum >",
            "PLUGIN_DRAFT": "<+ inputs.draft >",
            "PLUGIN_FILES": "<+ inputs.files >",
            "PLUGIN_FILE_EXISTS": "<+ inputs.file_exists >",
            "PLUGIN_NOTE": "<+ inputs.note >",
            "PLUGIN_OVERWRITE": "<+ inputs.overwrite >",
            "PLUGIN_PRERELEASE": "<+ inputs.prerelease >",
            "PLUGIN_TITLE": "<+ inputs.title >",
            "PLUGIN_UPLOAD_URL": "<+ inputs.upload_url >"
          }
        }
      },
      "inputs": {
        "api_key": {
          "type": "string",
          "description": "GitHub oauth token with public_repo or repo permission. If you create your token, ensure you select the correct scope. For private repositories you have to select repo while public repositories only requires public_repo.",
          "required": true
        },
        "base_url": { "type": "string", "description": "GitHub base URL, only required for GHE" },
        "checksum": {
          "type": "string",
          "description": "checksum takes hash methods to include in your GitHub release for the files specified. Supported hash methods include - md5, sha1, sha256, sha512, adler32, and crc32."
        },
        "draft": { "type": "boolean", "description": "create a draft release", "default": "false" },
        "file_exists": {
          "type": "string",
          "description": "what to do if an file asset already exists, supported values - overwrite, skip and fail.",
          "default": "overwrite"
        },
        "files": {
          "type": "array",
          "description": "files to upload to GitHub Release, globs are allowed",
          "required": true
        },
        "note": { "type": "string", "description": "file or string with notes for the release" },
        "overwrite": {
          "type": "boolean",
          "description": "force overwrite existing release informations (only title and note)",
          "default": "false"
        },
        "prerelease": { "type": "boolean", "description": "create a pre-release", "default": "false" },
        "title": {
          "type": "string",
          "description": "file or string for the title shown in the gitea release",
          "required": true
        },
        "upload_url": { "type": "string", "description": "GitHub upload URL, only required for GHE" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "github-search-downstream",
    "spec": {
      "name": "Github Search Downstream",
      "description": "Use this plugin to trigger builds for a list of downstream repositories fetched from a Github repository search. This is useful when updates to a repository have downstream impacts that should also be tested, and those repository are searchable on Github.",
      "step": {
        "type": "script",
        "spec": {
          "image": "gboo/github-search-downstream",
          "envs": {
            "PLUGIN_DRONE_SERVER": "<+ inputs.drone_server >",
            "PLUGIN_DRONE_TOKEN": "<+ inputs.drone_token >",
            "PLUGIN_GITHUB_QUERY": "<+ inputs.github_query >",
            "PLUGIN_GITHUB_TOKEN": "<+ inputs.github_token >",
            "PLUGIN_IGNORE_MISSING": "<+ inputs.ignore_missing >",
            "PLUGIN_TIMEOUT": "<+ inputs.timeout >",
            "PLUGIN_WAIT": "<+ inputs.wait >"
          }
        }
      },
      "inputs": {
        "drone_server": { "type": "string", "description": "Drone server url", "required": true },
        "drone_token": { "type": "string", "description": "Drone server token", "required": true },
        "github_query": {
          "type": "string",
          "description": "Query to search Github for downstream repositories",
          "required": true
        },
        "github_token": { "type": "string", "description": "Github token", "required": true },
        "ignore_missing": {
          "type": "boolean",
          "description": "continue triggering if build is not found",
          "default": "false"
        },
        "timeout": {
          "type": "number",
          "description": "how long to wait on any currently running builds.",
          "default": "60"
        },
        "wait": {
          "type": "boolean",
          "description": "wait for any currently running builds to finish if true, else fails",
          "default": "false"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gitlab-ci",
    "spec": {
      "name": "Gitlab-CI",
      "description": "The Gitlab-ci plugin allows you to trigger Gitlab-ci job automatically.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-gitlab-ci",
          "envs": {
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_HOST": "<+ inputs.host >",
            "PLUGIN_ID": "<+ inputs.id >",
            "PLUGIN_REF": "<+ inputs.ref >",
            "PLUGIN_TOKEN": "<+ inputs.token >"
          }
        }
      },
      "inputs": {
        "debug": { "type": "boolean", "description": "Enable debug mode", "default": "false" },
        "host": { "type": "string", "description": "Gitlab server url", "required": true },
        "id": { "type": "string", "description": "Gitlab project id", "required": true },
        "ref": { "type": "string", "description": "valid refs are only the branches and tags", "required": true },
        "token": { "type": "string", "description": "Gitlab token", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gitleaks",
    "spec": {
      "name": "Gitleaks",
      "description": "A plugin to detect hard-coded secrets and sensitive data in your source code files.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/gitleaks",
          "envs": { "PLUGIN_CONFIG": "<+ inputs.config >", "PLUGIN_PATH": "<+ inputs.path >" }
        }
      },
      "inputs": {
        "config": { "type": "string", "description": "The path to the gitleaks config file." },
        "path": {
          "type": "string",
          "description": "The path to the directory containing the source code files.",
          "default": "."
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "google-chat",
    "spec": {
      "name": "Google Chat",
      "description": "The Google chat plugin posts build status messages to your company google chat.",
      "step": {
        "type": "script",
        "spec": {
          "image": "pelotech/drone-google-chat",
          "envs": {
            "PLUGIN_CONVERSATION_KEY": "<+ inputs.conversation_key >",
            "PLUGIN_KEY": "<+ inputs.key >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >",
            "PLUGIN_TOKEN": "<+ inputs.token >",
            "PLUGIN_WEBHOOK": "<+ inputs.webhook >"
          }
        }
      },
      "inputs": {
        "conversation_key": {
          "type": "string",
          "description": "arbitrary key to group messages together.",
          "required": true
        },
        "key": { "type": "string", "description": "key for the webook.", "required": true },
        "template": { "type": "string", "description": "overwrite the default message template." },
        "token": { "type": "string", "description": "token for the webook.", "required": true },
        "webhook": {
          "type": "string",
          "description": "incomming webhook in the Bots section of google chat.",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "google-cloud-auth",
    "spec": {
      "name": "Google Cloud Auth",
      "description": "Plugin that allows you create and configure the Google Cloud auth configuration file that could be used with gcloud CLI. The plugin also configures Docker configuration(~/.docker/config.json) to enable push and pull of the container images from Google Artifact Registry.  **IMPORTANT:** The plugin supports only Google Artifact Registry.",
      "step": {
        "type": "script",
        "spec": {
          "image": "https://hub.docker.com/repository/docker/kameshsampath/drone-gcloud-auth",
          "envs": {
            "PLUGIN_GOOGLE_APPLICATION_CREDENTIALS": "<+ inputs.google_application_credentials >",
            "PLUGIN_GOOGLE_CLOUD_PROJECT": "<+ inputs.google_cloud_project >",
            "PLUGIN_GOOGLE_CLOUD_REGION": "<+ inputs.google_cloud_region >",
            "PLUGIN_REGISTRY_LOCATIONS": "<+ inputs.registry_locations >"
          }
        }
      },
      "inputs": {
        "google_application_credentials": {
          "type": "string",
          "description": "The Google Cloud Service Account JSON that will be used to configure your `gcloud` authorizations to be used with gcloud CLI.",
          "required": true
        },
        "google_cloud_project": {
          "type": "string",
          "description": "The Google project which will be set as default project on when using \"glcoud\".",
          "required": true
        },
        "google_cloud_region": {
          "type": "string",
          "description": "The Google region which will be set as default `compute/region` when using `gcloud`. You can find the available regions using the command \"gcloud compute regions list\". If configured this region will be enabled for Google Artifact Registry."
        },
        "registry_locations": {
          "type": "string",
          "description": "The list of Google Artifact Registry locations to configure with Google Cloud Docker credential helper."
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "google-cloud-run",
    "spec": {
      "name": "Google Cloud Run",
      "description": "Plugin to build and manage Google Cloud Run services.",
      "step": {
        "type": "script",
        "spec": {
          "image": "https://hub.docker.com/repository/docker/kameshsampath/drone-gcloud-run",
          "envs": {
            "PLUGIN_ALLOW_UNAUTHENTICATED": "<+ inputs.allow_unauthenticated >",
            "PLUGIN_DELETE": "<+ inputs.delete >",
            "PLUGIN_IMAGE": "<+ inputs.image >",
            "PLUGIN_PROJECT": "<+ inputs.project >",
            "PLUGIN_REGION": "<+ inputs.region >",
            "PLUGIN_SERVICE_ACCOUNT_JSON": "<+ inputs.service_account_json >",
            "PLUGIN_SERVICE_NAME": "<+ inputs.service_name >"
          }
        }
      },
      "inputs": {
        "allow_unauthenticated": { "type": "boolean", "description": "Allow public access to the service." },
        "delete": { "type": "boolean", "description": "If the service needs to be deleted." },
        "image": {
          "type": "string",
          "description": "The container image that will be used for the service.",
          "required": true
        },
        "project": {
          "type": "string",
          "description": "The Google project where the Google Cloud Run service will be deployed.",
          "required": true
        },
        "region": {
          "type": "string",
          "description": "The Google Cloud region e.g asia-south1 where the Google Cloud Run service will be deployed.",
          "required": true
        },
        "service_account_json": {
          "type": "string",
          "description": "The Google Cloud Service Account JSON that has required permissions to create, update and delete Google Cloud Run services .",
          "required": true
        },
        "service_name": {
          "type": "string",
          "description": "The name of the Google Cloud Run service.",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gpgsign",
    "spec": {
      "name": "GPG Sign",
      "description": "This plugin can sign your artifacts and build results with [GnuPG](https://www.gnupg.org/).",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/gpgsign",
          "envs": {
            "PLUGIN_CLEAR_SIGN": "<+ inputs.clear_sign >",
            "PLUGIN_DETACH_SIGN": "<+ inputs.detach_sign >",
            "PLUGIN_EXCLUDES": "<+ inputs.excludes >",
            "PLUGIN_FILES": "<+ inputs.files >",
            "PLUGIN_KEY": "<+ inputs.key >",
            "PLUGIN_PASSPHRASE": "<+ inputs.passphrase >"
          }
        }
      },
      "inputs": {
        "clear_sign": { "type": "boolean", "description": "Generate a clear-sign signature.", "default": "false" },
        "detach_sign": { "type": "boolean", "description": "Generate a detach-sign signature.", "default": "false" },
        "excludes": { "type": "array", "description": "List of globs to exclude files.", "default": "[]" },
        "files": { "type": "array", "description": "List of globs to match files.", "default": "[]", "required": true },
        "key": { "type": "string", "description": "Private GnuPG key, optionally base64 encoded.", "required": true },
        "passphrase": { "type": "string", "description": "passphrase for the private key.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "grafana-annotation",
    "spec": {
      "name": "Grafana Annotation",
      "description": "The Grafana Annotation plugin can be used to create an annotation in [Grafana](https://grafana.com).",
      "step": {
        "type": "script",
        "spec": {
          "image": "fdeschenes/drone-grafana-annotation",
          "envs": {
            "PLUGIN_API_KEY": "<+ inputs.api_key >",
            "PLUGIN_TAGS": "<+ inputs.tags >",
            "PLUGIN_TEXT": "<+ inputs.text >",
            "PLUGIN_URL": "<+ inputs.url >"
          }
        }
      },
      "inputs": {
        "api_key": { "type": "string", "description": "The Grafana API key", "required": true },
        "tags": { "type": "array", "description": "The tags to add to the annotation", "default": "[]" },
        "text": { "type": "string", "description": "Description", "required": true },
        "url": { "type": "string", "description": "The Grafana URL", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "gtalk",
    "spec": {
      "name": "GTalk",
      "description": "The GTalk plugin posts build status messages to your google account.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-gtalk",
          "envs": {
            "PLUGIN_GOOGLE_HOST": "<+ inputs.google_host >",
            "PLUGIN_GOOGLE_PASSWORD": "<+ inputs.google_password >",
            "PLUGIN_GOOGLE_USERNAME": "<+ inputs.google_username >",
            "PLUGIN_MESSAGE": "<+ inputs.message >",
            "PLUGIN_TO": "<+ inputs.to >"
          }
        }
      },
      "inputs": {
        "google_host": {
          "type": "string",
          "description": "The Google Talk server hostname",
          "default": "talk.google.com:443",
          "required": true
        },
        "google_password": { "type": "string", "description": "Google user account password", "required": true },
        "google_username": { "type": "string", "description": "Google user account", "required": true },
        "message": { "type": "string", "description": "overwrite the default message", "required": true },
        "to": { "type": "string", "description": "Google user account", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "harness-terraform",
    "spec": {
      "name": "Harness Terraform",
      "description": "Terraform plugin to use in the IACM module in Harness",
      "step": {
        "type": "script",
        "spec": { "image": "plugins/harness_terraform", "envs": { "PLUGIN_COMMAND": "<+ inputs.command >" } }
      },
      "inputs": {
        "command": {
          "type": "string",
          "description": "Commands that indicates what action the plugin will perform. Current supported values are init, plan, apply or destroy",
          "default": "init",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "helm",
    "spec": {
      "name": "Helm",
      "description": "This plugin allows you to run Kubernetes Helm as part of your pipeline.",
      "step": {
        "type": "script",
        "spec": {
          "image": "ipedrazas/drone-helm",
          "envs": {
            "PLUGIN_API_SERVER": "<+ inputs.api_server >",
            "PLUGIN_CHART": "<+ inputs.chart >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_KUBERNETES_TOKEN": "<+ inputs.kubernetes_token >",
            "PLUGIN_NAMESPACE": "<+ inputs.namespace >",
            "PLUGIN_PREFIX": "<+ inputs.prefix >",
            "PLUGIN_RELEASE": "<+ inputs.release >",
            "PLUGIN_SKIP_TLS_VERIFY": "<+ inputs.skip_tls_verify >",
            "PLUGIN_TILLER_NS": "<+ inputs.tiller_ns >",
            "PLUGIN_VALUES": "<+ inputs.values >"
          }
        }
      },
      "inputs": {
        "api_server": { "type": "string", "description": "kubernetes api server." },
        "chart": { "type": "string", "description": "The chart to install", "required": true },
        "debug": {
          "type": "boolean",
          "description": "very verbose output. it will display all the ENVVARS passed to the container. Very handy when debugging secrets.",
          "default": "false"
        },
        "kubernetes_token": { "type": "string", "description": "kubernetes token." },
        "namespace": {
          "type": "string",
          "description": "namespace where you want to install your chart. If you don't specify this parameter",
          "default": "default"
        },
        "prefix": {
          "type": "string",
          "description": "defines the prefix of all the secrets used in the plugin. If prefix is DEV and your secret should be named DEV_PASSWORD and the values would be ${PASSWORD}. If prefix is PROD the secret should be defined as PROD_PASSWORD. This allows you to define different secrets for different."
        },
        "release": {
          "type": "string",
          "description": "name used in the helm command to specify the release",
          "default": "If you don't specify the release, helm will generate a random name and you will not be able to upgrade that release.",
          "required": true
        },
        "skip_tls_verify": {
          "type": "boolean",
          "description": "if you create your own SSL certificates, youi will need this flag to be true to avoid having connectivity issues.",
          "default": "false"
        },
        "tiller_ns": {
          "type": "string",
          "description": "namespace where tiller will be installed.",
          "default": "kube-system"
        },
        "values": {
          "type": "string",
          "description": "values injected in helm command. These are the values you want to overwrite."
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "helm3",
    "spec": {
      "name": "Helm3",
      "description": "This plugin provides an interface to Helm 3.",
      "step": {
        "type": "script",
        "spec": {
          "image": "pelotech/drone-helm3",
          "envs": {
            "PLUGIN_ADD_REPOS": "<+ inputs.add_repos >",
            "PLUGIN_ATOMIC_UPGRADE": "<+ inputs.atomic_upgrade >",
            "PLUGIN_CHART": "<+ inputs.chart >",
            "PLUGIN_CHART_VERSION": "<+ inputs.chart_version >",
            "PLUGIN_CLEANUP_FAILED_UPGRADE": "<+ inputs.cleanup_failed_upgrade >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_DRY_RUN": "<+ inputs.dry_run >",
            "PLUGIN_FORCE_UPGRADE": "<+ inputs.force_upgrade >",
            "PLUGIN_KEEP_HISTORY": "<+ inputs.keep_history >",
            "PLUGIN_KUBE_API_SERVER": "<+ inputs.kube_api_server >",
            "PLUGIN_KUBE_CERTIFICATE": "<+ inputs.kube_certificate >",
            "PLUGIN_KUBE_SERVICE_ACCOUNT": "<+ inputs.kube_service_account >",
            "PLUGIN_KUBE_TOKEN": "<+ inputs.kube_token >",
            "PLUGIN_LINT_STRICTLY": "<+ inputs.lint_strictly >",
            "PLUGIN_MODE": "<+ inputs.mode >",
            "PLUGIN_NAMESPACE": "<+ inputs.namespace >",
            "PLUGIN_RELEASE": "<+ inputs.release >",
            "PLUGIN_REPO_CA_CERTIFICATE": "<+ inputs.repo_ca_certificate >",
            "PLUGIN_REPO_CERTIFICATE": "<+ inputs.repo_certificate >",
            "PLUGIN_REUSE_VALUES": "<+ inputs.reuse_values >",
            "PLUGIN_SKIP_TLS_VERIFY": "<+ inputs.skip_tls_verify >",
            "PLUGIN_STRING_VALUES": "<+ inputs.string_values >",
            "PLUGIN_TIMEOUT": "<+ inputs.timeout >",
            "PLUGIN_UPDATE_DEPENDENCIES": "<+ inputs.update_dependencies >",
            "PLUGIN_VALUES": "<+ inputs.values >",
            "PLUGIN_VALUES_FILES": "<+ inputs.values_files >",
            "PLUGIN_WAIT_FOR_UPGRADE": "<+ inputs.wait_for_upgrade >"
          }
        }
      },
      "inputs": {
        "add_repos": {
          "type": "array",
          "description": "Run helm repo add before running the main helm command.",
          "default": "boolean"
        },
        "atomic_upgrade": { "type": "boolean", "description": "Pass --atomic to helm upgrade.", "default": "false" },
        "chart": { "type": "string", "description": "Helm chart to install or lint." },
        "chart_version": { "type": "string", "description": "Version of the chart to install." },
        "cleanup_failed_upgrade": {
          "type": "boolean",
          "description": "Pass --cleanup-on-fail to helm upgrade.",
          "default": "false"
        },
        "debug": {
          "type": "boolean",
          "description": "Produce debug output from the plugin and helm itself. Note that this option may expose secrets in the log output.",
          "default": "false"
        },
        "dry_run": {
          "type": "boolean",
          "description": "Prepare the un/installation, but do not perform it.",
          "default": "false"
        },
        "force_upgrade": { "type": "boolean", "description": "Pass --force to helm upgrade.", "default": "false" },
        "keep_history": {
          "type": "boolean",
          "description": "Pass --keep-history to helm uninstall.",
          "default": "false"
        },
        "kube_api_server": { "type": "string", "description": "Kubernetes api server." },
        "kube_certificate": {
          "type": "string",
          "description": "Base64-encoded TLS certificate, for clusters using a self-signed CA certificate."
        },
        "kube_service_account": {
          "type": "string",
          "description": "Account name for connecting to the kubernetes api."
        },
        "kube_token": { "type": "string", "description": "Kubernetes api token." },
        "lint_strictly": { "type": "boolean", "description": "Pass --strict to helm lint.", "default": "false" },
        "mode": {
          "type": "string",
          "description": "Helm command to run; valid options are upgrade, lint, and uninstall. If not provided, can be inferred from the Drone event."
        },
        "namespace": { "type": "string", "description": "Kubernetes namespace for the un/installation." },
        "release": { "type": "string", "description": "Release name to un/install." },
        "repo_ca_certificate": {
          "type": "string",
          "description": "Base64 encoded TLS certificate for a chart repository certificate authority."
        },
        "repo_certificate": {
          "type": "string",
          "description": "Base64 encoded TLS certificate for a chart repository."
        },
        "reuse_values": {
          "type": "boolean",
          "description": "Reuse the values from a previous release.",
          "default": "false"
        },
        "skip_tls_verify": {
          "type": "boolean",
          "description": "Do not check for a valid certificate when connecting to the kubernetes api.",
          "default": "false"
        },
        "string_values": { "type": "string", "description": "Arguments for helm's --set-string flag." },
        "timeout": {
          "type": "string",
          "description": "Timeout for any individual kubernetes operation, formatted as a Golang duration (e.g. \"3m20s\")."
        },
        "update_dependencies": {
          "type": "boolean",
          "description": "Run helm dependency update before running the main helm command.",
          "default": "false"
        },
        "values": { "type": "string", "description": "Arguments for helm's --set flag." },
        "values_files": { "type": "string", "description": "Arguments for helm's --values flag." },
        "wait_for_upgrade": {
          "type": "boolean",
          "description": "Wait until kubernetes resources are in a ready state before marking the installation successful.",
          "default": "false"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "heroku",
    "spec": {
      "name": "Heroku",
      "description": "The heroku plugin can be used to build and publish images to the Heroku container registry.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/heroku",
          "envs": {
            "PLUGIN_API_KEY": "<+ inputs.api_key >",
            "PLUGIN_APP": "<+ inputs.app >",
            "PLUGIN_EMAIL": "<+ inputs.email >",
            "PLUGIN_PROCESS_TYPE": "<+ inputs.process_type >",
            "PLUGIN_REGISTRY": "<+ inputs.registry >"
          }
        }
      },
      "inputs": {
        "api_key": { "type": "string", "description": "heroku api key", "required": true },
        "app": { "type": "string", "description": "app name", "required": true },
        "email": { "type": "string", "description": "auth email", "required": true },
        "process_type": { "type": "string", "description": "process type", "required": true },
        "registry": {
          "type": "string",
          "description": "authenticates to this registry",
          "default": "registry.heroku.com"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "hg",
    "spec": {
      "name": "Mercurial",
      "description": "The mercurial plugin is used to clone a mercurial repository.",
      "step": { "type": "script", "spec": { "image": "plugins/hg" } },
      "inputs": {}
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "hugo",
    "spec": {
      "name": "Hugo",
      "description": "The Hugo plugin automatically generates static web page files, which can be published afterwards!",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/hugo",
          "envs": {
            "PLUGIN_BUILDDRAFTS": "<+ inputs.buildDrafts >",
            "PLUGIN_BUILDEXPIRED": "<+ inputs.buildExpired >",
            "PLUGIN_BUILDFUTURE": "<+ inputs.buildFuture >",
            "PLUGIN_CONFIG": "<+ inputs.config >",
            "PLUGIN_CONTENT": "<+ inputs.content >",
            "PLUGIN_LAYOUT": "<+ inputs.layout >",
            "PLUGIN_OUTPUT": "<+ inputs.output >",
            "PLUGIN_SOURCE": "<+ inputs.source >",
            "PLUGIN_THEME": "<+ inputs.theme >",
            "PLUGIN_URL": "<+ inputs.url >",
            "PLUGIN_VALIDATE": "<+ inputs.validate >"
          }
        }
      },
      "inputs": {
        "buildDrafts": { "type": "boolean", "description": "Include content marked as draft.", "default": "false" },
        "buildExpired": { "type": "boolean", "description": "Include expired content.", "default": "false" },
        "buildFuture": {
          "type": "boolean",
          "description": "include content with publishdate in the future.",
          "default": "false"
        },
        "config": {
          "type": "string",
          "description": "The path to the config file.",
          "default": "path/config.yaml|json|toml"
        },
        "content": { "type": "string", "description": "The path to the content directory." },
        "layout": { "type": "string", "description": "The path to the layout directory." },
        "output": { "type": "string", "description": "The path to the output directory." },
        "source": { "type": "string", "description": "The path to read files relative from." },
        "theme": { "type": "string", "description": "theme to use (located in /themes/THEMENAME/)." },
        "url": { "type": "string", "description": "hostname (and path) to the root." },
        "validate": { "type": "boolean", "description": "Validate config file before generation.", "default": "false" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "instant-access",
    "spec": {
      "name": "InstantAccess(即时达)",
      "description": "The InstantAccess plugin posts build status messages to your account.",
      "step": {
        "type": "script",
        "spec": {
          "image": "erguotou/drone-instant-access",
          "envs": {
            "PLUGIN_BODY": "<+ inputs.body >",
            "PLUGIN_CHANNEL": "<+ inputs.channel >",
            "PLUGIN_HEAD": "<+ inputs.head >"
          }
        }
      },
      "inputs": {
        "body": { "type": "string", "description": "Notification body, supports markdown", "required": true },
        "channel": {
          "type": "string",
          "description": "The InstantAccess(即时达) channel key, get key by http://push.ijingniu.cn/push/channel/",
          "required": true
        },
        "head": { "type": "string", "description": "Notification title", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "irc",
    "spec": {
      "name": "IRC",
      "description": "The IRC plugin can be used to send notifications to an IRC channel.\n",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/irc/",
          "envs": {
            "PLUGIN_CHANNEL": "<+ inputs.channel >",
            "PLUGIN_ENABLE-TLS": "<+ inputs.enable-tls >",
            "PLUGIN_HOST": "<+ inputs.host >",
            "PLUGIN_NICK": "<+ inputs.nick >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PORT": "<+ inputs.port >",
            "PLUGIN_RECIPIENTS": "<+ inputs.recipients >",
            "PLUGIN_SASL-PASSWORD": "<+ inputs.sasl-password >",
            "PLUGIN_USE-SASL": "<+ inputs.use-sasl >"
          }
        }
      },
      "inputs": {
        "channel": { "type": "string", "description": "channel to post message in" },
        "enable-tls": { "type": "boolean", "description": "enable tls", "default": "false" },
        "host": { "type": "string", "description": "irc server host" },
        "nick": { "type": "string", "description": "nickname used by bot", "default": "drone{random-number}" },
        "password": { "type": "string", "description": "password" },
        "port": { "type": "string", "description": "port", "default": "6667" },
        "recipients": { "type": "string", "description": "recipient" },
        "sasl-password": { "type": "string", "description": "sasl-password" },
        "use-sasl": { "type": "boolean", "description": "use use-sasl", "default": "false" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "java-maven",
    "spec": {
      "name": "Java Maven",
      "description": "The Java Apache Maven plugin that can be used to build Java applications using Apache Maven build tool.",
      "step": {
        "type": "script",
        "spec": {
          "image": "https://hub.docker.com/repository/docker/kameshsampath/drone-java-maven-plugin",
          "envs": {
            "PLUGIN_CONTEXT_DIR": "<+ inputs.context_dir >",
            "PLUGIN_GOALS": "<+ inputs.goals >",
            "PLUGIN_MAVEN_MIRROR_URL": "<+ inputs.maven_mirror_url >",
            "PLUGIN_MAVEN_MODULES": "<+ inputs.maven_modules >",
            "PLUGIN_PROXY_HOST": "<+ inputs.proxy_host >",
            "PLUGIN_PROXY_NON_PROXY_HOSTS": "<+ inputs.proxy_non_proxy_hosts >",
            "PLUGIN_PROXY_PASSWORD": "<+ inputs.proxy_password >",
            "PLUGIN_PROXY_PORT": "<+ inputs.proxy_port >",
            "PLUGIN_PROXY_PROTOCOL": "<+ inputs.proxy_protocol >",
            "PLUGIN_PROXY_USER": "<+ inputs.proxy_user >",
            "PLUGIN_SERVER_PASSWORD": "<+ inputs.server_password >",
            "PLUGIN_SERVER_USER": "<+ inputs.server_user >"
          }
        }
      },
      "inputs": {
        "context_dir": {
          "type": "string",
          "description": "The context directory within the source repository where \"pom.xml\" is found to execute the maven goals. Defaults to Drone workspace root."
        },
        "goals": {
          "type": "array",
          "description": "An array of maven goals to run.",
          "default": "-DskipTests clean install"
        },
        "maven_mirror_url": {
          "type": "string",
          "description": "The maven mirror to use for downloading the build dependencies."
        },
        "maven_modules": {
          "type": "array",
          "description": "An array of maven modules to be built incase of a multi module maven project."
        },
        "proxy_host": { "type": "string", "description": "Proxy server Host.", "default": "false" },
        "proxy_non_proxy_hosts": { "type": "array", "description": "Non proxy server hosts.", "default": "false" },
        "proxy_password": { "type": "string", "description": "The password for the proxy server." },
        "proxy_port": { "type": "number", "description": "Port number for the proxy server." },
        "proxy_protocol": {
          "type": "string",
          "description": "Protocol for the proxy ie http or https.",
          "default": "false"
        },
        "proxy_user": { "type": "string", "description": "The username for the proxy server." },
        "server_password": { "type": "string", "description": "The password for the maven repository manager server." },
        "server_user": { "type": "string", "description": "The username for the maven repository manager server." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "jenkins",
    "spec": {
      "name": "Jenkins",
      "description": "The Jenkins plugin allows you to trigger Jenkins job automatically.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-jenkins",
          "envs": {
            "PLUGIN_JOB": "<+ inputs.job >",
            "PLUGIN_TOKEN": "<+ inputs.token >",
            "PLUGIN_URL": "<+ inputs.url >",
            "PLUGIN_USER": "<+ inputs.user >"
          }
        }
      },
      "inputs": {
        "job": { "type": "string", "description": "The Jenkins job name", "required": true },
        "token": { "type": "string", "description": "The Jenkins token", "required": true },
        "url": { "type": "string", "description": "The Jenkins URL", "required": true },
        "user": { "type": "string", "description": "The Jenkins user", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "jfrog-artifactory",
    "spec": {
      "name": "JFrog Artifactory",
      "description": "A plugin to upload files to Jfrog artifactory.\n",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/artifactory",
          "envs": {
            "PLUGIN_APIKEY": "<+ inputs.apikey >",
            "PLUGIN_FLAT": "<+ inputs.flat >",
            "PLUGIN_INSECURE": "<+ inputs.insecure >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PEM_FILE_CONTENTS": "<+ inputs.pem_file_contents >",
            "PLUGIN_PEM_FILE_PATH": "<+ inputs.pem_file_path >",
            "PLUGIN_RETRIES": "<+ inputs.retries >",
            "PLUGIN_SOURCE": "<+ inputs.source >",
            "PLUGIN_TARGET": "<+ inputs.target >",
            "PLUGIN_URL": "<+ inputs.url >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "apikey": { "type": "string", "description": "key for authentication with artifactory" },
        "flat": {
          "type": "boolean",
          "description": "if true, artifacts are downloaded to the exact target path specified and their hierarchy in the source repository is ignored. if false, artifacts are downloaded to the target path in the file system while maintaining their hierarchy in the source repository",
          "default": "false"
        },
        "insecure": {
          "type": "boolean",
          "description": "if true, the connection to the source repository is not validated by checking the server certificate. if false, the connection to the source repository is validated by checking the server certificate",
          "default": "false"
        },
        "password": { "type": "string", "description": "password for authentication with artifactory" },
        "pem_file_contents": {
          "type": "string",
          "description": "pem file contents for authentication with artifactory, cannot be used in conjunction with insecure"
        },
        "pem_file_path": {
          "type": "string",
          "description": "pem file path for authentication with artifactory, defaults to either \"C:/users/ContainerAdministrator/.jfrog/security/certs/cert.pem\" or \"/root/.jfrog/security/certs/cert.pem\""
        },
        "retries": { "type": "number", "description": "number of upload retries", "default": "3" },
        "source": { "type": "string", "description": "file(s) to upload", "required": true },
        "target": { "type": "string", "description": "destination of source files in artifactory", "required": true },
        "url": { "type": "string", "description": "location of the artifactory server", "required": true },
        "username": { "type": "string", "description": "username for authentication with artifactory" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "jira",
    "spec": {
      "name": "Jira",
      "description": "A plugin to attach build and deployment details to a Jira issue. It can use oauth client id / oauth secret OR use Jira connect key. For further information on how to use the plugin with harness there is a video `https://www.youtube.com/watch?v=YIKbLeY1-gI`.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/jira",
          "envs": {
            "PLUGIN_CLIENT_ID": "<+ inputs.client_id >",
            "PLUGIN_CLIENT_SECRET": "<+ inputs.client_secret >",
            "PLUGIN_CONNECT_KEY": "<+ inputs.connect_key >",
            "PLUGIN_ENVIRONMENT_NAME": "<+ inputs.environment_name >",
            "PLUGIN_INSTANCE": "<+ inputs.instance >",
            "PLUGIN_LINK": "<+ inputs.link >",
            "PLUGIN_LOG_LEVEL": "<+ inputs.log_level >",
            "PLUGIN_PIPELINE": "<+ inputs.pipeline >",
            "PLUGIN_PROJECT": "<+ inputs.project >"
          }
        }
      },
      "inputs": {
        "client_id": {
          "type": "string",
          "description": "The Jira Oauth2 client ID. You must also pass the client secret.",
          "required": true
        },
        "client_secret": {
          "type": "string",
          "description": "The Jira Oauth2 client secret. You must also pass the client id.",
          "required": true
        },
        "connect_key": {
          "type": "string",
          "description": "The Jira Connect key. This is instead of passing oauth information.",
          "required": true
        },
        "environment_name": { "type": "string", "description": "The Jira environment name.", "required": true },
        "instance": {
          "type": "string",
          "description": "The Jira instance. The prefix on your atlassian hostname.",
          "required": true
        },
        "link": { "type": "string", "description": "The link to the Jira deployment." },
        "log_level": {
          "type": "string",
          "description": "debug/info Level defines the plugin log level. Set this to debug to see the response from jira"
        },
        "pipeline": { "type": "string", "description": "The pipeline name.", "required": true },
        "project": { "type": "string", "description": "The Jira project. eg TEST", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "k8s",
    "spec": {
      "name": "Kubernetes Plugin",
      "description": "Drone CI plugin for creating & updating K8s Resources.   This plugin supports all Kubernetes resources and also supports creating/updating Configmaps from config files.",
      "step": {
        "type": "script",
        "spec": {
          "image": "zc2638/drone-k8s-plugin",
          "envs": {
            "PLUGIN_CONFIG_FILES": "<+ inputs.config_files >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_INIT_TEMPLATES": "<+ inputs.init_templates >",
            "PLUGIN_KUBERNETES_CA_CRT": "<+ inputs.kubernetes_ca_crt >",
            "PLUGIN_KUBERNETES_SERVER": "<+ inputs.kubernetes_server >",
            "PLUGIN_KUBERNETES_SKIP_TLS": "<+ inputs.kubernetes_skip_tls >",
            "PLUGIN_KUBERNETES_TOKEN": "<+ inputs.kubernetes_token >",
            "PLUGIN_NAMESPACE": "<+ inputs.namespace >",
            "PLUGIN_OTHER_PARAMETERS": "<+ inputs.Other_parameters >",
            "PLUGIN_TEMPLATES": "<+ inputs.templates >"
          }
        }
      },
      "inputs": {
        "Other_parameters": {
          "type": "string",
          "description": "Other parameters will be made available for interpolation within yaml templates (upper-case will be converted to lower-case)."
        },
        "config_files": {
          "type": "array",
          "description": "Config file paths for automatic creation/update of ConfigMap.The syntax is expressed as `namespace:name:file_path:file_name` or `namespace:name:file_path`, when file_name is not specified, it will default to the file name of file_path."
        },
        "debug": { "type": "boolean", "description": "Used to enable debug level logging.", "default": "false" },
        "init_templates": {
          "type": "array",
          "description": "Path to Kubernetes Resource yaml based definition file (e.g. ConfigMap, Deployment or others), used to initialize some resources."
        },
        "kubernetes_ca_crt": {
          "type": "string",
          "description": "The same as `k8s_ca_crt`. Certificate from ServiceAccount for authentication to the API server."
        },
        "kubernetes_server": {
          "type": "string",
          "description": "The same as `k8s_server`. The address and port of the Kubernetes API server.",
          "required": true
        },
        "kubernetes_skip_tls": {
          "type": "boolean",
          "description": "The same as `k8s_skip_tls`. If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure.",
          "default": "false"
        },
        "kubernetes_token": {
          "type": "string",
          "description": "The same as `k8s_token`. Token from ServiceAccount for authentication to the API server.",
          "required": true
        },
        "namespace": { "type": "string", "description": "Default namespace to use when namespace is not set." },
        "templates": {
          "type": "array",
          "description": "Path to Kubernetes Resource yaml based definition file (e.g. ConfigMap, Deployment or others)."
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "kaniko-ecr",
    "spec": {
      "name": "Kaniko ECR",
      "description": "The Kaniko ECR plugin can be used to build and publish images to the Amazon ECR registry, using the Kaniko image builder. Unlike the Docker ECR plugin, you are not required you to run your agent in privileged mode.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/kaniko-ecr",
          "envs": {
            "PLUGIN_ACCESS_KEY": "<+ inputs.access_key >",
            "PLUGIN_BUILD_ARGS": "<+ inputs.build_args >",
            "PLUGIN_CONTEXT": "<+ inputs.context >",
            "PLUGIN_CREATE_REPOSITORY": "<+ inputs.create_repository >",
            "PLUGIN_DOCKERFILE": "<+ inputs.dockerfile >",
            "PLUGIN_LIFECYCLE_POLICY": "<+ inputs.lifecycle_policy >",
            "PLUGIN_REGION": "<+ inputs.region >",
            "PLUGIN_REGISTRY": "<+ inputs.registry >",
            "PLUGIN_REPO": "<+ inputs.repo >",
            "PLUGIN_REPOSITORY_POLICY": "<+ inputs.repository_policy >",
            "PLUGIN_SECRET_KEY": "<+ inputs.secret_key >",
            "PLUGIN_TAGS": "<+ inputs.tags >",
            "PLUGIN_TARGET": "<+ inputs.target >"
          }
        }
      },
      "inputs": {
        "access_key": { "type": "string", "description": "AWS access key.", "required": true },
        "build_args": { "type": "array", "description": "custom arguments passed to docker build.", "default": "[]" },
        "context": { "type": "string", "description": "path to the context directory", "default": "git repo root" },
        "create_repository": {
          "type": "boolean",
          "description": "Create repository if it does not exist.",
          "default": "false"
        },
        "dockerfile": { "type": "string", "description": "path to the Dockerfile", "default": "Dockerfile" },
        "lifecycle_policy": { "type": "string", "description": "filename of ecr lifecycle json policy." },
        "region": { "type": "string", "description": "AWS region.", "default": "us-east-1" },
        "registry": { "type": "string", "description": "authenticates to this registry", "required": true },
        "repo": { "type": "string", "description": "repository name for the image", "required": true },
        "repository_policy": { "type": "string", "description": "filename of ecr repository json policy." },
        "secret_key": { "type": "string", "description": "AWS secret key.", "required": true },
        "tags": { "type": "array", "description": "repository tags to apply to the image", "default": "[]" },
        "target": { "type": "string", "description": "the build target to use, must be defined in the docker file" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "kaniko",
    "spec": {
      "name": "Kaniko",
      "description": "This plugin can be used to build and publish images to the Docker registry, using the Kaniko image builder. Unlike the Docker plugin you are not required you to run your agent in privileged mode.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/kaniko",
          "envs": {
            "PLUGIN_BUILD_ARGS": "<+ inputs.build_args >",
            "PLUGIN_CONTEXT": "<+ inputs.context >",
            "PLUGIN_DOCKERFILE": "<+ inputs.dockerfile >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_REGISTRY": "<+ inputs.registry >",
            "PLUGIN_REPO": "<+ inputs.repo >",
            "PLUGIN_TAGS": "<+ inputs.tags >",
            "PLUGIN_TARGET": "<+ inputs.target >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "build_args": { "type": "array", "description": "custom arguments passed to docker build.", "default": "[]" },
        "context": { "type": "string", "description": "path to the context directory", "default": "git repo root" },
        "dockerfile": { "type": "string", "description": "path to the Dockerfile", "default": "Dockerfile" },
        "password": { "type": "string", "description": "authenticates with this password", "required": true },
        "registry": { "type": "string", "description": "authenticates to this registry", "required": true },
        "repo": { "type": "string", "description": "repository name for the image", "required": true },
        "tags": { "type": "array", "description": "repository tags to apply to the image", "default": "[]" },
        "target": { "type": "string", "description": "the build target to use, must be defined in the docker file" },
        "username": { "type": "string", "description": "authenticates with this username", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "kube",
    "spec": {
      "name": "Drone Kube",
      "description": "Drone kubernetes plugin.",
      "step": {
        "type": "script",
        "spec": {
          "image": "vallard/drone-kube",
          "envs": {
            "PLUGIN_NAMESPACE": "<+ inputs.namespace >",
            "PLUGIN_SERVER": "<+ inputs.server >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >"
          }
        }
      },
      "inputs": {
        "namespace": { "type": "string", "description": "The namespace to deploy the template in", "required": true },
        "server": {
          "type": "string",
          "description": "The kubernetes server to deploy the template in",
          "required": true
        },
        "template": { "type": "string", "description": "The template to use", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "kubernetes",
    "spec": {
      "name": "Kubernetes Deployments",
      "description": "The Kubernetes plugin can be used to upgrade a Kubernetes deployment with a newer version of an image.",
      "step": {
        "type": "script",
        "spec": {
          "image": "https://quay.io/honestbee/drone-kubernetes",
          "envs": {
            "PLUGIN_CONTAINER": "<+ inputs.container >",
            "PLUGIN_DEPLOYMENT": "<+ inputs.deployment >",
            "PLUGIN_KUBERNETES_SERVER": "<+ inputs.kubernetes_server >",
            "PLUGIN_KUBERNETES_TOKEN": "<+ inputs.kubernetes_token >",
            "PLUGIN_NAMESPACE": "<+ inputs.namespace >",
            "PLUGIN_REPO": "<+ inputs.repo >",
            "PLUGIN_TAG": "<+ inputs.tag >"
          }
        }
      },
      "inputs": {
        "container": {
          "type": "array",
          "description": "Container name (setup with the name option in the kubernetes manifest).",
          "required": true
        },
        "deployment": { "type": "array", "description": "Deployment name.", "required": true },
        "kubernetes_server": { "type": "string", "description": "Kubernetes server URL.", "required": true },
        "kubernetes_token": { "type": "string", "description": "Kubernetes token.", "required": true },
        "namespace": { "type": "string", "description": "Kubernetes namespace.", "required": true },
        "repo": {
          "type": "string",
          "description": "Image to update full name (with registry path).",
          "required": true
        },
        "tag": { "type": "string", "description": "Image tag to update.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "kubevious",
    "spec": {
      "name": "Kubevious",
      "description": "The Kubevious plugin detects and prevents errors(typos, misconfigurations, conflicts, inconsistencies) and violations of best practices for Kubernetes applications and clusters.",
      "step": {
        "type": "script",
        "spec": {
          "image": "kubevious/cli",
          "envs": {
            "PLUGIN_CRDS": "<+ inputs.crds >",
            "PLUGIN_DETAILED_OUTPUT": "<+ inputs.detailed_output >",
            "PLUGIN_HELM_CHART": "<+ inputs.helm_chart >",
            "PLUGIN_HELM_INCLUDE_CRDS": "<+ inputs.helm_include_crds >",
            "PLUGIN_HELM_NAMESPACE": "<+ inputs.helm_namespace >",
            "PLUGIN_HELM_OVERRIDE": "<+ inputs.helm_override >",
            "PLUGIN_HELM_REPO_NAME": "<+ inputs.helm_repo_name >",
            "PLUGIN_HELM_REPO_URL": "<+ inputs.helm_repo_url >",
            "PLUGIN_IGNORE_NON_K8S": "<+ inputs.ignore_non_k8s >",
            "PLUGIN_IGNORE_UNKNOWN": "<+ inputs.ignore_unknown >",
            "PLUGIN_JSON_OUTPUT": "<+ inputs.json_output >",
            "PLUGIN_K8S_VERSION": "<+ inputs.k8s_version >",
            "PLUGIN_LIVE_K8S": "<+ inputs.live_k8s >",
            "PLUGIN_MANIFESTS": "<+ inputs.manifests >",
            "PLUGIN_MOCKS": "<+ inputs.mocks >",
            "PLUGIN_ONLY_RULES": "<+ inputs.only_rules >",
            "PLUGIN_ONLY_RULE_CATEGORIES": "<+ inputs.only_rule_categories >",
            "PLUGIN_OTHER_ARGS": "<+ inputs.other_args >",
            "PLUGIN_SKIP_RULES": "<+ inputs.skip_rules >",
            "PLUGIN_SKIP_RULE_CATEGORIES": "<+ inputs.skip_rule_categories >"
          }
        }
      },
      "inputs": {
        "crds": { "type": "string", "description": "Path to CRDs to include in validation" },
        "detailed_output": { "type": "boolean", "description": "Output in details", "default": "false" },
        "helm_chart": { "type": "string", "description": "Helm repository chart name" },
        "helm_include_crds": {
          "type": "boolean",
          "description": "Indicates whether or not to include CRDs in Helm release",
          "default": "false"
        },
        "helm_namespace": { "type": "string", "description": "Helm release namespace" },
        "helm_override": { "type": "string", "description": "Helm overrides" },
        "helm_repo_name": { "type": "string", "description": "Name alias for Helm repository URL" },
        "helm_repo_url": { "type": "string", "description": "Helm repository URL" },
        "ignore_non_k8s": { "type": "boolean", "description": "Ignore non-Kubernetes YAML files", "default": "false" },
        "ignore_unknown": {
          "type": "boolean",
          "description": "Ignore unknown Kubernetes resources",
          "default": "false"
        },
        "json_output": { "type": "boolean", "description": "Output in JSON format", "default": "false" },
        "k8s_version": { "type": "string", "description": "Version of Kubernetes to validate againts" },
        "live_k8s": {
          "type": "boolean",
          "description": "Validate againts live Kubernetes version",
          "default": "false"
        },
        "manifests": { "type": "string", "description": "Path to manifest files, directories or URLs to validate" },
        "mocks": { "type": "string", "description": "Path to mocked manifests to include in validation" },
        "only_rule_categories": { "type": "string", "description": "Run only specified rules by category" },
        "only_rules": { "type": "string", "description": "Run only specified rules" },
        "other_args": { "type": "string", "description": "Additional arguments" },
        "skip_rule_categories": { "type": "string", "description": "Skip rules by category" },
        "skip_rules": { "type": "string", "description": "Skip rules by name" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "lambda",
    "spec": {
      "name": "AWS Lambda",
      "description": "The plugin automatically deployes a serverless function to AWS Lambda from a zip file located in an S3 bucket. This plugin does not handle creating or uploading the zip file.",
      "step": {
        "type": "script",
        "spec": {
          "image": "omerxx/drone-lambda-plugin",
          "envs": {
            "PLUGIN_AWS_ACCESS_KEY_ID": "<+ inputs.aws_access_key_id >",
            "PLUGIN_AWS_DEFAULT_REGION": "<+ inputs.aws_default_region >",
            "PLUGIN_AWS_SECRET_ACCESS_KEY": "<+ inputs.aws_secret_access_key >",
            "PLUGIN_FILE_NAME": "<+ inputs.file_name >",
            "PLUGIN_FUNCTION_NAME": "<+ inputs.function_name >",
            "PLUGIN_S3_BUCKET": "<+ inputs.s3_bucket >"
          }
        }
      },
      "inputs": {
        "aws_access_key_id": { "type": "string", "description": "The AWS access key ID" },
        "aws_default_region": {
          "type": "string",
          "description": "AWS region. This variable overrides the default region of the in-use profile, if set."
        },
        "aws_secret_access_key": {
          "type": "string",
          "description": "AWS secret key. Access and secret key variables override credentials stored in config files."
        },
        "file_name": {
          "type": "string",
          "description": "Name of the file in S3. Can be prefixed like my-directory/my-zip-package.zip.",
          "required": true
        },
        "function_name": {
          "type": "string",
          "description": "Name of the lambda function as set in AWS.",
          "required": true
        },
        "s3_bucket": {
          "type": "string",
          "description": "Name of the S3 bucket in which the zip package for deployment is stored.",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "line",
    "spec": {
      "name": "Line",
      "description": "The Line plugin posts build status messages to your channel.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-line",
          "envs": {
            "PLUGIN_AUDIOS": "<+ inputs.audios >",
            "PLUGIN_CHANNEL_SECRET": "<+ inputs.channel_secret >",
            "PLUGIN_CHANNEL_TOKEN": "<+ inputs.channel_token >",
            "PLUGIN_IMAGES": "<+ inputs.images >",
            "PLUGIN_LOCATIONS": "<+ inputs.locations >",
            "PLUGIN_MESSAGE": "<+ inputs.message >",
            "PLUGIN_STICKERS": "<+ inputs.stickers >",
            "PLUGIN_TO": "<+ inputs.to >",
            "PLUGIN_VIDEOS": "<+ inputs.videos >"
          }
        }
      },
      "inputs": {
        "audios": { "type": "array", "description": "Valid audio URLs", "default": "[]" },
        "channel_secret": { "type": "string", "description": "The channel secret", "required": true },
        "channel_token": { "type": "string", "description": "The channel token", "required": true },
        "images": { "type": "array", "description": "Valid image URLs", "default": "[]" },
        "locations": { "type": "array", "description": "Valid location lat/lng", "default": "[]" },
        "message": { "type": "string", "description": "Overwrite the default message template.", "required": true },
        "stickers": { "type": "array", "description": "Valid stickers", "default": "[]" },
        "to": { "type": "string", "description": "The user ID to send a message to" },
        "videos": { "type": "array", "description": "Valid video URLs", "default": "[]" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "load-and-store",
    "spec": {
      "name": "Load and store",
      "description": "This plugin can be used to load and publish images to the Docker registry. It can come in handy when the default Docker plugin cannot be used. A good example usecase is building Docker images with nix which produces a Docker image archive.",
      "step": {
        "type": "script",
        "spec": {
          "image": "allgreed/drone-load-and-store",
          "envs": {
            "PLUGIN_ARCHIVE": "<+ inputs.archive >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_REGISTRY": "<+ inputs.registry >",
            "PLUGIN_REPO": "<+ inputs.repo >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "archive": { "type": "string", "description": "location of the docker image archive.", "required": true },
        "debug": { "type": "boolean", "description": "Enable verbose logging", "default": "false" },
        "password": { "type": "string", "description": "The password to use for the repository", "required": true },
        "registry": { "type": "string", "description": "authenticates to this registry.", "default": "docker.io" },
        "repo": { "type": "string", "description": "repository name for the image.", "required": true },
        "username": { "type": "string", "description": "The username to use for the repository", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "manifest",
    "spec": {
      "name": "Manifest",
      "description": "This plugin can push manifests for multi-arch Docker images.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/manifest",
          "envs": {
            "PLUGIN_AUTO_TAG": "<+ inputs.auto_tag >",
            "PLUGIN_DEFAULT_TAGS": "<+ inputs.default_tags >",
            "PLUGIN_IGNORE_MISSING": "<+ inputs.ignore_missing >",
            "PLUGIN_INSECURE": "<+ inputs.insecure >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PLATFORMS": "<+ inputs.platforms >",
            "PLUGIN_SPEC": "<+ inputs.spec >",
            "PLUGIN_TAG": "<+ inputs.tag >",
            "PLUGIN_TAGS": "<+ inputs.tags >",
            "PLUGIN_TARGET": "<+ inputs.target >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "auto_tag": { "type": "boolean", "description": "Auto tags, only used with spec.", "default": "false" },
        "default_tags": { "type": "boolean", "description": "Default tags, only used with spec.", "default": "false" },
        "ignore_missing": { "type": "boolean", "description": "Ignore missing source images.", "default": "false" },
        "insecure": {
          "type": "boolean",
          "description": "Enable insecure (not TLS) registry support.",
          "default": "false"
        },
        "password": {
          "type": "string",
          "description": "Password for DockerHub authentication",
          "default": "Anonymous access",
          "required": true
        },
        "platforms": {
          "type": "array",
          "description": "List of platforms in format OS/ARCH.",
          "default": "[]",
          "required": true
        },
        "spec": { "type": "string", "description": "Path to a manifest specification file.", "required": true },
        "tag": { "type": "string", "description": "Tag, only used with spec." },
        "tags": { "type": "array", "description": "Tags, only used with manifest.", "default": "[]" },
        "target": { "type": "string", "description": "Target image for manifest.", "required": true },
        "template": {
          "type": "string",
          "description": "Template for manifest sources, OS and ARCH are replaced.",
          "required": true
        },
        "username": {
          "type": "string",
          "description": "Username for DockerHub authentication",
          "default": "Anonymous access",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "marathon",
    "spec": {
      "name": "Marathon",
      "description": "This plugin can be used to deploy applications to a Marathon server.",
      "step": {
        "type": "script",
        "spec": {
          "image": "e20co/drone-marathon",
          "envs": {
            "PLUGIN_MARATHONFILE": "<+ inputs.marathonfile >",
            "PLUGIN_SERVER": "<+ inputs.server >",
            "PLUGIN_TRIGGER_RESTART": "<+ inputs.trigger_restart >",
            "PLUGIN_VALUES": "<+ inputs.values >"
          }
        }
      },
      "inputs": {
        "marathonfile": {
          "type": "string",
          "description": "The Marathon configuration file.",
          "default": "marathon.json"
        },
        "server": { "type": "string", "description": "Marathon server URL.", "default": "http://marathon.mesos:8080" },
        "trigger_restart": {
          "type": "boolean",
          "description": "Force a restart of the application.",
          "default": "false"
        },
        "values": { "type": "object", "description": "Map of values to replace in the marathonfile." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "matrix",
    "spec": {
      "name": "Matrix",
      "description": "This plugin can be used to send build success or failure messages to a Matrix room.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/matrix",
          "envs": {
            "PLUGIN_ACCESSTOKEN": "<+ inputs.accesstoken >",
            "PLUGIN_HOMESERVER": "<+ inputs.homeserver >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_ROOMID": "<+ inputs.roomid >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >",
            "PLUGIN_USERID": "<+ inputs.userid >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "accesstoken": { "type": "string", "description": "Matrix access token (use with userid)." },
        "homeserver": {
          "type": "string",
          "description": "The Matrix homeserver URL.",
          "default": "https://matrix.org"
        },
        "password": {
          "type": "string",
          "description": "Password on homeserver (use with username).",
          "required": true
        },
        "roomid": {
          "type": "string",
          "description": "Room ID to send messages (not alias, but ID, and you can skip the !).",
          "required": true
        },
        "template": { "type": "string", "description": "Template to use for message." },
        "userid": { "type": "string", "description": "Matrix user ID (@user:homeserver.tld)." },
        "username": { "type": "string", "description": "Username on homeserver.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "matrixchat-notify",
    "spec": {
      "name": "Matrixchat Notifications",
      "description": "A plugin to send notifications to Matrix chat rooms from CI pipeline steps. Supports Jinja message templates and Markdown rendering.",
      "step": {
        "type": "script",
        "spec": {
          "image": "spotlightkid/drone-matrixchat-notify",
          "envs": {
            "PLUGIN_ACCESSTOKEN": "<+ inputs.accesstoken >",
            "PLUGIN_ALLOWED_ATTRS": "<+ inputs.allowed_attrs >",
            "PLUGIN_ALLOWED_TAGS": "<+ inputs.allowed_tags >",
            "PLUGIN_DEVICEID": "<+ inputs.deviceid >",
            "PLUGIN_DEVICENAME": "<+ inputs.devicename >",
            "PLUGIN_HOMESERVER": "<+ inputs.homeserver >",
            "PLUGIN_JINJA": "<+ inputs.jinja >",
            "PLUGIN_MARKDOWN": "<+ inputs.markdown >",
            "PLUGIN_MARKDOWN_EXTENSIONS": "<+ inputs.markdown_extensions >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PASS_ENVIRONMENT": "<+ inputs.pass_environment >",
            "PLUGIN_ROOMID": "<+ inputs.roomid >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >",
            "PLUGIN_USERID": "<+ inputs.userid >"
          }
        }
      },
      "inputs": {
        "accesstoken": {
          "type": "string",
          "description": "Access token to use for authentication instead of `password`.\n\nEither an access token or a password is required.",
          "required": true
        },
        "allowed_attrs": {
          "type": "array",
          "description": "List or string with comma-separated list of HTML attribute names or dict mapping tag names to lists of attributes names.",
          "default": "`DEFAULT_ALLOWED_ATTRS`"
        },
        "allowed_tags": {
          "type": "array",
          "description": "List or set or string with comma-separated list of HTML tag names.\n\nHTML tags not included will be stripped from the HTML output generated by\nrendering a Markdown message template.",
          "default": "`DEFAULT_ALLOWED_TAGS`"
        },
        "deviceid": { "type": "string", "description": "Device ID to send with access token." },
        "devicename": { "type": "string", "description": "Device name to send with access token." },
        "homeserver": {
          "type": "string",
          "description": "The Matrix homeserver URL.",
          "default": "https://matrix.org"
        },
        "jinja": {
          "type": "boolean",
          "description": "If set to true, `yes`, `y`, `true`, `t`, `on` or `1`, the message template is rendered with the Jinja templating engine."
        },
        "markdown": {
          "type": "boolean",
          "description": "If set to true, `yes`, `y`, `true`, `t`, `on` or `1`, the message resulting from template substtution is considered to be in Markdown format and will be rendered to HTML."
        },
        "markdown_extensions": {
          "type": "array",
          "description": "Comma-separated list of enabled Markdown extensions.",
          "default": "admonition, extra, sane_lists, smarty"
        },
        "pass_environment": {
          "type": "array",
          "description": "Comma-separated white-list of environment variable names or name\nshell-glob patterns.\n\nOnly environment variables matching any of the given names or patterns\nwill be available as valid placeholders in the message template.",
          "default": "DRONE_*"
        },
        "password": {
          "type": "string",
          "description": "Password to use for authenticating the user set with `userid`.\n\nEither a password or an access token is required.",
          "required": true
        },
        "roomid": {
          "type": "string",
          "description": "ID of matrix chat room to send messages to (ID, not alias).",
          "required": true
        },
        "template": {
          "type": "string",
          "description": "The message template.\n\nValid placeholders (example: `${DRONE_REPO}`) will be substituted with the\nvalues of the matching environment variables (subject to filtering\naccording to the `pass_environment` setting).",
          "default": "${DRONE_BUILD_STATUS}"
        },
        "userid": {
          "type": "string",
          "description": "Matrix user ID to send message as (ID, not username).",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "melange",
    "spec": {
      "name": "Melange",
      "description": "Plugin to build apk from source code. Learn more about melange at https://github.com/chainguard-dev/melange.",
      "step": {
        "type": "script",
        "spec": {
          "image": "https://hub.docker.com/repository/docker/kameshsampath/melange-drone-plugin",
          "envs": {
            "PLUGIN_ARCHS": "<+ inputs.archs >",
            "PLUGIN_CONFIG_FILE": "<+ inputs.config_file >",
            "PLUGIN_ENV_FILE": "<+ inputs.env_file >",
            "PLUGIN_OUTPUT_DIR": "<+ inputs.output_dir >",
            "PLUGIN_SIGNING_KEY": "<+ inputs.signing_key >"
          }
        }
      },
      "inputs": {
        "archs": {
          "type": "array",
          "description": "`386`,`amd64`,`arm64`,`arm/v6`,`arm/v7`,`ppc64le`,`riscv64`,`s390x`",
          "default": "$(uname -m)"
        },
        "config_file": {
          "type": "string",
          "description": "The melange configuration YAML file, a path relative to drone pipeline. https://github.com/chainguard-dev/melange/blob/main/docs/BUILD-PROCESS.md#melangeyaml",
          "required": true
        },
        "env_file": {
          "type": "string",
          "description": "The environment file that will be preloaded and made available to build environment"
        },
        "output_dir": {
          "type": "string",
          "description": "The directory where the built packages will be saved",
          "default": "$DRONE_WORKSPACE/packages"
        },
        "signing_key": {
          "type": "string",
          "description": "The signing key that will be used to sign the package. If not provided it will be generated and set to `melange.rsa`",
          "default": "melange.rsa"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "metronome",
    "spec": {
      "name": "Metronome",
      "description": "This plugin can be used to deploy applications to a Metronome server, it will create\\update the given Metronome tasks as needed.",
      "step": {
        "type": "script",
        "spec": {
          "image": "naorlivne/drone-metronome",
          "envs": {
            "PLUGIN_METRONOME_HOST": "<+ inputs.metronome_host >",
            "PLUGIN_METRONOME_JOB_FILE": "<+ inputs.metronome_job_file >"
          }
        }
      },
      "inputs": {
        "metronome_host": {
          "type": "string",
          "description": "The Metronome server URL (no trailing slash should be used).",
          "default": "http://metronome.mesos:9000"
        },
        "metronome_job_file": {
          "type": "string",
          "description": "The Metronome configuration file location relative to the root folder of the repo.",
          "default": "metronome.json",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "mvn-auth",
    "spec": {
      "name": "Maven Auth",
      "description": "The Maven Auth plugin can be used for generating the settings.xml with server authentication for a Maven repository. Please note that dependencies are saved in the .m2 directory.",
      "step": {
        "type": "script",
        "spec": {
          "image": "robertstettner/drone-mvn-auth",
          "envs": {
            "PLUGIN_ACTIVE_PROFILES": "<+ inputs.active_profiles >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_PROFILES": "<+ inputs.profiles >",
            "PLUGIN_SERVERS": "<+ inputs.servers >"
          }
        }
      },
      "inputs": {
        "active_profiles": { "type": "array", "description": "The list of active profiles", "default": "[]" },
        "debug": { "type": "boolean", "description": "Enable debug mode", "default": "false" },
        "profiles": { "type": "array", "description": "The list of profiles", "default": "[]" },
        "servers": { "type": "array", "description": "The list of servers", "default": "[]" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "netlify",
    "spec": {
      "name": "Netlify",
      "description": "The netlify plugin deploy your build to netlify.",
      "step": {
        "type": "script",
        "spec": {
          "image": "lucap/drone-netlify",
          "envs": {
            "PLUGIN_DOMAIN": "<+ inputs.domain >",
            "PLUGIN_ENVIROMENT": "<+ inputs.enviroment >",
            "PLUGIN_PATH": "<+ inputs.path >",
            "PLUGIN_SITE_ID": "<+ inputs.site_id >",
            "PLUGIN_SITE_NAME": "<+ inputs.site_name >",
            "PLUGIN_TOKEN": "<+ inputs.token >"
          }
        }
      },
      "inputs": {
        "domain": { "type": "string", "description": "Set your custom domain." },
        "enviroment": { "type": "string", "description": "Set the Netlify environment." },
        "path": { "type": "string", "description": "Path to a folder or zip file to deploy." },
        "site_id": {
          "type": "string",
          "description": "Set the Site ID (or API ID in your Site settings dashboard).",
          "required": true
        },
        "site_name": { "type": "string", "description": "Set the Netlify subdomain." },
        "token": { "type": "string", "description": "The netlify token", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "newrelic-deployment",
    "spec": {
      "name": "Newrelic Deployment",
      "description": "The Newrelic deployment plugin reports/logs your deployment to your dashboard to make it easy to track changes.",
      "step": {
        "type": "script",
        "spec": {
          "image": "cityfurniture/drone-newrelic-deployment",
          "envs": { "PLUGIN_API_KEY": "<+ inputs.api_key >", "PLUGIN_APP_NAME": "<+ inputs.app_name >" }
        }
      },
      "inputs": {
        "api_key": { "type": "string", "description": "Your Newrelic API key.", "required": true },
        "app_name": { "type": "string", "description": "Your Newrelic application name.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "nomad",
    "spec": {
      "name": "Nomad",
      "description": "Use the Nomad plugin to deploy services from a template. You will need to supply Drone with the nomad template file.",
      "step": {
        "type": "script",
        "spec": {
          "image": "loq9/drone-nomad",
          "envs": {
            "PLUGIN_ADDR": "<+ inputs.addr >",
            "PLUGIN_NAMESPACE": "<+ inputs.namespace >",
            "PLUGIN_REGION": "<+ inputs.region >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >",
            "PLUGIN_TOKEN": "<+ inputs.token >"
          }
        }
      },
      "inputs": {
        "addr": { "type": "string", "description": "The Nomad server address", "required": true },
        "namespace": { "type": "string", "description": "Nomad namespace" },
        "region": { "type": "string", "description": "Nomad region" },
        "template": { "type": "string", "description": "Template for Nomad", "required": true },
        "token": { "type": "string", "description": "Nomad token" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "now",
    "spec": {
      "name": "Now",
      "description": "The Now plugin deploy your build to now.sh.",
      "step": {
        "type": "script",
        "spec": {
          "image": "lucap/drone-now",
          "envs": {
            "PLUGIN_ALIAS": "<+ inputs.alias >",
            "PLUGIN_CLEANUP": "<+ inputs.cleanup >",
            "PLUGIN_DEPLOY_NAME": "<+ inputs.deploy_name >",
            "PLUGIN_DIRECTORY": "<+ inputs.directory >",
            "PLUGIN_NOW_TOKEN": "<+ inputs.now_token >",
            "PLUGIN_RULES_DOMAIN": "<+ inputs.rules_domain >",
            "PLUGIN_RULES_FILE": "<+ inputs.rules_file >",
            "PLUGIN_SCALE": "<+ inputs.scale >",
            "PLUGIN_TEAM": "<+ inputs.team >",
            "PLUGIN_TYPE": "<+ inputs.type >"
          }
        }
      },
      "inputs": {
        "alias": { "type": "string", "description": "Target now.sh subdomain or domain" },
        "cleanup": { "type": "boolean", "description": "Equivalent to now rm --safe --yes $alias", "default": "false" },
        "deploy_name": { "type": "string", "description": "The deployment name", "default": "working directory" },
        "directory": { "type": "string", "description": "The directory to deploy" },
        "now_token": { "type": "string", "description": "The now.sh token", "required": true },
        "rules_domain": { "type": "string", "description": "Your domain" },
        "rules_file": { "type": "string", "description": "File that contain set of rules" },
        "scale": { "type": "string", "description": "Min and Max scaling values" },
        "team": { "type": "string", "description": "Set the team scope" },
        "type": { "type": "string", "description": "Deployment type (docker, npm, static)." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "npm-auth",
    "spec": {
      "name": "NPM Auth",
      "description": "This plugin is used to generate an .npmrc file locally to authenticate against any public/private NPM repository.",
      "step": {
        "type": "script",
        "spec": {
          "image": "robertstettner/drone-npm-auth",
          "envs": {
            "PLUGIN_EMAIL": "<+ inputs.email >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PATH": "<+ inputs.path >",
            "PLUGIN_REGISTRY": "<+ inputs.registry >",
            "PLUGIN_SCOPE": "<+ inputs.scope >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "email": { "type": "string", "description": "The NPM email", "required": true },
        "password": { "type": "string", "description": "The NPM password", "required": true },
        "path": { "type": "string", "description": "Output path of the generated .npmrc file.", "default": "./" },
        "registry": { "type": "string", "description": "The NPM registry", "default": "https://registry.npmjs.org" },
        "scope": { "type": "string", "description": "The NPM scope" },
        "username": { "type": "string", "description": "The NPM username", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "npm",
    "spec": {
      "name": "NPM",
      "description": "The NPM plugin can be used to publish libraries to public or private registries.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/npm",
          "envs": {
            "PLUGIN_ACCESS": "<+ inputs.access >",
            "PLUGIN_EMAIL": "<+ inputs.email >",
            "PLUGIN_FOLDER": "<+ inputs.folder >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_REGISTRY": "<+ inputs.registry >",
            "PLUGIN_TOKEN": "<+ inputs.token >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "access": { "type": "string", "description": "NPM scoped package access" },
        "email": { "type": "string", "description": "the email for the account to publish with" },
        "folder": {
          "type": "string",
          "description": "the folder, relative to the workspace, containing the library.",
          "default": "the workspace directory"
        },
        "password": {
          "type": "string",
          "description": "the password for the account to publish with",
          "required": true
        },
        "registry": {
          "type": "string",
          "description": "the registry to publish to",
          "default": "https://registry.npmjs.org"
        },
        "token": { "type": "string", "description": "the token for the account to publish with" },
        "username": {
          "type": "string",
          "description": "the username for the account to publish with",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "ntfy",
    "spec": {
      "name": "Ntfy",
      "description": "The Ntfy.sh plugin posts build status messages to your selected Ntfy server.",
      "step": {
        "type": "script",
        "spec": {
          "image": "parrazam/drone-ntfy",
          "envs": {
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PRIORITY": "<+ inputs.priority >",
            "PLUGIN_TAGS": "<+ inputs.tags >",
            "PLUGIN_TOKEN": "<+ inputs.token >",
            "PLUGIN_TOPIC": "<+ inputs.topic >",
            "PLUGIN_URL": "<+ inputs.url >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "password": { "type": "string", "description": "Password for username" },
        "priority": {
          "type": "string",
          "description": "Priority of the notification. Values can be [min, low, default, high, max]",
          "default": "default"
        },
        "tags": { "type": "string", "description": "Custom tags of the notification." },
        "token": { "type": "string", "description": "Token to publish/subscribe, instead to use username/password" },
        "topic": { "type": "string", "description": "Topic to publish message", "required": true },
        "url": { "type": "string", "description": "Ntfy server. If empty, default one will be https://ntfy.sh" },
        "username": { "type": "string", "description": "Username with publish permissions" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "openfaas",
    "spec": {
      "name": "OpenFaaS",
      "description": "This plugin can be used to build (generate Dockerfile and stuff) and Deploy functions to the OpenFaaS Gateway, and for the Docker image build & publish step, you can use the plugin for Kaniko or you favorite plugin.",
      "step": {
        "type": "script",
        "spec": {
          "image": "knovus/drone-openfaas",
          "envs": {
            "PLUGIN_DEPLOY": "<+ inputs.deploy >",
            "PLUGIN_IMAGE_NAME": "<+ inputs.image_name >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_REGISTRY": "<+ inputs.registry >",
            "PLUGIN_TAG": "<+ inputs.tag >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >",
            "PLUGIN_TLS_NO_VERIFY": "<+ inputs.tls_no_verify >",
            "PLUGIN_URL": "<+ inputs.url >",
            "PLUGIN_USERNAME": "<+ inputs.username >",
            "PLUGIN_YAML": "<+ inputs.yaml >"
          }
        }
      },
      "inputs": {
        "deploy": {
          "type": "boolean",
          "description": "set to true if you want to deploy the function.",
          "default": "false"
        },
        "image_name": {
          "type": "string",
          "description": "the docker image name published.",
          "default": "reads the parameter from yaml file"
        },
        "password": { "type": "string", "description": "the password to authenticate to the OpenFaaS Gateway." },
        "registry": { "type": "string", "description": "the registry where the Docker image is published." },
        "tag": {
          "type": "string",
          "description": "repository tag strategy for the function, based on OpenFaaS TAG.",
          "default": "set latest"
        },
        "template": {
          "type": "string",
          "description": "If you need to pull a OpenFaaS store template to build the function."
        },
        "tls_no_verify": {
          "type": "boolean",
          "description": "set to true if you setup don't have a valid tls certificate.",
          "default": "false"
        },
        "url": { "type": "string", "description": "authenticates and deploys to this OpenFaaS Gateway." },
        "username": { "type": "string", "description": "the username to authenticate to the OpenFaaS Gateway." },
        "yaml": {
          "type": "string",
          "description": "OpenFaaS function definition to be used. Optional.",
          "default": "reads stack.yml file"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "packer",
    "spec": {
      "name": "Packer",
      "description": "This plugin can build automated machine images with Packer.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-packer",
          "envs": {
            "PLUGIN_ACTIONS": "<+ inputs.actions >",
            "PLUGIN_COLOR": "<+ inputs.color >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_EXCEPT": "<+ inputs.except >",
            "PLUGIN_FORCE": "<+ inputs.force >",
            "PLUGIN_ONLY": "<+ inputs.only >",
            "PLUGIN_PARALLEL": "<+ inputs.parallel >",
            "PLUGIN_READABLE": "<+ inputs.readable >",
            "PLUGIN_SYNTAX_ONLY": "<+ inputs.syntax_only >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >",
            "PLUGIN_VARS": "<+ inputs.vars >",
            "PLUGIN_VAR_FILES": "<+ inputs.var_files >"
          }
        }
      },
      "inputs": {
        "actions": { "type": "array", "description": "a list of actions to have packer perform." },
        "color": { "type": "boolean", "description": "Disable color output.", "default": "false" },
        "debug": { "type": "boolean", "description": "Debug mode enabled for builds.", "default": "false" },
        "except": { "type": "array", "description": "validate or build all builds other than these." },
        "force": {
          "type": "boolean",
          "description": "Force a build to continue if artifacts exist, deletes existing artifacts.",
          "default": "false"
        },
        "only": { "type": "array", "description": "validate or build only the specified builds." },
        "parallel": { "type": "boolean", "description": "Disable parallelization.", "default": "false" },
        "readable": { "type": "boolean", "description": "Machine-readable output.", "default": "false" },
        "syntax_only": {
          "type": "boolean",
          "description": "Only check syntax. Do not verify config of the template.",
          "default": "false"
        },
        "template": {
          "type": "string",
          "description": "A json file will execute multiple builds in parallel as defined in the template."
        },
        "var_files": {
          "type": "array",
          "description": "a list of var files to use. Each value is passed as -var-file=."
        },
        "vars": {
          "type": "object",
          "description": "a map of variables to pass to the Packer build commands. Each value is passed as a <key>=<value> option."
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "plugin-fossa",
    "spec": {
      "name": "fossa",
      "description": "By default, this plugin will run the analyze command per the generic CI documentation for FOSSA.",
      "step": {
        "type": "script",
        "spec": {
          "image": "rancher/drone-fossa",
          "envs": { "PLUGIN_API_KEY": "<+ inputs.api_key >", "PLUGIN_DEBUG": "<+ inputs.debug >" }
        }
      },
      "inputs": {
        "api_key": { "type": "string", "description": "FOSSA API key.", "required": true },
        "debug": { "type": "boolean", "description": "Enable debug mode.", "default": "false" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "plugin-kube",
    "spec": {
      "name": "Kubernetes",
      "description": "Updates Kubernetes deployments from templates & configMaps from files. This plugin will either create or update existing resources dependent on their presence. It will wait for deployments before it progresses.",
      "step": {
        "type": "script",
        "spec": {
          "image": "danielgormly/drone-plugin-kube",
          "envs": {
            "PLUGIN_CA": "<+ inputs.ca >",
            "PLUGIN_CONFIGMAP_FILE": "<+ inputs.configmap_file >",
            "PLUGIN_KUBERNETES_TOKEN": "<+ inputs.kubernetes_token >",
            "PLUGIN_OTHER_PARAMETERS": "<+ inputs.Other_parameters >",
            "PLUGIN_SERVER": "<+ inputs.server >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >"
          }
        }
      },
      "inputs": {
        "Other_parameters": {
          "type": "string",
          "description": "Other parameters will be made available for interpolation within yaml templates (upper-case will be converted to lower-case)."
        },
        "ca": { "type": "string", "description": "Base-64 encoded string of the K8s CA cert." },
        "configmap_file": {
          "type": "string",
          "description": "path to file containing data to inject in configmap (They configmap key that contains the data will be the filename)."
        },
        "kubernetes_token": {
          "type": "string",
          "description": "Kubernetes service account token (Not base64 encoded).",
          "required": true
        },
        "server": {
          "type": "string",
          "description": "Full url of Kubernetes API endpoint including protocol & port.",
          "required": true
        },
        "template": {
          "type": "string",
          "description": "Path to Kubernetes yaml based definition file (Configmap or Deployment)."
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "pypi",
    "spec": {
      "name": "PyPI",
      "description": "This plugin allows you to publish Python pypi packages as part of your pipeline.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/pypi",
          "envs": {
            "PLUGIN_DISTRIBUTIONS": "<+ inputs.distributions >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_REPOSITORY": "<+ inputs.repository >",
            "PLUGIN_SETUPFILE": "<+ inputs.setupfile >",
            "PLUGIN_SKIP_BUILD": "<+ inputs.skip_build >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "distributions": {
          "type": "string",
          "description": "List of distribution types to publish.",
          "default": "only sdist"
        },
        "password": { "type": "string", "description": "Password to be used for the pypi publish.", "required": true },
        "repository": {
          "type": "string",
          "description": "The URL of the repository to be published to.",
          "default": "https://upload.pypi.org/legacy/"
        },
        "setupfile": {
          "type": "string",
          "description": "The relative path from the workspace root to the setup.py file to be used.",
          "default": "setup.py"
        },
        "skip_build": {
          "type": "boolean",
          "description": "Skip the build and only upload pre-build files from dist/*.",
          "default": "false"
        },
        "username": { "type": "string", "description": "Username to be used for the pypi publish.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "qodana-jvm-community-plugin",
    "spec": {
      "name": "Qodana JVM Community",
      "description": "This plugin allows you to run the Qodana JVM Community linter in Drone and publish the results to Qodana Cloud. The Community license is enough.",
      "step": {
        "type": "script",
        "spec": {
          "image": "2martens/qodana-jvm-community-drone-plugin",
          "envs": { "PLUGIN_ARGS": "<+ inputs.args >", "PLUGIN_QODANA_TOKEN": "<+ inputs.qodana_token >" }
        }
      },
      "inputs": {
        "args": {
          "type": "string",
          "description": "Arguments passed to Qodana command. For example --baseline or --failure-threshold",
          "required": true
        },
        "qodana_token": {
          "type": "string",
          "description": "Qodana token used to publish analysis results to Qodana cloud.",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "rancher-stack-v1",
    "spec": {
      "name": "Rancher Stack v1",
      "description": "A drone.io Rancher Stack plugin to deploy/update an entire Rancher stack (not just a single service) to Rancher v1.6. See Docker Hub for more information.",
      "step": {
        "type": "script",
        "spec": {
          "image": "dubc/drone-rancher-stack-v1",
          "envs": {
            "PLUGIN_ACCESSKEY": "<+ inputs.accesskey >",
            "PLUGIN_PULL": "<+ inputs.pull >",
            "PLUGIN_SECRETKEY": "<+ inputs.secretkey >",
            "PLUGIN_STACK": "<+ inputs.stack >",
            "PLUGIN_URL": "<+ inputs.url >"
          }
        }
      },
      "inputs": {
        "accesskey": {
          "type": "string",
          "description": "The access key for your rancher environment.",
          "required": true
        },
        "pull": {
          "type": "boolean",
          "description": "Makes sure you get the latest plugin version.",
          "default": "true"
        },
        "secretkey": {
          "type": "string",
          "description": "The secret key for your rancher environment.",
          "required": true
        },
        "stack": {
          "type": "string",
          "description": "This stack must already exist in your rancher environment. E.g app-staging.",
          "required": true
        },
        "url": {
          "type": "string",
          "description": "The url where your rancher resides. E.g rancher.domain.com",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "rancher",
    "spec": {
      "name": "Rancher",
      "description": "The Rancher plugin can be used to deploy a Docker image to a Rancher environment.",
      "step": {
        "type": "script",
        "spec": {
          "image": "pelotech/drone-rancher",
          "envs": {
            "PLUGIN_ACCESS_KEY": "<+ inputs.access_key >",
            "PLUGIN_BATCH_SIZE": "<+ inputs.batch_size >",
            "PLUGIN_CONFIRM": "<+ inputs.confirm >",
            "PLUGIN_DOCKER_IMAGE": "<+ inputs.docker_image >",
            "PLUGIN_INTERVAL_MILLIS": "<+ inputs.interval_millis >",
            "PLUGIN_SECRET_KEY": "<+ inputs.secret_key >",
            "PLUGIN_SERVICE": "<+ inputs.service >",
            "PLUGIN_START_FIRST": "<+ inputs.start_first >",
            "PLUGIN_TIMEOUT": "<+ inputs.timeout >",
            "PLUGIN_URL": "<+ inputs.url >"
          }
        }
      },
      "inputs": {
        "access_key": {
          "type": "string",
          "description": "the access key for the rancher environment",
          "required": true
        },
        "batch_size": { "type": "number", "description": "number of containers to upgrade in one batch" },
        "confirm": {
          "type": "boolean",
          "description": "auto confirm the service upgrade if successful.",
          "default": "false"
        },
        "docker_image": {
          "type": "string",
          "description": "docker image to use to upgrade the environment",
          "required": true
        },
        "interval_millis": {
          "type": "number",
          "description": "interval in milliseconds between upgrades of the containers"
        },
        "secret_key": {
          "type": "string",
          "description": "the secret key for the rancher environment",
          "required": true
        },
        "service": {
          "type": "string",
          "description": "rancher service on that environment to upgrade",
          "required": true
        },
        "start_first": {
          "type": "boolean",
          "description": "start new container before stopping old one.",
          "default": "true"
        },
        "timeout": {
          "type": "number",
          "description": "the maximum wait time in seconds for the service to upgrade.",
          "default": "30"
        },
        "url": { "type": "string", "description": "the url of the rancher server", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "rds-snapper",
    "spec": {
      "name": "AWS RDS Snapper",
      "description": "The rds-snapper plugin cleans up specific RDS instance's snapshots, keeps specified number of copies and creates new snapshots.",
      "step": {
        "type": "script",
        "spec": {
          "image": "quay.io/honestbee/rds-snapper",
          "envs": {
            "PLUGIN_ACTION": "<+ inputs.action >",
            "PLUGIN_AWS_ACCESS_KEY": "<+ inputs.aws_access_key >",
            "PLUGIN_AWS_REGION": "<+ inputs.aws_region >",
            "PLUGIN_AWS_SECRET_KEY": "<+ inputs.aws_secret_key >",
            "PLUGIN_DBNAME": "<+ inputs.dbname >",
            "PLUGIN_KEEP": "<+ inputs.keep >",
            "PLUGIN_SUFFIX": "<+ inputs.suffix >"
          }
        }
      },
      "inputs": {
        "action": {
          "type": "string",
          "description": "choose which features to execute (clear|create|export)",
          "required": true
        },
        "aws_access_key": { "type": "string", "description": "AWS access key", "required": true },
        "aws_region": {
          "type": "string",
          "description": "bucket region (us-east-1, eu-west-1, etc)",
          "required": true
        },
        "aws_secret_key": { "type": "string", "description": "AWS secret key", "required": true },
        "dbname": { "type": "string", "description": "rds instance's name" },
        "keep": { "type": "number", "description": "number of snapshots to keep", "default": "5" },
        "suffix": { "type": "string", "description": "snapshot's name suffix.", "default": "randomly generated" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "rocket",
    "spec": {
      "name": "Rocket.Chat",
      "description": "Drone plugin for sending message to Rocket.Chant channel using API.",
      "step": {
        "type": "script",
        "spec": {
          "image": "mike1pol/drone-rocket",
          "envs": {
            "PLUGIN_AVATAR_URL": "<+ inputs.avatar_url >",
            "PLUGIN_CHANNEL": "<+ inputs.channel >",
            "PLUGIN_MESSAGE": "<+ inputs.message >",
            "PLUGIN_TOKEN": "<+ inputs.token >",
            "PLUGIN_URL": "<+ inputs.url >",
            "PLUGIN_USER_ID": "<+ inputs.user_id >"
          }
        }
      },
      "inputs": {
        "avatar_url": { "type": "string", "description": "override the default avatar of the user" },
        "channel": { "type": "string", "description": "Rocket.chat channel", "required": true },
        "message": {
          "type": "string",
          "description": "the message contents (up to 2000 characters)",
          "required": true
        },
        "token": { "type": "string", "description": "Rocket.chat token", "required": true },
        "url": { "type": "string", "description": "Rocket.chat url", "required": true },
        "user_id": { "type": "string", "description": "Rocket.chat user id", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "rsync",
    "spec": {
      "name": "rsync",
      "description": "The rsync plugin can be used to transfer files to remote machines, and run a user-defined script afterwards.",
      "step": {
        "type": "script",
        "spec": {
          "image": "drillster/drone-rsync",
          "envs": {
            "PLUGIN_ARGS": "<+ inputs.args >",
            "PLUGIN_DELETE": "<+ inputs.delete >",
            "PLUGIN_EXCLUDE": "<+ inputs.exclude >",
            "PLUGIN_HOSTS": "<+ inputs.hosts >",
            "PLUGIN_INCLUDE": "<+ inputs.include >",
            "PLUGIN_KEY": "<+ inputs.key >",
            "PLUGIN_PORT": "<+ inputs.port >",
            "PLUGIN_PRESCRIPT": "<+ inputs.prescript >",
            "PLUGIN_RECURSIVE": "<+ inputs.recursive >",
            "PLUGIN_SCRIPT": "<+ inputs.script >",
            "PLUGIN_SOURCE": "<+ inputs.source >",
            "PLUGIN_TARGET": "<+ inputs.target >",
            "PLUGIN_USER": "<+ inputs.user >"
          }
        }
      },
      "inputs": {
        "args": {
          "type": "string",
          "description": "instruct plugin to use these additional rsync CLI arguments, e.g. \"--blocking-io\""
        },
        "delete": {
          "type": "boolean",
          "description": "instruct plugin to delete the target folder before copying",
          "default": "false"
        },
        "exclude": { "type": "array", "description": "rsync exclude filter", "default": "[]" },
        "hosts": {
          "type": "array",
          "description": "list of hosts (remote machines)",
          "default": "[]",
          "required": true
        },
        "include": { "type": "array", "description": "rsync include filter", "default": "[]" },
        "key": { "type": "string", "description": "private SSH key for the remote machines" },
        "port": { "type": "number", "description": "port to connect to on the remote machines", "default": "22" },
        "prescript": {
          "type": "array",
          "description": "list of commands to execute on remote machines before rsync occurs",
          "default": "[]"
        },
        "recursive": { "type": "boolean", "description": "instruct plugin to recursively copy", "default": "false" },
        "script": {
          "type": "array",
          "description": "list of commands to execute on remote machines over SSH after rsync occurs",
          "default": "[]"
        },
        "source": { "type": "string", "description": "source folder to copy from", "default": "./" },
        "target": { "type": "string", "description": "target folder on remote machines to copy to" },
        "user": { "type": "string", "description": "user to connect as on the remote machines", "default": "root" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "s3-cache",
    "spec": {
      "name": "AWS S3 Cache",
      "description": "The S3 cache plugin can be used to preserve files and directories between builds.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/s3-cache",
          "envs": {
            "PLUGIN_ACCESS_KEY": "<+ inputs.access_key >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_ENDPOINT": "<+ inputs.endpoint >",
            "PLUGIN_FALLBACK_PATH": "<+ inputs.fallback_path >",
            "PLUGIN_FILENAME": "<+ inputs.filename >",
            "PLUGIN_FLUSH": "<+ inputs.flush >",
            "PLUGIN_FLUSH_AGE": "<+ inputs.flush_age >",
            "PLUGIN_FLUSH_PATH": "<+ inputs.flush_path >",
            "PLUGIN_MOUNT": "<+ inputs.mount >",
            "PLUGIN_PATH": "<+ inputs.path >",
            "PLUGIN_REBUILD": "<+ inputs.rebuild >",
            "PLUGIN_RESTORE": "<+ inputs.restore >",
            "PLUGIN_ROOT": "<+ inputs.root >",
            "PLUGIN_SECRET_KEY": "<+ inputs.secret_key >",
            "PLUGIN_WORKDIR": "<+ inputs.workdir >"
          }
        }
      },
      "inputs": {
        "access_key": { "type": "string", "description": "amazon access key" },
        "debug": { "type": "boolean", "description": "enable debug logging", "default": "false" },
        "endpoint": {
          "type": "string",
          "description": "custom endpoint URL (optional, to use a S3 compatible non-Amazon service)"
        },
        "fallback_path": {
          "type": "string",
          "description": "fallback path for the cache file",
          "default": "[root]/<owner>/<repo>/<branch>/"
        },
        "filename": { "type": "string", "description": "filename for the cache" },
        "flush": {
          "type": "boolean",
          "description": "mode to flush the cache of old cache items (please be sure to set this so we don't waste storage)",
          "default": "false"
        },
        "flush_age": { "type": "number", "description": "flush cache files older then x days", "default": "30" },
        "flush_path": {
          "type": "string",
          "description": "path to search for flushable cache files.",
          "default": "[root]/<owner>/<repo>/"
        },
        "mount": { "type": "array", "description": "list of files/directories to cache", "default": "[]" },
        "path": {
          "type": "string",
          "description": "path to store the cache file",
          "default": "[root]/<owner>/<repo>/<branch>/"
        },
        "rebuild": {
          "type": "boolean",
          "description": "mode to rebuild the cache from the build environment and specified mounts",
          "default": "false"
        },
        "restore": {
          "type": "boolean",
          "description": "mode to restore the build environment from cache",
          "default": "false"
        },
        "root": {
          "type": "string",
          "description": "root path prefix for all cache default paths (path, fallback_path, and flush_path).",
          "default": "/"
        },
        "secret_key": { "type": "string", "description": "amazon secret key" },
        "workdir": { "type": "string", "description": "path where to restore the cache files to." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "s3-sync",
    "spec": {
      "name": "AWS S3 Sync",
      "description": "The S3 sync synchronizes files and build artifacts to your S3 bucket.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/s3-sync",
          "envs": {
            "PLUGIN_ACCESS_KEY": "<+ inputs.access_key >",
            "PLUGIN_ACL": "<+ inputs.acl >",
            "PLUGIN_BUCKET": "<+ inputs.bucket >",
            "PLUGIN_CACHE_CONTROL": "<+ inputs.cache_control >",
            "PLUGIN_CLOUDFRONT_DISTRIBUTION": "<+ inputs.cloudfront_distribution >",
            "PLUGIN_CONTENT_ENCODING": "<+ inputs.content_encoding >",
            "PLUGIN_CONTENT_TYPE": "<+ inputs.content_type >",
            "PLUGIN_DELETE": "<+ inputs.delete >",
            "PLUGIN_DRY_RUN": "<+ inputs.dry_run >",
            "PLUGIN_METADATA": "<+ inputs.metadata >",
            "PLUGIN_REDIRECTS": "<+ inputs.redirects >",
            "PLUGIN_REGION": "<+ inputs.region >",
            "PLUGIN_SECRET_KEY": "<+ inputs.secret_key >",
            "PLUGIN_SOURCE": "<+ inputs.source >",
            "PLUGIN_TARGET": "<+ inputs.target >"
          }
        }
      },
      "inputs": {
        "access_key": { "type": "string", "description": "AWS access key." },
        "acl": { "type": "string", "description": "ACL for files." },
        "bucket": { "type": "string", "description": "S3 bucket name.", "required": true },
        "cache_control": { "type": "string", "description": "Cache control for files." },
        "cloudfront_distribution": { "type": "string", "description": "Cloudfront distribution ID." },
        "content_encoding": { "type": "string", "description": "Content encoding for files." },
        "content_type": { "type": "string", "description": "Content type for files." },
        "delete": { "type": "boolean", "description": "Delete files after sync.", "default": "false" },
        "dry_run": { "type": "boolean", "description": "Dry run.", "default": "false" },
        "metadata": { "type": "string", "description": "Additional Metadata for files." },
        "redirects": { "type": "string", "description": "Redirects to create." },
        "region": { "type": "string", "description": "S3 region.", "default": "us-east-1" },
        "secret_key": { "type": "string", "description": "AWS secret key." },
        "source": { "type": "string", "description": "Source folder to archive.", "default": "." },
        "target": { "type": "string", "description": "Target location.", "default": "/" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "s3",
    "spec": {
      "name": "AWS S3",
      "description": "The S3 plugin uploads files and build artifacts to your S3 bucket, or S3-compatible bucket such as Minio.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/s3",
          "envs": {
            "PLUGIN_ACCESS_KEY": "<+ inputs.access_key >",
            "PLUGIN_ACL": "<+ inputs.acl >",
            "PLUGIN_BUCKET": "<+ inputs.bucket >",
            "PLUGIN_ENCRYPTION": "<+ inputs.encryption >",
            "PLUGIN_ENDPOINT": "<+ inputs.endpoint >",
            "PLUGIN_EXCLUDE": "<+ inputs.exclude >",
            "PLUGIN_PATH_STYLE": "<+ inputs.path_style >",
            "PLUGIN_REGION": "<+ inputs.region >",
            "PLUGIN_SECRET_KEY": "<+ inputs.secret_key >",
            "PLUGIN_SOURCE": "<+ inputs.source >",
            "PLUGIN_STRIP_PREFIX": "<+ inputs.strip_prefix >",
            "PLUGIN_TARGET": "<+ inputs.target >"
          }
        }
      },
      "inputs": {
        "access_key": { "type": "string", "description": "amazon key" },
        "acl": { "type": "string", "description": "bucket acl (public-read, private, etc)" },
        "bucket": { "type": "string", "description": "bucket name", "required": true },
        "encryption": { "type": "string", "description": "if provided, use server-side encryption" },
        "endpoint": {
          "type": "string",
          "description": "custom endpoint URL (optional, to use a S3 compatible non-Amazon service)"
        },
        "exclude": { "type": "string", "description": "glob exclusion patterns" },
        "path_style": {
          "type": "boolean",
          "description": "whether path style URLs should be used (true for minio)",
          "default": "false"
        },
        "region": { "type": "string", "description": "bucket region (us-east-1, eu-west-1, etc)" },
        "secret_key": { "type": "string", "description": "amazon secret" },
        "source": {
          "type": "string",
          "description": "source location of the files, using a glob matching pattern. Location must be within the drone workspace.",
          "required": true
        },
        "strip_prefix": { "type": "string", "description": "strip the prefix from source path" },
        "target": { "type": "string", "description": "target location of files in the bucket.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "scp",
    "spec": {
      "name": "SCP",
      "description": "The SCP plugin copy files and artifacts to target host machine via SSH.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-scp",
          "envs": {
            "PLUGIN_COMMAND_TIMEOUT": "<+ inputs.command_timeout >",
            "PLUGIN_HOST": "<+ inputs.host >",
            "PLUGIN_KEY": "<+ inputs.key >",
            "PLUGIN_OVERWRITE": "<+ inputs.overwrite >",
            "PLUGIN_PASSPHRASE": "<+ inputs.passphrase >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PORT": "<+ inputs.port >",
            "PLUGIN_PROXY_HOST": "<+ inputs.proxy_host >",
            "PLUGIN_PROXY_KEY": "<+ inputs.proxy_key >",
            "PLUGIN_PROXY_KEY_PASSPHRASE": "<+ inputs.proxy_key_passphrase >",
            "PLUGIN_PROXY_KEY_PATH": "<+ inputs.proxy_key_path >",
            "PLUGIN_PROXY_PASSWORD": "<+ inputs.proxy_password >",
            "PLUGIN_PROXY_PORT": "<+ inputs.proxy_port >",
            "PLUGIN_PROXY_USERNAME": "<+ inputs.proxy_username >",
            "PLUGIN_RM": "<+ inputs.rm >",
            "PLUGIN_SOURCE": "<+ inputs.source >",
            "PLUGIN_STRIP_COMPONENTS": "<+ inputs.strip_components >",
            "PLUGIN_TARGET": "<+ inputs.target >",
            "PLUGIN_TAR_EXEC": "<+ inputs.tar_exec >",
            "PLUGIN_TAR_TMP_PATH": "<+ inputs.tar_tmp_path >",
            "PLUGIN_TIMEOUT": "<+ inputs.timeout >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "command_timeout": { "type": "number", "description": "Timeout in minutes.", "default": "10" },
        "host": { "type": "string", "description": "Target host machine.", "required": true },
        "key": { "type": "string", "description": "Target host machine private key." },
        "overwrite": { "type": "boolean", "description": "Overwrite target file if exists.", "default": "false" },
        "passphrase": { "type": "string", "description": "Target host machine private key passphrase." },
        "password": { "type": "string", "description": "Target host machine password.", "required": true },
        "port": { "type": "number", "description": "Target host machine port.", "default": "22" },
        "proxy_host": { "type": "string", "description": "Proxy host." },
        "proxy_key": { "type": "string", "description": "Proxy private key." },
        "proxy_key_passphrase": { "type": "string", "description": "Proxy private key passphrase." },
        "proxy_key_path": { "type": "string", "description": "Proxy private key path." },
        "proxy_password": { "type": "string", "description": "Proxy password." },
        "proxy_port": { "type": "number", "description": "Proxy port.", "default": "0" },
        "proxy_username": { "type": "string", "description": "Proxy username." },
        "rm": { "type": "boolean", "description": "Remove source file after copy.", "default": "false" },
        "source": { "type": "string", "description": "Source file path.", "required": true },
        "strip_components": {
          "type": "number",
          "description": "Strip components from the target path.",
          "default": "0"
        },
        "tar_exec": { "type": "string", "description": "Tar command." },
        "tar_tmp_path": { "type": "string", "description": "Temporary path for tar." },
        "target": { "type": "string", "description": "Target host machine path.", "required": true },
        "timeout": { "type": "number", "description": "Timeout in seconds.", "default": "30" },
        "username": { "type": "string", "description": "Target host machine username.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "serverchan",
    "spec": {
      "name": "ServerChan(Server酱)",
      "description": "The ServerChan plugin posts build status messages to your account.",
      "step": {
        "type": "script",
        "spec": {
          "image": "yakumioto/drone-serverchan",
          "envs": {
            "PLUGIN_DESP": "<+ inputs.desp >",
            "PLUGIN_KEY": "<+ inputs.key >",
            "PLUGIN_TEXT": "<+ inputs.text >"
          }
        }
      },
      "inputs": {
        "desp": { "type": "string", "description": "Message description." },
        "key": { "type": "string", "description": "ServerChan key.", "required": true },
        "text": { "type": "string", "description": "Notification title", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "sftp-cache",
    "spec": {
      "name": "SFTP Cache",
      "description": "Use this plugin for caching build artifacts to speed up your build times. This plugin can create and restore caches of any folders.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-sftp-cache",
          "envs": {
            "PLUGIN_IGNORE_BRANCH": "<+ inputs.ignore_branch >",
            "PLUGIN_KEY": "<+ inputs.key >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PORT": "<+ inputs.port >",
            "PLUGIN_REBUILD": "<+ inputs.rebuild >",
            "PLUGIN_RESTOE": "<+ inputs.restoe >",
            "PLUGIN_SERVER": "<+ inputs.server >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "ignore_branch": { "type": "boolean", "description": "flag to ignore commit branch name on hash value" },
        "key": { "type": "string", "description": "plain text of user private key" },
        "password": { "type": "string", "description": "password for target host user" },
        "port": { "type": "string", "description": "ssh port of target host" },
        "rebuild": { "type": "boolean", "description": "flag to trigger a rebuild" },
        "restoe": { "type": "boolean", "description": "flag to trigger a restore" },
        "server": { "type": "string", "description": "target hostname or IP", "required": true },
        "username": { "type": "string", "description": "account for target host user" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "slack-blame",
    "spec": {
      "name": "Slack Blame",
      "description": "Use the Slack Blame plugin to send a message to a Slack channel or through direct message when a build completes. You will need to supply Drone with an access token to the Slack API. You can create a new access token at [https://api.slack.com/web](https://api.slack.com/web).",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/slack-blame",
          "envs": {
            "PLUGIN_CHANNEL": "<+ inputs.channel >",
            "PLUGIN_FAILURE_ICON": "<+ inputs.failure_icon >",
            "PLUGIN_FAILURE_IMAGE_ATTACHMENTS": "<+ inputs.failure_image_attachments >",
            "PLUGIN_FAILURE_TEMPLATE": "<+ inputs.failure_template >",
            "PLUGIN_FAILURE_USERNAME": "<+ inputs.failure_username >",
            "PLUGIN_MAPPING": "<+ inputs.mapping >",
            "PLUGIN_SUCCESS_ICON": "<+ inputs.success_icon >",
            "PLUGIN_SUCCESS_IMAGE_ATTACHMENTS": "<+ inputs.success_image_attachments >",
            "PLUGIN_SUCCESS_TEMPLATE": "<+ inputs.success_template >",
            "PLUGIN_SUCCESS_USERNAME": "<+ inputs.success_username >",
            "PLUGIN_TOKEN": "<+ inputs.token >"
          }
        }
      },
      "inputs": {
        "channel": { "type": "string", "description": "Slack channel." },
        "failure_icon": { "type": "string", "description": "Icon for failed builds." },
        "failure_image_attachments": { "type": "array", "description": "List of image attachments for failed builds." },
        "failure_template": { "type": "string", "description": "Template for failed builds." },
        "failure_username": { "type": "string", "description": "Username for failed builds." },
        "mapping": {
          "type": "array",
          "description": "Mapping of authors to Slack users. Supports environment variable interpolation, e.g. {\"$DRONE_COMMIT_AUTHOR\": \"$SLACK_USER\"}."
        },
        "success_icon": { "type": "string", "description": "Icon for successful builds." },
        "success_image_attachments": {
          "type": "array",
          "description": "List of image attachments for successful builds."
        },
        "success_template": { "type": "string", "description": "Template for successful builds." },
        "success_username": { "type": "string", "description": "Username for successful builds." },
        "token": { "type": "string", "description": "Slack access token.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "slack",
    "spec": {
      "name": "Slack",
      "description": "The Slack plugin posts build status messages to your channel.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/slack",
          "envs": {
            "PLUGIN_CHANNEL": "<+ inputs.channel >",
            "PLUGIN_ICON_EMOJI": "<+ inputs.icon_emoji >",
            "PLUGIN_ICON_URL": "<+ inputs.icon_url >",
            "PLUGIN_IMAGE_URL": "<+ inputs.image_url >",
            "PLUGIN_LINK_NAMES": "<+ inputs.link_names >",
            "PLUGIN_RECIPIENT": "<+ inputs.recipient >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >",
            "PLUGIN_USERNAME": "<+ inputs.username >",
            "PLUGIN_WEBHOOK": "<+ inputs.webhook >"
          }
        }
      },
      "inputs": {
        "channel": {
          "type": "string",
          "description": "messages sent to the above webhook are posted here",
          "default": "false"
        },
        "icon_emoji": {
          "type": "string",
          "description": "displays a emoji to the left of the username",
          "default": "false"
        },
        "icon_url": {
          "type": "string",
          "description": "a valid URL that displays a image to the left of the username",
          "default": "false"
        },
        "image_url": {
          "type": "string",
          "description": "a valid URL to an image file that will be displayed inside a message attachment",
          "default": "false"
        },
        "link_names": {
          "type": "string",
          "description": "links usernames and channels in the message",
          "default": "false"
        },
        "recipient": {
          "type": "string",
          "description": "alternatively you can send it to a specific user",
          "default": "false"
        },
        "template": { "type": "string", "description": "overwrite the default message template", "default": "false" },
        "username": {
          "type": "string",
          "description": "choose the username this integration will post as",
          "default": "false"
        },
        "webhook": {
          "type": "string",
          "description": "incoming webhook url for posting to a channel",
          "default": "false",
          "required": true
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "snyk",
    "spec": {
      "name": "Snyk",
      "description": "A plugin to scan container images for vulnerabilities using Snyk.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/drone-snyk",
          "envs": {
            "PLUGIN_DOCKERFILE": "<+ inputs.dockerfile >",
            "PLUGIN_FAIL_ON_ISSUES": "<+ inputs.fail_on_issues >",
            "PLUGIN_IMAGE": "<+ inputs.image >",
            "PLUGIN_SEVERITY_THRESHOLD": "<+ inputs.severity_threshold >",
            "PLUGIN_SNYK": "<+ inputs.snyk >"
          }
        }
      },
      "inputs": {
        "dockerfile": { "type": "string", "description": "Path to the Dockerfile to use." },
        "fail_on_issues": { "type": "boolean", "description": "Fail build if issues are found.", "default": "false" },
        "image": { "type": "string", "description": "Name of the image to scan.", "required": true },
        "severity_threshold": { "type": "string", "description": "Severity threshold." },
        "snyk": { "type": "string", "description": "Snyk token." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "sonar-node-plugin",
    "spec": {
      "name": "SonarScanner",
      "description": "This plugin enable code analysis with different versions of NodeJS (via nvm) and  post the analysis report to your SonarQube server.  SonarQube is an open source code quality management platform.",
      "step": {
        "type": "script",
        "spec": {
          "image": "kytay/sonar-node-plugin",
          "envs": {
            "PLUGIN_SONAR_DEBUG": "<+ inputs.sonar_debug >",
            "PLUGIN_SONAR_HOST": "<+ inputs.sonar_host >",
            "PLUGIN_SONAR_LOGIN": "<+ inputs.sonar_login >",
            "PLUGIN_SONAR_LOGLEVEL": "<+ inputs.sonar_loglevel >",
            "PLUGIN_SONAR_PASSWORD": "<+ inputs.sonar_password >",
            "PLUGIN_SONAR_PROJECT_SETTINGS": "<+ inputs.sonar_project_settings >",
            "PLUGIN_SONAR_TOKEN": "<+ inputs.sonar_token >",
            "PLUGIN_USE_NODE_VERSION": "<+ inputs.use_node_version >"
          }
        }
      },
      "inputs": {
        "sonar_debug": {
          "type": "boolean",
          "description": "Enable debug flag for additional information logging",
          "default": "false"
        },
        "sonar_host": { "type": "string", "description": "Hostname of the sonar server.", "required": true },
        "sonar_login": {
          "type": "string",
          "description": "This is the login of a SonarQube user with either Execute Analysis permission on the project or Global Execute Analysis permission. Using authentication token is encouraged for security reasons. Refer to https://docs.sonarqube.org/latest/user-guide/user-token/"
        },
        "sonar_loglevel": {
          "type": "string",
          "description": "Control the quantity / level of logs produced during an analysis.",
          "default": "INFO"
        },
        "sonar_password": {
          "type": "string",
          "description": "This is the password that goes with your sonar_login username. Using authentication token is encouraged for security reasons. Refer to https://docs.sonarqube.org/latest/user-guide/user-token/"
        },
        "sonar_project_settings": {
          "type": "string",
          "description": "Specify the path to the project configuration file."
        },
        "sonar_token": {
          "type": "string",
          "description": "The authentication token with either Execute Analysis permission on the project or Global Execute Analysis permission. sonar_login and sonar_password are ignored, when authentication token is provided."
        },
        "use_node_version": {
          "type": "string",
          "description": "Specify the node version to use for sonar-scanner, the most recent node LTS version will be selected if this variable is not specified. Example Values: 16, 16.18.1, v16, v16.18.1"
        }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "sonar-plugin",
    "spec": {
      "name": "SonarQube",
      "description": "This plugin can scan your code quality and post the analysis report to your SonarQube server. SonarQube (previously called Sonar), is an open source code quality management platform.",
      "step": {
        "type": "script",
        "spec": {
          "image": "aosapps/drone-sonar-plugin",
          "envs": { "PLUGIN_SONAR_HOST": "<+ inputs.sonar_host >", "PLUGIN_SONAR_TOKEN": "<+ inputs.sonar_token >" }
        }
      },
      "inputs": {
        "sonar_host": { "type": "string", "description": "Hostname of the sonar server.", "required": true },
        "sonar_token": { "type": "string", "description": "Access token.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "ssh",
    "spec": {
      "name": "SSH",
      "description": "Use the SSH plugin to execute commands on a remote server.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-ssh",
          "envs": {
            "PLUGIN_COMMAND_TIMEOUT": "<+ inputs.command_timeout >",
            "PLUGIN_ENVS": "<+ inputs.envs >",
            "PLUGIN_HOST": "<+ inputs.host >",
            "PLUGIN_KEY": "<+ inputs.key >",
            "PLUGIN_KEY_PATH": "<+ inputs.key_path >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_PORT": "<+ inputs.port >",
            "PLUGIN_PROXY_HOST": "<+ inputs.proxy_host >",
            "PLUGIN_PROXY_KEY": "<+ inputs.proxy_key >",
            "PLUGIN_PROXY_KEY_PATH": "<+ inputs.proxy_key_path >",
            "PLUGIN_PROXY_PASSWORD": "<+ inputs.proxy_password >",
            "PLUGIN_PROXY_PORT": "<+ inputs.proxy_port >",
            "PLUGIN_PROXY_USERNAME": "<+ inputs.proxy_username >",
            "PLUGIN_SCRIPT": "<+ inputs.script >",
            "PLUGIN_SCRIPT_STOP": "<+ inputs.script_stop >",
            "PLUGIN_TIMEOUT": "<+ inputs.timeout >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "command_timeout": {
          "type": "string",
          "description": "Command timeout is the maximum amount of time for the execute commands",
          "default": "10m"
        },
        "envs": {
          "type": "array",
          "description": "custom secrets which are made available in the script section.",
          "default": "[]"
        },
        "host": { "type": "string", "description": "Hostname or IP address of the server.", "required": true },
        "key": { "type": "string", "description": "plain text of user private key" },
        "key_path": { "type": "string", "description": "Path to the private key to login to the server." },
        "password": { "type": "string", "description": "Password to login to the server." },
        "port": { "type": "string", "description": "Port of the server.", "default": "22" },
        "proxy_host": { "type": "string", "description": "Proxy hostname or IP address." },
        "proxy_key": { "type": "string", "description": "lain text of proxy private key." },
        "proxy_key_path": { "type": "string", "description": "Path to the private key to login to the proxy." },
        "proxy_password": { "type": "string", "description": "Proxy password." },
        "proxy_port": { "type": "string", "description": "Proxy port." },
        "proxy_username": { "type": "string", "description": "Proxy username." },
        "script": { "type": "string", "description": "Command to execute on the server." },
        "script_stop": { "type": "boolean", "description": "stop script after first failure.", "default": "false" },
        "timeout": {
          "type": "string",
          "description": "Timeout is the maximum amount of time for the ssh connection to establish.",
          "default": "30s"
        },
        "username": { "type": "string", "description": "account for target host user." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "telegram",
    "spec": {
      "name": "Telegram",
      "description": "The Telegram plugin posts build status messages to your account.",
      "step": {
        "type": "script",
        "spec": {
          "image": "appleboy/drone-telegram",
          "envs": {
            "PLUGIN_AUDIO": "<+ inputs.audio >",
            "PLUGIN_DOCUMENT": "<+ inputs.document >",
            "PLUGIN_FORMAT": "<+ inputs.format >",
            "PLUGIN_LOCATION": "<+ inputs.location >",
            "PLUGIN_MESSAGE": "<+ inputs.message >",
            "PLUGIN_PHOTO": "<+ inputs.photo >",
            "PLUGIN_STICKER": "<+ inputs.sticker >",
            "PLUGIN_TO": "<+ inputs.to >",
            "PLUGIN_TOKEN": "<+ inputs.token >",
            "PLUGIN_VENUE": "<+ inputs.venue >",
            "PLUGIN_VIDEO": "<+ inputs.video >",
            "PLUGIN_VOICE": "<+ inputs.voice >"
          }
        }
      },
      "inputs": {
        "audio": { "type": "string", "description": "local file path" },
        "document": { "type": "string", "description": "local file path" },
        "format": { "type": "string", "description": "markdown or html format" },
        "location": { "type": "string", "description": "local file path" },
        "message": { "type": "string", "description": "overwrite the default message template" },
        "photo": { "type": "string", "description": "local file path" },
        "sticker": { "type": "string", "description": "local file path" },
        "to": {
          "type": "string",
          "description": "telegram user id (can be requested from the @userinfobot inside Telegram)",
          "required": true
        },
        "token": { "type": "string", "description": "telegram token from telegram developer center", "required": true },
        "venue": { "type": "string", "description": "local file path" },
        "video": { "type": "string", "description": "local file path" },
        "voice": { "type": "string", "description": "local file path" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "terraform",
    "spec": {
      "name": "Terraform",
      "description": "The Terraform plugin applies the infrastructure configuration contained within the repository.",
      "step": {
        "type": "script",
        "spec": {
          "image": "jmccann/drone-terraform",
          "envs": {
            "PLUGIN_CA_CERT": "<+ inputs.ca_cert >",
            "PLUGIN_PARALLELISM": "<+ inputs.parallelism >",
            "PLUGIN_PLAN": "<+ inputs.plan >",
            "PLUGIN_REMOTE": "<+ inputs.remote >",
            "PLUGIN_ROLE_ARN_TO_ASSUME": "<+ inputs.role_arn_to_assume >",
            "PLUGIN_ROOT_DIR": "<+ inputs.root_dir >",
            "PLUGIN_SECRETS": "<+ inputs.secrets >",
            "PLUGIN_SENSITIVE": "<+ inputs.sensitive >",
            "PLUGIN_VARS": "<+ inputs.vars >"
          }
        }
      },
      "inputs": {
        "ca_cert": {
          "type": "string",
          "description": "ca cert to add to your environment to allow terraform to use internal/private resources"
        },
        "parallelism": {
          "type": "string",
          "description": "The number of concurrent operations as Terraform walks its graph."
        },
        "plan": {
          "type": "boolean",
          "description": "Whether to run a plan before applying the configuration.",
          "default": "false"
        },
        "remote": {
          "type": "array",
          "description": "contains the configuration for the Terraform remote state tracking."
        },
        "role_arn_to_assume": {
          "type": "string",
          "description": "A role to assume before running the terraform commands."
        },
        "root_dir": {
          "type": "string",
          "description": "The root directory where the terraform files live. When unset, the top level directory will be assumed."
        },
        "secrets": {
          "type": "array",
          "description": "variables to pass to the Terraform `plan` and `apply` commands. Each value is passed as a `-var <key>=<ENVVAR>` option.  The `ENVVAR` is read as the key/pair value."
        },
        "sensitive": {
          "type": "boolean",
          "description": "Whether or not to suppress terraform commands to stdout.",
          "default": "false"
        },
        "vars": { "type": "array", "description": "The backend to use for the remote." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "upx",
    "spec": {
      "name": "UPX",
      "description": "The UPX plugin can be used to pack executables.",
      "step": {
        "type": "script",
        "spec": {
          "image": "cnbattle/drone-upx",
          "envs": {
            "PLUGIN_LEVEL": "<+ inputs.level >",
            "PLUGIN_ORIGINAL_FILE": "<+ inputs.original_file >",
            "PLUGIN_SAVE_FILE": "<+ inputs.save_file >"
          }
        }
      },
      "inputs": {
        "level": {
          "type": "string",
          "description": "Compression level, a value between 1 and 9, the bigger the better.",
          "default": "5"
        },
        "original_file": { "type": "string", "description": "The path to the file to save the original file." },
        "save_file": { "type": "string", "description": "The path to the file to save the upx file." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "vercel-deploy",
    "spec": {
      "name": "Vercel Deploy",
      "description": "Plugin that allows you deploy a site to Vercel.",
      "step": {
        "type": "script",
        "spec": {
          "image": "https://hub.docker.com/repository/docker/kameshsampath/drone-vercel-deploy",
          "envs": {
            "PLUGIN_LOG_LEVEL": "<+ inputs.log_level >",
            "PLUGIN_VERCEL_ENV": "<+ inputs.vercel_env >",
            "PLUGIN_VERCEL_ENVIRONMENT_VARIABLES": "<+ inputs.vercel_environment_variables >",
            "PLUGIN_VERCEL_ENVIRONMENT_VARIABLE_FILE": "<+ inputs.vercel_environment_variable_file >",
            "PLUGIN_VERCEL_ORG_ID": "<+ inputs.vercel_org_id >",
            "PLUGIN_VERCEL_PROJECT_CREATE": "<+ inputs.vercel_project_create >",
            "PLUGIN_VERCEL_PROJECT_ID": "<+ inputs.vercel_project_id >",
            "PLUGIN_VERCEL_TOKEN": "<+ inputs.vercel_token >"
          }
        }
      },
      "inputs": {
        "log_level": { "type": "string", "description": "Log level that will be used while debugging the plugin" },
        "vercel_env": {
          "type": "string",
          "description": "The vercel environment to deploy. It could be one of development, preview or production.\n",
          "default": "development",
          "required": true
        },
        "vercel_environment_variable_file": {
          "type": "string",
          "description": "An environment variable file, with each line being a KEY=VALUE pairs."
        },
        "vercel_environment_variables": {
          "type": "object",
          "description": "An array of KEY=VALUE pair of environment variables will be added to site project at vercel_environment scope."
        },
        "vercel_org_id": {
          "type": "string",
          "description": "The Vercel organization to which the site project is associated.",
          "required": true
        },
        "vercel_project_create": {
          "type": "boolean",
          "description": "Flag to indicate if the project need to be created",
          "default": "true"
        },
        "vercel_project_id": {
          "type": "string",
          "description": "The Vercel Project where the site will be deployed. It could be name or id of existing project or the project that will be created.",
          "required": true
        },
        "vercel_token": { "type": "string", "description": "The Vercel Token to use.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "volume-cache",
    "spec": {
      "name": "Volume Cache",
      "description": "The volume cache plugin can be used to preserve files and directories between builds.",
      "step": {
        "type": "script",
        "spec": {
          "image": "drillster/drone-volume-cache",
          "envs": {
            "PLUGIN_MOUNT": "<+ inputs.mount >",
            "PLUGIN_REBUILD": "<+ inputs.rebuild >",
            "PLUGIN_RESTORE": "<+ inputs.restore >"
          }
        }
      },
      "inputs": {
        "mount": { "type": "array", "description": "list of folders or files to cache", "default": "[]" },
        "rebuild": { "type": "boolean", "description": "Rebuild cache.", "default": "false" },
        "restore": { "type": "boolean", "description": "Restore cache from previous build.", "default": "false" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "webdav",
    "spec": {
      "name": "WebDAV",
      "description": "The WebDAV plugin will allow pushing build artifacts to any WebDAV server, including Nextcloud or ownCloud.",
      "step": {
        "type": "script",
        "spec": {
          "image": "vividboarder/drone-webdav",
          "envs": {
            "PLUGIN_DESTINATION": "<+ inputs.destination >",
            "PLUGIN_FILE": "<+ inputs.file >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "destination": { "type": "string", "description": "The destination URL.", "required": true },
        "file": { "type": "string", "description": "The path to the file to upload.", "required": true },
        "password": { "type": "string", "description": "The password to authenticate with." },
        "username": { "type": "string", "description": "The username to authenticate with.", "required": true }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "webhook",
    "spec": {
      "name": "Webhook",
      "description": "Use the Webhook plugin to notify services via Webhook when a build completes. You will need to supply Drone with outgoing Webhook URLs.",
      "step": {
        "type": "script",
        "spec": {
          "image": "plugins/webhook",
          "envs": {
            "PLUGIN_CONTENT_TYPE": "<+ inputs.content_type >",
            "PLUGIN_DEBUG": "<+ inputs.debug >",
            "PLUGIN_HEADERS": "<+ inputs.headers >",
            "PLUGIN_METHOD": "<+ inputs.method >",
            "PLUGIN_PASSWORD": "<+ inputs.password >",
            "PLUGIN_SKIP_VERIFY": "<+ inputs.skip_verify >",
            "PLUGIN_TEMPLATE": "<+ inputs.template >",
            "PLUGIN_URLS": "<+ inputs.urls >",
            "PLUGIN_USERNAME": "<+ inputs.username >"
          }
        }
      },
      "inputs": {
        "content_type": {
          "type": "string",
          "description": "The content type of the webhook.",
          "default": "application/json"
        },
        "debug": { "type": "boolean", "description": "Enable debug information.", "default": "false" },
        "headers": { "type": "array", "description": "Map of custom headers" },
        "method": { "type": "string", "description": "The HTTP method to use for the request.", "default": "POST" },
        "password": { "type": "string", "description": "The password to use for basic auth." },
        "skip_verify": { "type": "boolean", "description": "Skip SSL verification.", "default": "false" },
        "template": { "type": "string", "description": "Custom template for webhook" },
        "urls": { "type": "string", "description": "The URLs to send the webhook to.", "required": true },
        "username": { "type": "string", "description": "The username to use for basic auth." }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "wechat-2",
    "spec": {
      "name": "Wechat for Work",
      "description": "Drone plugin for WeChat for Work to show build notifications.",
      "step": {
        "type": "script",
        "spec": {
          "image": "clem109/drone-wechat",
          "envs": {
            "PLUGIN_AGENT_ID": "<+ inputs.agent_id >",
            "PLUGIN_BTNTXT": "<+ inputs.btntxt >",
            "PLUGIN_CORPID": "<+ inputs.corpid >",
            "PLUGIN_CORP_SECRET": "<+ inputs.corp_secret >",
            "PLUGIN_DESCRIPTION": "<+ inputs.description >",
            "PLUGIN_MSG_URL": "<+ inputs.msg_url >",
            "PLUGIN_TITLE": "<+ inputs.title >",
            "PLUGIN_TO_PARTY": "<+ inputs.to_party >",
            "PLUGIN_TO_TAG": "<+ inputs.to_tag >",
            "PLUGIN_TO_USER": "<+ inputs.to_user >"
          }
        }
      },
      "inputs": {
        "agent_id": { "type": "string", "description": "The agent id to send the message", "required": true },
        "btntxt": { "type": "string", "description": "The text for the button on the card" },
        "corp_secret": { "type": "string", "description": "The corp_secret for authorization", "required": true },
        "corpid": { "type": "string", "description": "The corpid for authorization", "required": true },
        "description": { "type": "string", "description": "Text description of the card", "required": true },
        "msg_url": { "type": "string", "description": "The link for the text card click" },
        "title": { "type": "string", "description": "Notification title" },
        "to_party": { "type": "string", "description": "The party id to send the message" },
        "to_tag": { "type": "string", "description": "The tag id to send the message" },
        "to_user": { "type": "string", "description": "The user id to send the message" }
      }
    }
  },
  {
    "kind": "plugin",
    "type": "step",
    "name": "wechat",
    "spec": {
      "name": "Wechat",
      "description": "The Wechat plugin posts build status messages to your account.",
      "step": {
        "type": "script",
        "spec": {
          "image": "lizheming/drone-wechat",
          "envs": {
            "PLUGIN_AGENT_ID": "<+ inputs.agent_id >",
            "PLUGIN_BTN_TEXT": "<+ inputs.btn_text >",
            "PLUGIN_CORPID": "<+ inputs.corpid >",
            "PLUGIN_CORP_SECRET": "<+ inputs.corp_secret >",
            "PLUGIN_MESSAGE": "<+ inputs.message >",
            "PLUGIN_MSG_URL": "<+ inputs.msg_url >",
            "PLUGIN_SAFE": "<+ inputs.safe >",
            "PLUGIN_TITLE": "<+ inputs.title >",
            "PLUGIN_TO_PARTY": "<+ inputs.to_party >",
            "PLUGIN_TO_TAG": "<+ inputs.to_tag >",
            "PLUGIN_TO_USER": "<+ inputs.to_user >"
          }
        }
      },
      "inputs": {
        "agent_id": { "type": "string", "description": "The agent id to send the message", "required": true },
        "btn_text": { "type": "string", "description": "The text for the button on the card" },
        "corp_secret": { "type": "string", "description": "The corp_secret for authorization", "required": true },
        "corpid": { "type": "string", "description": "The corpid for authorization", "required": true },
        "message": { "type": "string", "description": "Notification body message, support markdown", "required": true },
        "msg_url": { "type": "string", "description": "The link for the text card click" },
        "safe": { "type": "boolean", "description": "encrypt message, default is false", "default": "false" },
        "title": { "type": "string", "description": "The title for the card" },
        "to_party": { "type": "string", "description": "The party id to send the message" },
        "to_tag": { "type": "string", "description": "The tag id to send the message" },
        "to_user": { "type": "string", "description": "The user id to send the message" }
      }
    }
  }
]
