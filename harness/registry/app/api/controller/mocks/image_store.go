package mocks

import (
	"context"

	"github.com/harness/gitness/registry/types"

	"github.com/stretchr/testify/mock"
)

// ImageStore is an autogenerated mock type for the ImageStore type
type ImageStore struct {
	mock.Mock
}

// Get provides a mock function with given fields: ctx, id
func (m *ImageStore) Get(ctx context.Context, id int64) (*types.Image, error) {
	ret := m.Called(ctx, id)

	var r0 *types.Image
	if rf, ok := ret.Get(0).(func(context.Context, int64) *types.Image); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Image)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByName provides a mock function with given fields: ctx, registryID, name
func (m *ImageStore) GetByName(ctx context.Context, registryID int64, name string) (*types.Image, error) {
	ret := m.Called(ctx, registryID, name)

	var r0 *types.Image
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) *types.Image); ok {
		r0 = rf(ctx, registryID, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Image)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64, string) error); ok {
		r1 = rf(ctx, registryID, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLabelsByParentIDAndRepo provides a mock function with given fields: ctx, parentID, repo, limit, offset, search
func (m *ImageStore) GetLabelsByParentIDAndRepo(ctx context.Context, parentID int64, repo string, limit int, offset int, search string) ([]string, error) {
	ret := m.Called(ctx, parentID, repo, limit, offset, search)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, int, int, string) []string); ok {
		r0 = rf(ctx, parentID, repo, limit, offset, search)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64, string, int, int, string) error); ok {
		r1 = rf(ctx, parentID, repo, limit, offset, search)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountLabelsByParentIDAndRepo provides a mock function with given fields: ctx, parentID, repo, search
func (m *ImageStore) CountLabelsByParentIDAndRepo(ctx context.Context, parentID int64, repo string, search string) (int64, error) {
	ret := m.Called(ctx, parentID, repo, search)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, string) int64); ok {
		r0 = rf(ctx, parentID, repo, search)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64, string, string) error); ok {
		r1 = rf(ctx, parentID, repo, search)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByRepoAndName provides a mock function with given fields: ctx, parentID, repo, name
func (m *ImageStore) GetByRepoAndName(ctx context.Context, parentID int64, repo string, name string) (*types.Image, error) {
	ret := m.Called(ctx, parentID, repo, name)

	var r0 *types.Image
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, string) *types.Image); ok {
		r0 = rf(ctx, parentID, repo, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Image)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64, string, string) error); ok {
		r1 = rf(ctx, parentID, repo, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOrUpdate provides a mock function with given fields: ctx, image
func (m *ImageStore) CreateOrUpdate(ctx context.Context, image *types.Image) error {
	ret := m.Called(ctx, image)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Image) error); ok {
		r0 = rf(ctx, image)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Update provides a mock function with given fields: ctx, image
func (m *ImageStore) Update(ctx context.Context, image *types.Image) error {
	ret := m.Called(ctx, image)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Image) error); ok {
		r0 = rf(ctx, image)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateStatus provides a mock function with given fields: ctx, image
func (m *ImageStore) UpdateStatus(ctx context.Context, image *types.Image) error {
	ret := m.Called(ctx, image)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Image) error); ok {
		r0 = rf(ctx, image)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteByRegistryID provides a mock function with given fields: ctx, registryID
func (m *ImageStore) DeleteByRegistryID(ctx context.Context, registryID int64) error {
	ret := m.Called(ctx, registryID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, registryID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteBandwidthStatByRegistryID provides a mock function with given fields: ctx, registryID
func (m *ImageStore) DeleteBandwidthStatByRegistryID(ctx context.Context, registryID int64) error {
	ret := m.Called(ctx, registryID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, registryID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteDownloadStatByRegistryID provides a mock function with given fields: ctx, registryID
func (m *ImageStore) DeleteDownloadStatByRegistryID(ctx context.Context, registryID int64) error {
	ret := m.Called(ctx, registryID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, registryID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
