// Code generated by testify. DO NOT EDIT.

package mocks

import (
	"context"

	"github.com/harness/gitness/app/auth"
	"github.com/harness/gitness/types"
	"github.com/harness/gitness/types/enum"

	"github.com/stretchr/testify/mock"
)

// Authorizer is an autogenerated mock type for the Authorizer type
type Authorizer struct {
	mock.Mock
}

// Check provides a mock function with given fields: ctx, session, scope, resource, permission
func (m *Authorizer) Check(ctx context.Context, session *auth.Session, scope *types.Scope, resource *types.Resource, permission enum.Permission) (bool, error) {
	ret := m.Called(ctx, session, scope, resource, permission)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, *auth.Session, *types.Scope, *types.Resource, enum.Permission) bool); ok {
		r0 = rf(ctx, session, scope, resource, permission)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *auth.Session, *types.Scope, *types.Resource, enum.Permission) error); ok {
		r1 = rf(ctx, session, scope, resource, permission)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckAll provides a mock function with given fields: ctx, session, permissionChecks
func (m *Authorizer) CheckAll(ctx context.Context, session *auth.Session, permissionChecks ...types.PermissionCheck) (bool, error) {
	var args []interface{}
	args = append(args, ctx, session)
	for _, check := range permissionChecks {
		args = append(args, check)
	}
	ret := m.Called(args...)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, *auth.Session, ...types.PermissionCheck) bool); ok {
		r0 = rf(ctx, session, permissionChecks...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *auth.Session, ...types.PermissionCheck) error); ok {
		r1 = rf(ctx, session, permissionChecks...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
