// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"encoding/json"

	"github.com/harness/gitness/registry/app/api/openapi/contracts/artifact"
	"github.com/harness/gitness/registry/types"
	mock "github.com/stretchr/testify/mock"
)

// NewMockArtifactRepository creates a new instance of MockArtifactRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockArtifactRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockArtifactRepository {
	mock := &MockArtifactRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockArtifactRepository is an autogenerated mock type for the ArtifactRepository type
type MockArtifactRepository struct {
	mock.Mock
}

type MockArtifactRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockArtifactRepository) EXPECT() *MockArtifactRepository_Expecter {
	return &MockArtifactRepository_Expecter{mock: &_m.Mock}
}

// Count provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) Count(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockArtifactRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockArtifactRepository_Expecter) Count(ctx interface{}) *MockArtifactRepository_Count_Call {
	return &MockArtifactRepository_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockArtifactRepository_Count_Call) Run(run func(ctx context.Context)) *MockArtifactRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_Count_Call) Return(n int64, err error) *MockArtifactRepository_Count_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockArtifactRepository_Count_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockArtifactRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// CountAllArtifactsByParentID provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) CountAllArtifactsByParentID(ctx context.Context, parentID int64, registryIDs *[]string, search string, latestVersion bool, packageTypes []string) (int64, error) {
	ret := _mock.Called(ctx, parentID, registryIDs, search, latestVersion, packageTypes)

	if len(ret) == 0 {
		panic("no return value specified for CountAllArtifactsByParentID")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, *[]string, string, bool, []string) (int64, error)); ok {
		return returnFunc(ctx, parentID, registryIDs, search, latestVersion, packageTypes)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, *[]string, string, bool, []string) int64); ok {
		r0 = returnFunc(ctx, parentID, registryIDs, search, latestVersion, packageTypes)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, *[]string, string, bool, []string) error); ok {
		r1 = returnFunc(ctx, parentID, registryIDs, search, latestVersion, packageTypes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_CountAllArtifactsByParentID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountAllArtifactsByParentID'
type MockArtifactRepository_CountAllArtifactsByParentID_Call struct {
	*mock.Call
}

// CountAllArtifactsByParentID is a helper method to define mock.On call
//   - ctx context.Context
//   - parentID int64
//   - registryIDs *[]string
//   - search string
//   - latestVersion bool
//   - packageTypes []string
func (_e *MockArtifactRepository_Expecter) CountAllArtifactsByParentID(ctx interface{}, parentID interface{}, registryIDs interface{}, search interface{}, latestVersion interface{}, packageTypes interface{}) *MockArtifactRepository_CountAllArtifactsByParentID_Call {
	return &MockArtifactRepository_CountAllArtifactsByParentID_Call{Call: _e.mock.On("CountAllArtifactsByParentID", ctx, parentID, registryIDs, search, latestVersion, packageTypes)}
}

func (_c *MockArtifactRepository_CountAllArtifactsByParentID_Call) Run(run func(ctx context.Context, parentID int64, registryIDs *[]string, search string, latestVersion bool, packageTypes []string)) *MockArtifactRepository_CountAllArtifactsByParentID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 *[]string
		if args[2] != nil {
			arg2 = args[2].(*[]string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 bool
		if args[4] != nil {
			arg4 = args[4].(bool)
		}
		var arg5 []string
		if args[5] != nil {
			arg5 = args[5].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_CountAllArtifactsByParentID_Call) Return(n int64, err error) *MockArtifactRepository_CountAllArtifactsByParentID_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockArtifactRepository_CountAllArtifactsByParentID_Call) RunAndReturn(run func(ctx context.Context, parentID int64, registryIDs *[]string, search string, latestVersion bool, packageTypes []string) (int64, error)) *MockArtifactRepository_CountAllArtifactsByParentID_Call {
	_c.Call.Return(run)
	return _c
}

// CountAllVersionsByRepoAndImage provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) CountAllVersionsByRepoAndImage(ctx context.Context, parentID int64, repoKey string, image string, search string, artifactType *artifact.ArtifactType) (int64, error) {
	ret := _mock.Called(ctx, parentID, repoKey, image, search, artifactType)

	if len(ret) == 0 {
		panic("no return value specified for CountAllVersionsByRepoAndImage")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, string, *artifact.ArtifactType) (int64, error)); ok {
		return returnFunc(ctx, parentID, repoKey, image, search, artifactType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, string, *artifact.ArtifactType) int64); ok {
		r0 = returnFunc(ctx, parentID, repoKey, image, search, artifactType)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, string, string, *artifact.ArtifactType) error); ok {
		r1 = returnFunc(ctx, parentID, repoKey, image, search, artifactType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_CountAllVersionsByRepoAndImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountAllVersionsByRepoAndImage'
type MockArtifactRepository_CountAllVersionsByRepoAndImage_Call struct {
	*mock.Call
}

// CountAllVersionsByRepoAndImage is a helper method to define mock.On call
//   - ctx context.Context
//   - parentID int64
//   - repoKey string
//   - image string
//   - search string
//   - artifactType *artifact.ArtifactType
func (_e *MockArtifactRepository_Expecter) CountAllVersionsByRepoAndImage(ctx interface{}, parentID interface{}, repoKey interface{}, image interface{}, search interface{}, artifactType interface{}) *MockArtifactRepository_CountAllVersionsByRepoAndImage_Call {
	return &MockArtifactRepository_CountAllVersionsByRepoAndImage_Call{Call: _e.mock.On("CountAllVersionsByRepoAndImage", ctx, parentID, repoKey, image, search, artifactType)}
}

func (_c *MockArtifactRepository_CountAllVersionsByRepoAndImage_Call) Run(run func(ctx context.Context, parentID int64, repoKey string, image string, search string, artifactType *artifact.ArtifactType)) *MockArtifactRepository_CountAllVersionsByRepoAndImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 *artifact.ArtifactType
		if args[5] != nil {
			arg5 = args[5].(*artifact.ArtifactType)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_CountAllVersionsByRepoAndImage_Call) Return(n int64, err error) *MockArtifactRepository_CountAllVersionsByRepoAndImage_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockArtifactRepository_CountAllVersionsByRepoAndImage_Call) RunAndReturn(run func(ctx context.Context, parentID int64, repoKey string, image string, search string, artifactType *artifact.ArtifactType) (int64, error)) *MockArtifactRepository_CountAllVersionsByRepoAndImage_Call {
	_c.Call.Return(run)
	return _c
}

// CountArtifactsByRepo provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) CountArtifactsByRepo(ctx context.Context, parentID int64, repoKey string, search string, labels []string, artifactType *artifact.ArtifactType) (int64, error) {
	ret := _mock.Called(ctx, parentID, repoKey, search, labels, artifactType)

	if len(ret) == 0 {
		panic("no return value specified for CountArtifactsByRepo")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, []string, *artifact.ArtifactType) (int64, error)); ok {
		return returnFunc(ctx, parentID, repoKey, search, labels, artifactType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, []string, *artifact.ArtifactType) int64); ok {
		r0 = returnFunc(ctx, parentID, repoKey, search, labels, artifactType)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, string, []string, *artifact.ArtifactType) error); ok {
		r1 = returnFunc(ctx, parentID, repoKey, search, labels, artifactType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_CountArtifactsByRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountArtifactsByRepo'
type MockArtifactRepository_CountArtifactsByRepo_Call struct {
	*mock.Call
}

// CountArtifactsByRepo is a helper method to define mock.On call
//   - ctx context.Context
//   - parentID int64
//   - repoKey string
//   - search string
//   - labels []string
//   - artifactType *artifact.ArtifactType
func (_e *MockArtifactRepository_Expecter) CountArtifactsByRepo(ctx interface{}, parentID interface{}, repoKey interface{}, search interface{}, labels interface{}, artifactType interface{}) *MockArtifactRepository_CountArtifactsByRepo_Call {
	return &MockArtifactRepository_CountArtifactsByRepo_Call{Call: _e.mock.On("CountArtifactsByRepo", ctx, parentID, repoKey, search, labels, artifactType)}
}

func (_c *MockArtifactRepository_CountArtifactsByRepo_Call) Run(run func(ctx context.Context, parentID int64, repoKey string, search string, labels []string, artifactType *artifact.ArtifactType)) *MockArtifactRepository_CountArtifactsByRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 []string
		if args[4] != nil {
			arg4 = args[4].([]string)
		}
		var arg5 *artifact.ArtifactType
		if args[5] != nil {
			arg5 = args[5].(*artifact.ArtifactType)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_CountArtifactsByRepo_Call) Return(n int64, err error) *MockArtifactRepository_CountArtifactsByRepo_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockArtifactRepository_CountArtifactsByRepo_Call) RunAndReturn(run func(ctx context.Context, parentID int64, repoKey string, search string, labels []string, artifactType *artifact.ArtifactType) (int64, error)) *MockArtifactRepository_CountArtifactsByRepo_Call {
	_c.Call.Return(run)
	return _c
}

// CountByImageName provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) CountByImageName(ctx context.Context, regID int64, name string) (int64, error) {
	ret := _mock.Called(ctx, regID, name)

	if len(ret) == 0 {
		panic("no return value specified for CountByImageName")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) (int64, error)); ok {
		return returnFunc(ctx, regID, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) int64); ok {
		r0 = returnFunc(ctx, regID, name)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string) error); ok {
		r1 = returnFunc(ctx, regID, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_CountByImageName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByImageName'
type MockArtifactRepository_CountByImageName_Call struct {
	*mock.Call
}

// CountByImageName is a helper method to define mock.On call
//   - ctx context.Context
//   - regID int64
//   - name string
func (_e *MockArtifactRepository_Expecter) CountByImageName(ctx interface{}, regID interface{}, name interface{}) *MockArtifactRepository_CountByImageName_Call {
	return &MockArtifactRepository_CountByImageName_Call{Call: _e.mock.On("CountByImageName", ctx, regID, name)}
}

func (_c *MockArtifactRepository_CountByImageName_Call) Run(run func(ctx context.Context, regID int64, name string)) *MockArtifactRepository_CountByImageName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_CountByImageName_Call) Return(n int64, err error) *MockArtifactRepository_CountByImageName_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockArtifactRepository_CountByImageName_Call) RunAndReturn(run func(ctx context.Context, regID int64, name string) (int64, error)) *MockArtifactRepository_CountByImageName_Call {
	_c.Call.Return(run)
	return _c
}

// CountLatestByName provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) CountLatestByName(ctx context.Context, regID int64, name string) (int64, error) {
	ret := _mock.Called(ctx, regID, name)

	if len(ret) == 0 {
		panic("no return value specified for CountLatestByName")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) (int64, error)); ok {
		return returnFunc(ctx, regID, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) int64); ok {
		r0 = returnFunc(ctx, regID, name)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string) error); ok {
		r1 = returnFunc(ctx, regID, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_CountLatestByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountLatestByName'
type MockArtifactRepository_CountLatestByName_Call struct {
	*mock.Call
}

// CountLatestByName is a helper method to define mock.On call
//   - ctx context.Context
//   - regID int64
//   - name string
func (_e *MockArtifactRepository_Expecter) CountLatestByName(ctx interface{}, regID interface{}, name interface{}) *MockArtifactRepository_CountLatestByName_Call {
	return &MockArtifactRepository_CountLatestByName_Call{Call: _e.mock.On("CountLatestByName", ctx, regID, name)}
}

func (_c *MockArtifactRepository_CountLatestByName_Call) Run(run func(ctx context.Context, regID int64, name string)) *MockArtifactRepository_CountLatestByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_CountLatestByName_Call) Return(n int64, err error) *MockArtifactRepository_CountLatestByName_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockArtifactRepository_CountLatestByName_Call) RunAndReturn(run func(ctx context.Context, regID int64, name string) (int64, error)) *MockArtifactRepository_CountLatestByName_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdate provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) CreateOrUpdate(ctx context.Context, artifact1 *types.Artifact) (int64, error) {
	ret := _mock.Called(ctx, artifact1)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdate")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Artifact) (int64, error)); ok {
		return returnFunc(ctx, artifact1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *types.Artifact) int64); ok {
		r0 = returnFunc(ctx, artifact1)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *types.Artifact) error); ok {
		r1 = returnFunc(ctx, artifact1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_CreateOrUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdate'
type MockArtifactRepository_CreateOrUpdate_Call struct {
	*mock.Call
}

// CreateOrUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - artifact1 *types.Artifact
func (_e *MockArtifactRepository_Expecter) CreateOrUpdate(ctx interface{}, artifact1 interface{}) *MockArtifactRepository_CreateOrUpdate_Call {
	return &MockArtifactRepository_CreateOrUpdate_Call{Call: _e.mock.On("CreateOrUpdate", ctx, artifact1)}
}

func (_c *MockArtifactRepository_CreateOrUpdate_Call) Run(run func(ctx context.Context, artifact1 *types.Artifact)) *MockArtifactRepository_CreateOrUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *types.Artifact
		if args[1] != nil {
			arg1 = args[1].(*types.Artifact)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_CreateOrUpdate_Call) Return(n int64, err error) *MockArtifactRepository_CreateOrUpdate_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockArtifactRepository_CreateOrUpdate_Call) RunAndReturn(run func(ctx context.Context, artifact1 *types.Artifact) (int64, error)) *MockArtifactRepository_CreateOrUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteByImageNameAndRegistryID provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) DeleteByImageNameAndRegistryID(ctx context.Context, regID int64, image string) error {
	ret := _mock.Called(ctx, regID, image)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByImageNameAndRegistryID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) error); ok {
		r0 = returnFunc(ctx, regID, image)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockArtifactRepository_DeleteByImageNameAndRegistryID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteByImageNameAndRegistryID'
type MockArtifactRepository_DeleteByImageNameAndRegistryID_Call struct {
	*mock.Call
}

// DeleteByImageNameAndRegistryID is a helper method to define mock.On call
//   - ctx context.Context
//   - regID int64
//   - image string
func (_e *MockArtifactRepository_Expecter) DeleteByImageNameAndRegistryID(ctx interface{}, regID interface{}, image interface{}) *MockArtifactRepository_DeleteByImageNameAndRegistryID_Call {
	return &MockArtifactRepository_DeleteByImageNameAndRegistryID_Call{Call: _e.mock.On("DeleteByImageNameAndRegistryID", ctx, regID, image)}
}

func (_c *MockArtifactRepository_DeleteByImageNameAndRegistryID_Call) Run(run func(ctx context.Context, regID int64, image string)) *MockArtifactRepository_DeleteByImageNameAndRegistryID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_DeleteByImageNameAndRegistryID_Call) Return(err error) *MockArtifactRepository_DeleteByImageNameAndRegistryID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockArtifactRepository_DeleteByImageNameAndRegistryID_Call) RunAndReturn(run func(ctx context.Context, regID int64, image string) error) *MockArtifactRepository_DeleteByImageNameAndRegistryID_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteByVersionAndImageName provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) DeleteByVersionAndImageName(ctx context.Context, image string, version string, regID int64) error {
	ret := _mock.Called(ctx, image, version, regID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByVersionAndImageName")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) error); ok {
		r0 = returnFunc(ctx, image, version, regID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockArtifactRepository_DeleteByVersionAndImageName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteByVersionAndImageName'
type MockArtifactRepository_DeleteByVersionAndImageName_Call struct {
	*mock.Call
}

// DeleteByVersionAndImageName is a helper method to define mock.On call
//   - ctx context.Context
//   - image string
//   - version string
//   - regID int64
func (_e *MockArtifactRepository_Expecter) DeleteByVersionAndImageName(ctx interface{}, image interface{}, version interface{}, regID interface{}) *MockArtifactRepository_DeleteByVersionAndImageName_Call {
	return &MockArtifactRepository_DeleteByVersionAndImageName_Call{Call: _e.mock.On("DeleteByVersionAndImageName", ctx, image, version, regID)}
}

func (_c *MockArtifactRepository_DeleteByVersionAndImageName_Call) Run(run func(ctx context.Context, image string, version string, regID int64)) *MockArtifactRepository_DeleteByVersionAndImageName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_DeleteByVersionAndImageName_Call) Return(err error) *MockArtifactRepository_DeleteByVersionAndImageName_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockArtifactRepository_DeleteByVersionAndImageName_Call) RunAndReturn(run func(ctx context.Context, image string, version string, regID int64) error) *MockArtifactRepository_DeleteByVersionAndImageName_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllArtifactsByParentID provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) GetAllArtifactsByParentID(ctx context.Context, id int64, i *[]string, field string, order string, limit int, offset int, term string, version bool, packageTypes []string) (*[]types.ArtifactMetadata, error) {
	ret := _mock.Called(ctx, id, i, field, order, limit, offset, term, version, packageTypes)

	if len(ret) == 0 {
		panic("no return value specified for GetAllArtifactsByParentID")
	}

	var r0 *[]types.ArtifactMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, *[]string, string, string, int, int, string, bool, []string) (*[]types.ArtifactMetadata, error)); ok {
		return returnFunc(ctx, id, i, field, order, limit, offset, term, version, packageTypes)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, *[]string, string, string, int, int, string, bool, []string) *[]types.ArtifactMetadata); ok {
		r0 = returnFunc(ctx, id, i, field, order, limit, offset, term, version, packageTypes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]types.ArtifactMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, *[]string, string, string, int, int, string, bool, []string) error); ok {
		r1 = returnFunc(ctx, id, i, field, order, limit, offset, term, version, packageTypes)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_GetAllArtifactsByParentID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllArtifactsByParentID'
type MockArtifactRepository_GetAllArtifactsByParentID_Call struct {
	*mock.Call
}

// GetAllArtifactsByParentID is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
//   - i *[]string
//   - field string
//   - order string
//   - limit int
//   - offset int
//   - term string
//   - version bool
//   - packageTypes []string
func (_e *MockArtifactRepository_Expecter) GetAllArtifactsByParentID(ctx interface{}, id interface{}, i interface{}, field interface{}, order interface{}, limit interface{}, offset interface{}, term interface{}, version interface{}, packageTypes interface{}) *MockArtifactRepository_GetAllArtifactsByParentID_Call {
	return &MockArtifactRepository_GetAllArtifactsByParentID_Call{Call: _e.mock.On("GetAllArtifactsByParentID", ctx, id, i, field, order, limit, offset, term, version, packageTypes)}
}

func (_c *MockArtifactRepository_GetAllArtifactsByParentID_Call) Run(run func(ctx context.Context, id int64, i *[]string, field string, order string, limit int, offset int, term string, version bool, packageTypes []string)) *MockArtifactRepository_GetAllArtifactsByParentID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 *[]string
		if args[2] != nil {
			arg2 = args[2].(*[]string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 int
		if args[5] != nil {
			arg5 = args[5].(int)
		}
		var arg6 int
		if args[6] != nil {
			arg6 = args[6].(int)
		}
		var arg7 string
		if args[7] != nil {
			arg7 = args[7].(string)
		}
		var arg8 bool
		if args[8] != nil {
			arg8 = args[8].(bool)
		}
		var arg9 []string
		if args[9] != nil {
			arg9 = args[9].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
			arg7,
			arg8,
			arg9,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_GetAllArtifactsByParentID_Call) Return(artifactMetadatas *[]types.ArtifactMetadata, err error) *MockArtifactRepository_GetAllArtifactsByParentID_Call {
	_c.Call.Return(artifactMetadatas, err)
	return _c
}

func (_c *MockArtifactRepository_GetAllArtifactsByParentID_Call) RunAndReturn(run func(ctx context.Context, id int64, i *[]string, field string, order string, limit int, offset int, term string, version bool, packageTypes []string) (*[]types.ArtifactMetadata, error)) *MockArtifactRepository_GetAllArtifactsByParentID_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllArtifactsByRepo provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) GetAllArtifactsByRepo(ctx context.Context, registryID int64, batchSize int, artifactID int64) (*[]types.ArtifactMetadata, error) {
	ret := _mock.Called(ctx, registryID, batchSize, artifactID)

	if len(ret) == 0 {
		panic("no return value specified for GetAllArtifactsByRepo")
	}

	var r0 *[]types.ArtifactMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int, int64) (*[]types.ArtifactMetadata, error)); ok {
		return returnFunc(ctx, registryID, batchSize, artifactID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, int, int64) *[]types.ArtifactMetadata); ok {
		r0 = returnFunc(ctx, registryID, batchSize, artifactID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]types.ArtifactMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, int, int64) error); ok {
		r1 = returnFunc(ctx, registryID, batchSize, artifactID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_GetAllArtifactsByRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllArtifactsByRepo'
type MockArtifactRepository_GetAllArtifactsByRepo_Call struct {
	*mock.Call
}

// GetAllArtifactsByRepo is a helper method to define mock.On call
//   - ctx context.Context
//   - registryID int64
//   - batchSize int
//   - artifactID int64
func (_e *MockArtifactRepository_Expecter) GetAllArtifactsByRepo(ctx interface{}, registryID interface{}, batchSize interface{}, artifactID interface{}) *MockArtifactRepository_GetAllArtifactsByRepo_Call {
	return &MockArtifactRepository_GetAllArtifactsByRepo_Call{Call: _e.mock.On("GetAllArtifactsByRepo", ctx, registryID, batchSize, artifactID)}
}

func (_c *MockArtifactRepository_GetAllArtifactsByRepo_Call) Run(run func(ctx context.Context, registryID int64, batchSize int, artifactID int64)) *MockArtifactRepository_GetAllArtifactsByRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_GetAllArtifactsByRepo_Call) Return(artifactMetadatas *[]types.ArtifactMetadata, err error) *MockArtifactRepository_GetAllArtifactsByRepo_Call {
	_c.Call.Return(artifactMetadatas, err)
	return _c
}

func (_c *MockArtifactRepository_GetAllArtifactsByRepo_Call) RunAndReturn(run func(ctx context.Context, registryID int64, batchSize int, artifactID int64) (*[]types.ArtifactMetadata, error)) *MockArtifactRepository_GetAllArtifactsByRepo_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllVersionsByRepoAndImage provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) GetAllVersionsByRepoAndImage(ctx context.Context, id int64, image string, field string, order string, limit int, offset int, term string, artifactType *artifact.ArtifactType) (*[]types.NonOCIArtifactMetadata, error) {
	ret := _mock.Called(ctx, id, image, field, order, limit, offset, term, artifactType)

	if len(ret) == 0 {
		panic("no return value specified for GetAllVersionsByRepoAndImage")
	}

	var r0 *[]types.NonOCIArtifactMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, string, int, int, string, *artifact.ArtifactType) (*[]types.NonOCIArtifactMetadata, error)); ok {
		return returnFunc(ctx, id, image, field, order, limit, offset, term, artifactType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, string, int, int, string, *artifact.ArtifactType) *[]types.NonOCIArtifactMetadata); ok {
		r0 = returnFunc(ctx, id, image, field, order, limit, offset, term, artifactType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]types.NonOCIArtifactMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, string, string, int, int, string, *artifact.ArtifactType) error); ok {
		r1 = returnFunc(ctx, id, image, field, order, limit, offset, term, artifactType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_GetAllVersionsByRepoAndImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllVersionsByRepoAndImage'
type MockArtifactRepository_GetAllVersionsByRepoAndImage_Call struct {
	*mock.Call
}

// GetAllVersionsByRepoAndImage is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
//   - image string
//   - field string
//   - order string
//   - limit int
//   - offset int
//   - term string
//   - artifactType *artifact.ArtifactType
func (_e *MockArtifactRepository_Expecter) GetAllVersionsByRepoAndImage(ctx interface{}, id interface{}, image interface{}, field interface{}, order interface{}, limit interface{}, offset interface{}, term interface{}, artifactType interface{}) *MockArtifactRepository_GetAllVersionsByRepoAndImage_Call {
	return &MockArtifactRepository_GetAllVersionsByRepoAndImage_Call{Call: _e.mock.On("GetAllVersionsByRepoAndImage", ctx, id, image, field, order, limit, offset, term, artifactType)}
}

func (_c *MockArtifactRepository_GetAllVersionsByRepoAndImage_Call) Run(run func(ctx context.Context, id int64, image string, field string, order string, limit int, offset int, term string, artifactType *artifact.ArtifactType)) *MockArtifactRepository_GetAllVersionsByRepoAndImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 int
		if args[5] != nil {
			arg5 = args[5].(int)
		}
		var arg6 int
		if args[6] != nil {
			arg6 = args[6].(int)
		}
		var arg7 string
		if args[7] != nil {
			arg7 = args[7].(string)
		}
		var arg8 *artifact.ArtifactType
		if args[8] != nil {
			arg8 = args[8].(*artifact.ArtifactType)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
			arg7,
			arg8,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_GetAllVersionsByRepoAndImage_Call) Return(nonOCIArtifactMetadatas *[]types.NonOCIArtifactMetadata, err error) *MockArtifactRepository_GetAllVersionsByRepoAndImage_Call {
	_c.Call.Return(nonOCIArtifactMetadatas, err)
	return _c
}

func (_c *MockArtifactRepository_GetAllVersionsByRepoAndImage_Call) RunAndReturn(run func(ctx context.Context, id int64, image string, field string, order string, limit int, offset int, term string, artifactType *artifact.ArtifactType) (*[]types.NonOCIArtifactMetadata, error)) *MockArtifactRepository_GetAllVersionsByRepoAndImage_Call {
	_c.Call.Return(run)
	return _c
}

// GetArtifactMetadata provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) GetArtifactMetadata(ctx context.Context, id int64, identifier string, image string, version string, artifactType *artifact.ArtifactType) (*types.ArtifactMetadata, error) {
	ret := _mock.Called(ctx, id, identifier, image, version, artifactType)

	if len(ret) == 0 {
		panic("no return value specified for GetArtifactMetadata")
	}

	var r0 *types.ArtifactMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, string, *artifact.ArtifactType) (*types.ArtifactMetadata, error)); ok {
		return returnFunc(ctx, id, identifier, image, version, artifactType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, string, *artifact.ArtifactType) *types.ArtifactMetadata); ok {
		r0 = returnFunc(ctx, id, identifier, image, version, artifactType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ArtifactMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, string, string, *artifact.ArtifactType) error); ok {
		r1 = returnFunc(ctx, id, identifier, image, version, artifactType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_GetArtifactMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetArtifactMetadata'
type MockArtifactRepository_GetArtifactMetadata_Call struct {
	*mock.Call
}

// GetArtifactMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
//   - identifier string
//   - image string
//   - version string
//   - artifactType *artifact.ArtifactType
func (_e *MockArtifactRepository_Expecter) GetArtifactMetadata(ctx interface{}, id interface{}, identifier interface{}, image interface{}, version interface{}, artifactType interface{}) *MockArtifactRepository_GetArtifactMetadata_Call {
	return &MockArtifactRepository_GetArtifactMetadata_Call{Call: _e.mock.On("GetArtifactMetadata", ctx, id, identifier, image, version, artifactType)}
}

func (_c *MockArtifactRepository_GetArtifactMetadata_Call) Run(run func(ctx context.Context, id int64, identifier string, image string, version string, artifactType *artifact.ArtifactType)) *MockArtifactRepository_GetArtifactMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 *artifact.ArtifactType
		if args[5] != nil {
			arg5 = args[5].(*artifact.ArtifactType)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_GetArtifactMetadata_Call) Return(artifactMetadata *types.ArtifactMetadata, err error) *MockArtifactRepository_GetArtifactMetadata_Call {
	_c.Call.Return(artifactMetadata, err)
	return _c
}

func (_c *MockArtifactRepository_GetArtifactMetadata_Call) RunAndReturn(run func(ctx context.Context, id int64, identifier string, image string, version string, artifactType *artifact.ArtifactType) (*types.ArtifactMetadata, error)) *MockArtifactRepository_GetArtifactMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// GetArtifactsByRepo provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) GetArtifactsByRepo(ctx context.Context, parentID int64, repoKey string, sortByField string, sortByOrder string, limit int, offset int, search string, labels []string, artifactType *artifact.ArtifactType) (*[]types.ArtifactMetadata, error) {
	ret := _mock.Called(ctx, parentID, repoKey, sortByField, sortByOrder, limit, offset, search, labels, artifactType)

	if len(ret) == 0 {
		panic("no return value specified for GetArtifactsByRepo")
	}

	var r0 *[]types.ArtifactMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, string, int, int, string, []string, *artifact.ArtifactType) (*[]types.ArtifactMetadata, error)); ok {
		return returnFunc(ctx, parentID, repoKey, sortByField, sortByOrder, limit, offset, search, labels, artifactType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, string, int, int, string, []string, *artifact.ArtifactType) *[]types.ArtifactMetadata); ok {
		r0 = returnFunc(ctx, parentID, repoKey, sortByField, sortByOrder, limit, offset, search, labels, artifactType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]types.ArtifactMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, string, string, int, int, string, []string, *artifact.ArtifactType) error); ok {
		r1 = returnFunc(ctx, parentID, repoKey, sortByField, sortByOrder, limit, offset, search, labels, artifactType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_GetArtifactsByRepo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetArtifactsByRepo'
type MockArtifactRepository_GetArtifactsByRepo_Call struct {
	*mock.Call
}

// GetArtifactsByRepo is a helper method to define mock.On call
//   - ctx context.Context
//   - parentID int64
//   - repoKey string
//   - sortByField string
//   - sortByOrder string
//   - limit int
//   - offset int
//   - search string
//   - labels []string
//   - artifactType *artifact.ArtifactType
func (_e *MockArtifactRepository_Expecter) GetArtifactsByRepo(ctx interface{}, parentID interface{}, repoKey interface{}, sortByField interface{}, sortByOrder interface{}, limit interface{}, offset interface{}, search interface{}, labels interface{}, artifactType interface{}) *MockArtifactRepository_GetArtifactsByRepo_Call {
	return &MockArtifactRepository_GetArtifactsByRepo_Call{Call: _e.mock.On("GetArtifactsByRepo", ctx, parentID, repoKey, sortByField, sortByOrder, limit, offset, search, labels, artifactType)}
}

func (_c *MockArtifactRepository_GetArtifactsByRepo_Call) Run(run func(ctx context.Context, parentID int64, repoKey string, sortByField string, sortByOrder string, limit int, offset int, search string, labels []string, artifactType *artifact.ArtifactType)) *MockArtifactRepository_GetArtifactsByRepo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		var arg5 int
		if args[5] != nil {
			arg5 = args[5].(int)
		}
		var arg6 int
		if args[6] != nil {
			arg6 = args[6].(int)
		}
		var arg7 string
		if args[7] != nil {
			arg7 = args[7].(string)
		}
		var arg8 []string
		if args[8] != nil {
			arg8 = args[8].([]string)
		}
		var arg9 *artifact.ArtifactType
		if args[9] != nil {
			arg9 = args[9].(*artifact.ArtifactType)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
			arg7,
			arg8,
			arg9,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_GetArtifactsByRepo_Call) Return(artifactMetadatas *[]types.ArtifactMetadata, err error) *MockArtifactRepository_GetArtifactsByRepo_Call {
	_c.Call.Return(artifactMetadatas, err)
	return _c
}

func (_c *MockArtifactRepository_GetArtifactsByRepo_Call) RunAndReturn(run func(ctx context.Context, parentID int64, repoKey string, sortByField string, sortByOrder string, limit int, offset int, search string, labels []string, artifactType *artifact.ArtifactType) (*[]types.ArtifactMetadata, error)) *MockArtifactRepository_GetArtifactsByRepo_Call {
	_c.Call.Return(run)
	return _c
}

// GetArtifactsByRepoAndImageBatch provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) GetArtifactsByRepoAndImageBatch(ctx context.Context, registryID int64, imageName string, batchSize int, artifactID int64) (*[]types.ArtifactMetadata, error) {
	ret := _mock.Called(ctx, registryID, imageName, batchSize, artifactID)

	if len(ret) == 0 {
		panic("no return value specified for GetArtifactsByRepoAndImageBatch")
	}

	var r0 *[]types.ArtifactMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, int, int64) (*[]types.ArtifactMetadata, error)); ok {
		return returnFunc(ctx, registryID, imageName, batchSize, artifactID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, int, int64) *[]types.ArtifactMetadata); ok {
		r0 = returnFunc(ctx, registryID, imageName, batchSize, artifactID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]types.ArtifactMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, int, int64) error); ok {
		r1 = returnFunc(ctx, registryID, imageName, batchSize, artifactID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_GetArtifactsByRepoAndImageBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetArtifactsByRepoAndImageBatch'
type MockArtifactRepository_GetArtifactsByRepoAndImageBatch_Call struct {
	*mock.Call
}

// GetArtifactsByRepoAndImageBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - registryID int64
//   - imageName string
//   - batchSize int
//   - artifactID int64
func (_e *MockArtifactRepository_Expecter) GetArtifactsByRepoAndImageBatch(ctx interface{}, registryID interface{}, imageName interface{}, batchSize interface{}, artifactID interface{}) *MockArtifactRepository_GetArtifactsByRepoAndImageBatch_Call {
	return &MockArtifactRepository_GetArtifactsByRepoAndImageBatch_Call{Call: _e.mock.On("GetArtifactsByRepoAndImageBatch", ctx, registryID, imageName, batchSize, artifactID)}
}

func (_c *MockArtifactRepository_GetArtifactsByRepoAndImageBatch_Call) Run(run func(ctx context.Context, registryID int64, imageName string, batchSize int, artifactID int64)) *MockArtifactRepository_GetArtifactsByRepoAndImageBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 int64
		if args[4] != nil {
			arg4 = args[4].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_GetArtifactsByRepoAndImageBatch_Call) Return(artifactMetadatas *[]types.ArtifactMetadata, err error) *MockArtifactRepository_GetArtifactsByRepoAndImageBatch_Call {
	_c.Call.Return(artifactMetadatas, err)
	return _c
}

func (_c *MockArtifactRepository_GetArtifactsByRepoAndImageBatch_Call) RunAndReturn(run func(ctx context.Context, registryID int64, imageName string, batchSize int, artifactID int64) (*[]types.ArtifactMetadata, error)) *MockArtifactRepository_GetArtifactsByRepoAndImageBatch_Call {
	_c.Call.Return(run)
	return _c
}

// GetByName provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) GetByName(ctx context.Context, imageID int64, version string) (*types.Artifact, error) {
	ret := _mock.Called(ctx, imageID, version)

	if len(ret) == 0 {
		panic("no return value specified for GetByName")
	}

	var r0 *types.Artifact
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) (*types.Artifact, error)); ok {
		return returnFunc(ctx, imageID, version)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) *types.Artifact); ok {
		r0 = returnFunc(ctx, imageID, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Artifact)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string) error); ok {
		r1 = returnFunc(ctx, imageID, version)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_GetByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByName'
type MockArtifactRepository_GetByName_Call struct {
	*mock.Call
}

// GetByName is a helper method to define mock.On call
//   - ctx context.Context
//   - imageID int64
//   - version string
func (_e *MockArtifactRepository_Expecter) GetByName(ctx interface{}, imageID interface{}, version interface{}) *MockArtifactRepository_GetByName_Call {
	return &MockArtifactRepository_GetByName_Call{Call: _e.mock.On("GetByName", ctx, imageID, version)}
}

func (_c *MockArtifactRepository_GetByName_Call) Run(run func(ctx context.Context, imageID int64, version string)) *MockArtifactRepository_GetByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_GetByName_Call) Return(artifact1 *types.Artifact, err error) *MockArtifactRepository_GetByName_Call {
	_c.Call.Return(artifact1, err)
	return _c
}

func (_c *MockArtifactRepository_GetByName_Call) RunAndReturn(run func(ctx context.Context, imageID int64, version string) (*types.Artifact, error)) *MockArtifactRepository_GetByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetByRegistryIDAndImage provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) GetByRegistryIDAndImage(ctx context.Context, registryID int64, image string) (*[]types.Artifact, error) {
	ret := _mock.Called(ctx, registryID, image)

	if len(ret) == 0 {
		panic("no return value specified for GetByRegistryIDAndImage")
	}

	var r0 *[]types.Artifact
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) (*[]types.Artifact, error)); ok {
		return returnFunc(ctx, registryID, image)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string) *[]types.Artifact); ok {
		r0 = returnFunc(ctx, registryID, image)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]types.Artifact)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string) error); ok {
		r1 = returnFunc(ctx, registryID, image)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_GetByRegistryIDAndImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByRegistryIDAndImage'
type MockArtifactRepository_GetByRegistryIDAndImage_Call struct {
	*mock.Call
}

// GetByRegistryIDAndImage is a helper method to define mock.On call
//   - ctx context.Context
//   - registryID int64
//   - image string
func (_e *MockArtifactRepository_Expecter) GetByRegistryIDAndImage(ctx interface{}, registryID interface{}, image interface{}) *MockArtifactRepository_GetByRegistryIDAndImage_Call {
	return &MockArtifactRepository_GetByRegistryIDAndImage_Call{Call: _e.mock.On("GetByRegistryIDAndImage", ctx, registryID, image)}
}

func (_c *MockArtifactRepository_GetByRegistryIDAndImage_Call) Run(run func(ctx context.Context, registryID int64, image string)) *MockArtifactRepository_GetByRegistryIDAndImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_GetByRegistryIDAndImage_Call) Return(artifacts *[]types.Artifact, err error) *MockArtifactRepository_GetByRegistryIDAndImage_Call {
	_c.Call.Return(artifacts, err)
	return _c
}

func (_c *MockArtifactRepository_GetByRegistryIDAndImage_Call) RunAndReturn(run func(ctx context.Context, registryID int64, image string) (*[]types.Artifact, error)) *MockArtifactRepository_GetByRegistryIDAndImage_Call {
	_c.Call.Return(run)
	return _c
}

// GetByRegistryImageAndVersion provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) GetByRegistryImageAndVersion(ctx context.Context, registryID int64, image string, version string) (*types.Artifact, error) {
	ret := _mock.Called(ctx, registryID, image, version)

	if len(ret) == 0 {
		panic("no return value specified for GetByRegistryImageAndVersion")
	}

	var r0 *types.Artifact
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string) (*types.Artifact, error)); ok {
		return returnFunc(ctx, registryID, image, version)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string) *types.Artifact); ok {
		r0 = returnFunc(ctx, registryID, image, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Artifact)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, string) error); ok {
		r1 = returnFunc(ctx, registryID, image, version)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_GetByRegistryImageAndVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByRegistryImageAndVersion'
type MockArtifactRepository_GetByRegistryImageAndVersion_Call struct {
	*mock.Call
}

// GetByRegistryImageAndVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - registryID int64
//   - image string
//   - version string
func (_e *MockArtifactRepository_Expecter) GetByRegistryImageAndVersion(ctx interface{}, registryID interface{}, image interface{}, version interface{}) *MockArtifactRepository_GetByRegistryImageAndVersion_Call {
	return &MockArtifactRepository_GetByRegistryImageAndVersion_Call{Call: _e.mock.On("GetByRegistryImageAndVersion", ctx, registryID, image, version)}
}

func (_c *MockArtifactRepository_GetByRegistryImageAndVersion_Call) Run(run func(ctx context.Context, registryID int64, image string, version string)) *MockArtifactRepository_GetByRegistryImageAndVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_GetByRegistryImageAndVersion_Call) Return(artifact1 *types.Artifact, err error) *MockArtifactRepository_GetByRegistryImageAndVersion_Call {
	_c.Call.Return(artifact1, err)
	return _c
}

func (_c *MockArtifactRepository_GetByRegistryImageAndVersion_Call) RunAndReturn(run func(ctx context.Context, registryID int64, image string, version string) (*types.Artifact, error)) *MockArtifactRepository_GetByRegistryImageAndVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestArtifactMetadata provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) GetLatestArtifactMetadata(ctx context.Context, id int64, identifier string, image string) (*types.ArtifactMetadata, error) {
	ret := _mock.Called(ctx, id, identifier, image)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestArtifactMetadata")
	}

	var r0 *types.ArtifactMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string) (*types.ArtifactMetadata, error)); ok {
		return returnFunc(ctx, id, identifier, image)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string) *types.ArtifactMetadata); ok {
		r0 = returnFunc(ctx, id, identifier, image)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ArtifactMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, string) error); ok {
		r1 = returnFunc(ctx, id, identifier, image)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_GetLatestArtifactMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestArtifactMetadata'
type MockArtifactRepository_GetLatestArtifactMetadata_Call struct {
	*mock.Call
}

// GetLatestArtifactMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
//   - identifier string
//   - image string
func (_e *MockArtifactRepository_Expecter) GetLatestArtifactMetadata(ctx interface{}, id interface{}, identifier interface{}, image interface{}) *MockArtifactRepository_GetLatestArtifactMetadata_Call {
	return &MockArtifactRepository_GetLatestArtifactMetadata_Call{Call: _e.mock.On("GetLatestArtifactMetadata", ctx, id, identifier, image)}
}

func (_c *MockArtifactRepository_GetLatestArtifactMetadata_Call) Run(run func(ctx context.Context, id int64, identifier string, image string)) *MockArtifactRepository_GetLatestArtifactMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_GetLatestArtifactMetadata_Call) Return(artifactMetadata *types.ArtifactMetadata, err error) *MockArtifactRepository_GetLatestArtifactMetadata_Call {
	_c.Call.Return(artifactMetadata, err)
	return _c
}

func (_c *MockArtifactRepository_GetLatestArtifactMetadata_Call) RunAndReturn(run func(ctx context.Context, id int64, identifier string, image string) (*types.ArtifactMetadata, error)) *MockArtifactRepository_GetLatestArtifactMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestByImageID provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) GetLatestByImageID(ctx context.Context, imageID int64) (*types.Artifact, error) {
	ret := _mock.Called(ctx, imageID)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestByImageID")
	}

	var r0 *types.Artifact
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) (*types.Artifact, error)); ok {
		return returnFunc(ctx, imageID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64) *types.Artifact); ok {
		r0 = returnFunc(ctx, imageID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Artifact)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = returnFunc(ctx, imageID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_GetLatestByImageID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestByImageID'
type MockArtifactRepository_GetLatestByImageID_Call struct {
	*mock.Call
}

// GetLatestByImageID is a helper method to define mock.On call
//   - ctx context.Context
//   - imageID int64
func (_e *MockArtifactRepository_Expecter) GetLatestByImageID(ctx interface{}, imageID interface{}) *MockArtifactRepository_GetLatestByImageID_Call {
	return &MockArtifactRepository_GetLatestByImageID_Call{Call: _e.mock.On("GetLatestByImageID", ctx, imageID)}
}

func (_c *MockArtifactRepository_GetLatestByImageID_Call) Run(run func(ctx context.Context, imageID int64)) *MockArtifactRepository_GetLatestByImageID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_GetLatestByImageID_Call) Return(artifact1 *types.Artifact, err error) *MockArtifactRepository_GetLatestByImageID_Call {
	_c.Call.Return(artifact1, err)
	return _c
}

func (_c *MockArtifactRepository_GetLatestByImageID_Call) RunAndReturn(run func(ctx context.Context, imageID int64) (*types.Artifact, error)) *MockArtifactRepository_GetLatestByImageID_Call {
	_c.Call.Return(run)
	return _c
}

// SearchByImageName provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) SearchByImageName(ctx context.Context, regID int64, name string, limit int, offset int) (*[]types.ArtifactMetadata, error) {
	ret := _mock.Called(ctx, regID, name, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for SearchByImageName")
	}

	var r0 *[]types.ArtifactMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, int, int) (*[]types.ArtifactMetadata, error)); ok {
		return returnFunc(ctx, regID, name, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, int, int) *[]types.ArtifactMetadata); ok {
		r0 = returnFunc(ctx, regID, name, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]types.ArtifactMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, int, int) error); ok {
		r1 = returnFunc(ctx, regID, name, limit, offset)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_SearchByImageName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchByImageName'
type MockArtifactRepository_SearchByImageName_Call struct {
	*mock.Call
}

// SearchByImageName is a helper method to define mock.On call
//   - ctx context.Context
//   - regID int64
//   - name string
//   - limit int
//   - offset int
func (_e *MockArtifactRepository_Expecter) SearchByImageName(ctx interface{}, regID interface{}, name interface{}, limit interface{}, offset interface{}) *MockArtifactRepository_SearchByImageName_Call {
	return &MockArtifactRepository_SearchByImageName_Call{Call: _e.mock.On("SearchByImageName", ctx, regID, name, limit, offset)}
}

func (_c *MockArtifactRepository_SearchByImageName_Call) Run(run func(ctx context.Context, regID int64, name string, limit int, offset int)) *MockArtifactRepository_SearchByImageName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 int
		if args[4] != nil {
			arg4 = args[4].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_SearchByImageName_Call) Return(artifactMetadatas *[]types.ArtifactMetadata, err error) *MockArtifactRepository_SearchByImageName_Call {
	_c.Call.Return(artifactMetadatas, err)
	return _c
}

func (_c *MockArtifactRepository_SearchByImageName_Call) RunAndReturn(run func(ctx context.Context, regID int64, name string, limit int, offset int) (*[]types.ArtifactMetadata, error)) *MockArtifactRepository_SearchByImageName_Call {
	_c.Call.Return(run)
	return _c
}

// SearchLatestByName provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) SearchLatestByName(ctx context.Context, regID int64, name string, limit int, offset int) (*[]types.Artifact, error) {
	ret := _mock.Called(ctx, regID, name, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for SearchLatestByName")
	}

	var r0 *[]types.Artifact
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, int, int) (*[]types.Artifact, error)); ok {
		return returnFunc(ctx, regID, name, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, int, int) *[]types.Artifact); ok {
		r0 = returnFunc(ctx, regID, name, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*[]types.Artifact)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, int, int) error); ok {
		r1 = returnFunc(ctx, regID, name, limit, offset)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockArtifactRepository_SearchLatestByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchLatestByName'
type MockArtifactRepository_SearchLatestByName_Call struct {
	*mock.Call
}

// SearchLatestByName is a helper method to define mock.On call
//   - ctx context.Context
//   - regID int64
//   - name string
//   - limit int
//   - offset int
func (_e *MockArtifactRepository_Expecter) SearchLatestByName(ctx interface{}, regID interface{}, name interface{}, limit interface{}, offset interface{}) *MockArtifactRepository_SearchLatestByName_Call {
	return &MockArtifactRepository_SearchLatestByName_Call{Call: _e.mock.On("SearchLatestByName", ctx, regID, name, limit, offset)}
}

func (_c *MockArtifactRepository_SearchLatestByName_Call) Run(run func(ctx context.Context, regID int64, name string, limit int, offset int)) *MockArtifactRepository_SearchLatestByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int64
		if args[1] != nil {
			arg1 = args[1].(int64)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 int
		if args[4] != nil {
			arg4 = args[4].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_SearchLatestByName_Call) Return(artifacts *[]types.Artifact, err error) *MockArtifactRepository_SearchLatestByName_Call {
	_c.Call.Return(artifacts, err)
	return _c
}

func (_c *MockArtifactRepository_SearchLatestByName_Call) RunAndReturn(run func(ctx context.Context, regID int64, name string, limit int, offset int) (*[]types.Artifact, error)) *MockArtifactRepository_SearchLatestByName_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateArtifactMetadata provides a mock function for the type MockArtifactRepository
func (_mock *MockArtifactRepository) UpdateArtifactMetadata(ctx context.Context, metadata json.RawMessage, artifactID int64) error {
	ret := _mock.Called(ctx, metadata, artifactID)

	if len(ret) == 0 {
		panic("no return value specified for UpdateArtifactMetadata")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, json.RawMessage, int64) error); ok {
		r0 = returnFunc(ctx, metadata, artifactID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockArtifactRepository_UpdateArtifactMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateArtifactMetadata'
type MockArtifactRepository_UpdateArtifactMetadata_Call struct {
	*mock.Call
}

// UpdateArtifactMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - metadata json.RawMessage
//   - artifactID int64
func (_e *MockArtifactRepository_Expecter) UpdateArtifactMetadata(ctx interface{}, metadata interface{}, artifactID interface{}) *MockArtifactRepository_UpdateArtifactMetadata_Call {
	return &MockArtifactRepository_UpdateArtifactMetadata_Call{Call: _e.mock.On("UpdateArtifactMetadata", ctx, metadata, artifactID)}
}

func (_c *MockArtifactRepository_UpdateArtifactMetadata_Call) Run(run func(ctx context.Context, metadata json.RawMessage, artifactID int64)) *MockArtifactRepository_UpdateArtifactMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 json.RawMessage
		if args[1] != nil {
			arg1 = args[1].(json.RawMessage)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockArtifactRepository_UpdateArtifactMetadata_Call) Return(err error) *MockArtifactRepository_UpdateArtifactMetadata_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockArtifactRepository_UpdateArtifactMetadata_Call) RunAndReturn(run func(ctx context.Context, metadata json.RawMessage, artifactID int64) error) *MockArtifactRepository_UpdateArtifactMetadata_Call {
	_c.Call.Return(run)
	return _c
}
